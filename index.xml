<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>stonex</title>
        <link>https://sheny1xuan.github.io/</link>
        <description>Welcome to my&#39;blog!</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>sheny1xuan@163.com (Shen)</managingEditor>
            <webMaster>sheny1xuan@163.com (Shen)</webMaster><lastBuildDate>Wed, 04 Aug 2021 00:00:00 &#43;0000</lastBuildDate>
            <atom:link href="https://sheny1xuan.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>lc611.有效三角形的个数</title>
    <link>https://sheny1xuan.github.io/lc611/</link>
    <pubDate>Wed, 04 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc611/</guid>
    <description><![CDATA[611.有效三角形的个数 DFS超时 $T:O(2^n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int res = 0; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path, int idx){ if(path.size() &gt;= 3){ int a = path[0], b = path[1],]]></description>
</item><item>
    <title>lc581.最短无序连续子数组</title>
    <link>https://sheny1xuan.github.io/lc581/</link>
    <pubDate>Tue, 03 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc581/</guid>
    <description><![CDATA[581. 最短无序连续子数组 排序+双指针 T:O(nlogn) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; cpy(nums.begin(), nums.end()); sort(cpy.begin(), cpy.end()); int l = -1, r = nums.size(); for(int i = 0; i]]></description>
</item><item>
    <title>lc743.网络延迟时间</title>
    <link>https://sheny1xuan.github.io/lc743/</link>
    <pubDate>Mon, 02 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc743/</guid>
    <description><![CDATA[743. 网络延迟时间 dijkstra最短路问题 题意为找距离k最短路径中的最大值作为传递时间 Cpp Tips:在对象内初始化vector注意事项 class]]></description>
</item><item>
    <title>lc987.二叉树的垂序遍历</title>
    <link>https://sheny1xuan.github.io/lc987/</link>
    <pubDate>Sat, 31 Jul 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc987/</guid>
    <description><![CDATA[987. 二叉树的垂序遍历 利用三元组记录每个节点[列，行，节点值] 之后进行排序，默认的排序方式就是先按列从小到大排序，再按行从小到大排序，最后按节点]]></description>
</item><item>
    <title>lc171.Excel表列序号</title>
    <link>https://sheny1xuan.github.io/lc171/</link>
    <pubDate>Fri, 30 Jul 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc171/</guid>
    <description><![CDATA[171. Excel 表列序号 正向遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int titleToNumber(string columnTitle) { // 正向遍历-&gt;叠加权重 int ans = 0, n = columnTitle.size(); for(int i = 0; i &lt; n; i++){ ans = columnTitle[i] - &#39;A&#39; + ans * 26 +]]></description>
</item><item>
    <title>lc1104.二叉树寻路</title>
    <link>https://sheny1xuan.github.io/lc1104/</link>
    <pubDate>Thu, 29 Jul 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc1104/</guid>
    <description><![CDATA[1104. 二叉树寻路 完全二叉树规律 $i_{father} = i_{child}/2$ 所以先找到该节点对称的结点，再利用完全二叉树的规律即可 完全二叉树一行的开始是$2^{row - 1}$,结束是$]]></description>
</item></channel>
</rss>
