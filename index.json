[{"categories":["每日一题"],"content":"318.最大单词长度乘积 ","date":"2021-11-17","objectID":"/lc318/:1:0","tags":["位运算","leetcode","算法"],"title":"lc318.最大单词长度乘积","uri":"/lc318/"},{"categories":["每日一题"],"content":"位运算哈希 考虑暴力求解，对每一个字符串进行哈希，之后遍历剩余的字符串检查是否重复 $T:O(n^2l)$,$n$是字符串的个数,$l$是每个字符串的平均长度，不能通过。 提前对每个字符串进行哈希，利用26位存储每个字符哈希的结果。$T:O(26*n^2 + nl)$ class Solution { public: int maxProduct(vector\u003cstring\u003e\u0026 words) { int n = words.size(); int ans = 0; vector\u003cint\u003e f(n, 0); for (int i = 0; i \u003c n; i++) { for (auto\u0026 c: words[i]) { f[i] |= 1 \u003c\u003c (c - 'a'); } } for (int i = 0; i \u003c n; i++) { for (int j = i + 1; j \u003c n; j++) { bool ok = true; for (int k = 0; k \u003c 26; k++) { int x = (f[i] \u0026 (1 \u003c\u003c k)), y = (f[j] \u0026 (1 \u003c\u003c k)); if (x \u003e 0 \u0026\u0026 y \u003e 0) { ok = false; break; } } if (ok) { ans = max(ans, (int)words[i].size() * (int)words[j].size()); } } } return ans; } }; ","date":"2021-11-17","objectID":"/lc318/:1:1","tags":["位运算","leetcode","算法"],"title":"lc318.最大单词长度乘积","uri":"/lc318/"},{"categories":["每日一题"],"content":"124.二叉树中的最大路径和 a b c 最大路径可能有三种情况 $b \\rightarrow a \\rightarrow c $ $b \\rightarrow a \\rightarrow a’father$ $c \\rightarrow a \\rightarrow a’father$ 该节点向上返回值为该节点能够提供的最大路径 小于零时，舍弃该结点的儿子结点。 如果以该节点作为最优路径根节点 $path = left + right + root -\u003e val$ 如果该节点作为左右子树的结点 $return \\ max(left, right) + root -\u003e val$ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int ans = INT_MIN; int maxPathSum(TreeNode* root) { dfs(root); return ans; } // return root substree maxval int dfs(TreeNode* root) { if (root == nullptr) { return 0; } int l = dfs(root-\u003eleft); int r = dfs(root-\u003eright); // subtree value ans = max(l + r + root-\u003eval, ans); return max(0, max(l, r) + root-\u003eval); } }; ","date":"2021-11-04","objectID":"/lc124/:1:0","tags":["type","leetcode","算法"],"title":"lc124.二叉树中的最大路径和","uri":"/lc124/"},{"categories":["每日一题"],"content":"类似题目 687. 最长同值路径 543. 二叉树的直径 ","date":"2021-11-04","objectID":"/lc124/:1:1","tags":["type","leetcode","算法"],"title":"lc124.二叉树中的最大路径和","uri":"/lc124/"},{"categories":["每日一题"],"content":"687.最长同值路径 如果是普通的图，那么这个题目就是岛屿问题(DFS)，最大的连通图。 但是由于有限制是单条路径，所以要返回左右子树的路径最大值。 并且在搜索过程中把该节点为根节点作为计算左右子树相加的最大值。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int ans = 0; int longestUnivaluePath(TreeNode* root) { dfs(root); return ans; } // 返回与root值相同的最长同值路径的长度。 int dfs(TreeNode* root) { if (root == nullptr) { return 0; } // 与root-\u003eleft相同的最长同值路径长度 int l = dfs(root-\u003eleft); // 与root-\u003eright相同的最长同值路径长度 int r = dfs(root-\u003eright); // 如果根节点与左子节点值相同，延伸该子树，否则左边路径长度为0 if (root-\u003eleft \u0026\u0026 root-\u003eleft-\u003eval == root-\u003eval) { l += 1; } else { l = 0; } if (root-\u003eright \u0026\u0026 root-\u003eright-\u003eval == root-\u003eval) { r += 1; } else { r = 0; } // 向上延伸或者包含根节点的最大值。 ans = max(l + r, ans); return max(l, r); } }; ","date":"2021-11-02","objectID":"/lc687/:1:0","tags":["树","leetcode","算法"],"title":"lc687.最长同值路径","uri":"/lc687/"},{"categories":["tools"],"content":"Top使用 ","date":"2021-10-31","objectID":"/top/:1:0","tags":["top","性能监控"],"title":"top使用","uri":"/top/"},{"categories":["tools"],"content":"安装Top 默认系统安装 也可以通过源码安装procps-ng获取最新版top. ","date":"2021-10-31","objectID":"/top/:1:1","tags":["top","性能监控"],"title":"top使用","uri":"/top/"},{"categories":["tools"],"content":"通常使用 top进入top界面 默认按照cpu使用率从大到小显示所有进程 按f进入设置界面，可以选择显示的信息，以及排序的资源信息(s)。 ","date":"2021-10-31","objectID":"/top/:1:2","tags":["top","性能监控"],"title":"top使用","uri":"/top/"},{"categories":["tools"],"content":"查看某个进程的资源占用 查看/proc/pid/status ","date":"2021-10-31","objectID":"/top/:1:3","tags":["top","性能监控"],"title":"top使用","uri":"/top/"},{"categories":["tools"],"content":"参考 ","date":"2021-10-31","objectID":"/top/:1:4","tags":["top","性能监控"],"title":"top使用","uri":"/top/"},{"categories":["tools"],"content":"Valgrind使用 ","date":"2021-10-29","objectID":"/valgrind/:1:0","tags":["valgrind","内存泄露"],"title":"Valgrind使用","uri":"/valgrind/"},{"categories":["tools"],"content":"安装Valgrind sudo apt-get install valgrind 通过源码安装 ","date":"2021-10-29","objectID":"/valgrind/:1:1","tags":["valgrind","内存泄露"],"title":"Valgrind使用","uri":"/valgrind/"},{"categories":["tools"],"content":"通常使用 valgrid --log-file=output.log --tool=memcheck --leak-check=full --show-leak-kinds=all your_binary_file --log-file设置输出信息路径 --leak-check=full检测所有的内存使用问题，不仅仅包含内存泄露，还包含其他各种错误使用内存问题。 show-leak-kinds=all显示所有内存泄露的类型。 ","date":"2021-10-29","objectID":"/valgrind/:1:2","tags":["valgrind","内存泄露"],"title":"Valgrind使用","uri":"/valgrind/"},{"categories":["tools"],"content":"内存使用错误 错误配对malloc/free,new/delete Mismatched free() / delete / delete [] ","date":"2021-10-29","objectID":"/valgrind/:1:3","tags":["valgrind","内存泄露"],"title":"Valgrind使用","uri":"/valgrind/"},{"categories":["tools"],"content":"内存泄露的类型 Pointer chain AAA Leak Case BBB Leak Case ------------- ------------- ------------- (1) RRR ------------\u003e BBB DR (2) RRR ---\u003e AAA ---\u003e BBB DR IR (3) RRR BBB DL (4) RRR AAA ---\u003e BBB DL IL (5) RRR ------?-----\u003e BBB (y)DR, (n)DL (6) RRR ---\u003e AAA -?-\u003e BBB DR (y)IR, (n)DL (7) RRR -?-\u003e AAA ---\u003e BBB (y)DR, (n)DL (y)IR, (n)IL (8) RRR -?-\u003e AAA -?-\u003e BBB (y)DR, (n)DL (y,y)IR, (n,y)IL, (_,n)DL (9) RRR AAA -?-\u003e BBB DL (y)IL, (n)DL Pointer chain legend: - RRR: a root set node or DR block - AAA, BBB: heap blocks - ---\u003e: a start-pointer - -?-\u003e: an interior-pointer Leak Case legend: - DR: Directly reachable - IR: Indirectly reachable - DL: Directly lost - IL: Indirectly lost - (y)XY: it's XY if the interior-pointer is a real pointer - (n)XY: it's XY if the interior-pointer is not a real pointer - (_)XY: it's XY in either case 主要有两种Directly lost和Indirectly lost，主要是情况3和情况4。 Possible lost主要针对后面几种情况。 ","date":"2021-10-29","objectID":"/valgrind/:1:4","tags":["valgrind","内存泄露"],"title":"Valgrind使用","uri":"/valgrind/"},{"categories":["tools"],"content":"参考 https://zhuanlan.zhihu.com/p/92074597?utm_source=wechat_session\u0026utm_medium=social\u0026utm_oi=792314251669823488 ","date":"2021-10-29","objectID":"/valgrind/:1:5","tags":["valgrind","内存泄露"],"title":"Valgrind使用","uri":"/valgrind/"},{"categories":["每日一题"],"content":"869.重新排序得到 2 的幂 ","date":"2021-10-28","objectID":"/lc869/:1:0","tags":["DFS","leetcode","算法","排列"],"title":"lc869.重新排序得到 2 的幂","uri":"/lc869/"},{"categories":["每日一题"],"content":"排列+LBit 计算所有的排列 对每一个排列通过LBit判断其是否是2的幂(2的幂只有一位为1)。 T:O(m!)，m是数字的位数，排列的时间复杂度为O(m!) // #define DEBUG class Solution { public: bool ans = false; bool isValid(int x) { // x \u0026 x - 1 将 x 的最高位置位为0 return (x \u0026 x - 1) == 0; } bool reorderedPowerOf2(int x) { string numStr = to_string(x); int n = numStr.size(); sort(numStr.begin(), numStr.end()); vector\u003cbool\u003e vis(n, false); dfs(numStr, 0, vis, 0); return ans; } void dfs(string\u0026 num, int idx, vector\u003cbool\u003e\u0026 vis, int path) { #ifdef DEBUG cout \u003c\u003c path \u003c\u003c endl; #endif if (idx == num.size()) { if (isValid(path)) { ans = true; } return; } for (int i = 0; i \u003c num.size(); i++) { // frefix if (path == 0 \u0026\u0026 num[i] == '0') { continue; } // delete same num if (i \u003e 0 \u0026\u0026 num[i] == num[i - 1] \u0026\u0026 vis[i - 1] == false) { continue; } if (ans == true) { return ; } if (vis[i] == false) { vis[i] = true; dfs(num, idx + 1, vis, path * 10 + num[i] - '0'); vis[i] = false; } } } }; ","date":"2021-10-28","objectID":"/lc869/:1:1","tags":["DFS","leetcode","算法","排列"],"title":"lc869.重新排序得到 2 的幂","uri":"/lc869/"},{"categories":["每日一题"],"content":"378.有序矩阵中第 K 小的元素 如何判断一个数num在矩阵中处于第k小？从左下角向上移动，如果当前位置matrix[x][y] \u003c= num，那么说明这一列前面所有的行都比该数小，那么叠加x+1，列向右移动y+=1。否则x向上移动(也就是行向上移动)，直到满足matrix[x][y] \u003c= num或者移动出有序矩阵。 知道如何判断一个数处于第k大之后，那么我们可以将l=matrix[0][0], r=matrix[m-1][n-1]，对于这个区间内的数字进行二分查找，查找第一个满足处于第k小的元素。 这个元素一定在矩阵当中。举例[1, 2, 4, 10]，k=3，对任意数4\u003c=x\u003c10均满足在矩阵中满足条件的元素个数cnt=3，但是第一个满足cnt=3的元素一定是4，因为它包含等于的情况， 也就是它自己。 $T:O(nlog(r-l))$，r是矩阵中的最大值，l是矩阵中的最小值，n是矩阵的大小 class Solution { public: bool check(int t, vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int k) { int cnt = 0; int m = matrix.size(), n = matrix[0].size(); // 查找左下角满足条件个数 int x = m - 1, y = 0; while (x \u003e= 0 \u0026\u0026 y \u003c n) { if (matrix[x][y] \u003c= t) { // 向右移动 cnt += x + 1; y += 1; } else { // 向上移动 x -= 1; } } // cnt \u003e= k说明当前数过大，向左收缩边界 return cnt \u003e= k; } int kthSmallest(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int k) { int m = matrix.size(), n = matrix[0].size(); int l = matrix[0][0], r = matrix[m - 1][n - 1]; // 二分查找第一个[(矩阵左下角小于等于该元素个数)大于等于k]的值。 while (l \u003c r) { int mid = ((r - l) \u003e\u003e 1) + l; if (check(mid, matrix, k)) { r = mid; } else { l = mid + 1; } } // l一定在矩阵当中 // 因为第一个满足条件的个数大于等于k的元素肯定在矩阵中。 // 如示例1 ,k = 8 时, res = 13, 当mid为14时也满足条件，但是由于我们找的是第一个，所以他会向左收缩边界(r = mid)。 return l; } }; ","date":"2021-10-25","objectID":"/lc378/:1:0","tags":["二分查找","leetcode","算法","矩阵"],"title":"lc378.有序矩阵中第K小的元素","uri":"/lc378/"},{"categories":["每日一题"],"content":"638.大礼包 DFS 将每个单独的商品处理成一个礼包 对于每一个礼包有两种选择(好像完全背包问题):直接选择下一个礼包;继续选择这个礼包。 $T:O((m+n)*k^{m+n})$，$k$是每个礼包最多选择的次数，$n$是物品的个数，$m$是大礼包的个数，搜索$k^{m+n}$，每次搜索内部需要对$m+n$个大礼包进行对比。$k(10),m(100),n(10),(m+n)*k^{m+n}$感觉过不了，但是题目数据应该比较弱，实际的复杂度只有$O(m+n)*k^n=10^8$ class Solution { public: int ans = INT_MAX; // check current have whether satisfy the needs bool checkItemsEqual(vector\u003cint\u003e\u0026 needs, vector\u003cint\u003e\u0026 have) { for (int i = 0; i \u003c needs.size(); i++) { if(needs[i] != have[i]) { return false; } } return true; } // check current add this special whether more than the needs bool checkItemsMore(vector\u003cint\u003e\u0026 needs, vector\u003cint\u003e\u0026 have, vector\u003cint\u003eshoppingOffer) { for (int i = 0; i \u003c needs.size(); i++) { if(have[i] + shoppingOffer[i] \u003e needs[i]) { return false; } } return true; } // inc to have or dec from have void add(vector\u003cint\u003e\u0026 shoppingOffer, vector\u003cint\u003e\u0026 have, bool inc) { if(inc) { for (int i = 0; i \u003c shoppingOffer.size(); i++) { have[i] += shoppingOffer[i]; } } else { for (int i = 0; i \u003c shoppingOffer.size(); i++) { have[i] -= shoppingOffer[i]; } } } void dfs(vector\u003cvector\u003cint\u003e\u003e\u0026 special, vector\u003cint\u003e\u0026 needs, vector\u003cint\u003e\u0026 have, int idx) { if (idx == special.size()) { if (checkItemsEqual(needs, have)) { ans = min(have.back(), ans); } return; } // don't choose this idx dfs(special, needs, have, idx+1); // choose this idx if (checkItemsMore(needs, have, special[idx])) { add(special[idx], have, true); dfs(special, needs, have, idx); add(special[idx], have, false); } } int shoppingOffers(vector\u003cint\u003e\u0026 price, vector\u003cvector\u003cint\u003e\u003e\u0026 special, vector\u003cint\u003e\u0026 needs) { int n = price.size(); // view a item as a shopping offers. for (int i = 0; i \u003c n; i++) { vector\u003cint\u003e t(n + 1, 0); t[i] = 1; t[n] = price[i]; // add this to shopping offers special.push_back(t); } // current items and prices vector\u003cint\u003e have(n + 1, 0); dfs(special, needs, have, 0); return ans; } }; ","date":"2021-10-24","objectID":"/lc638/:1:0","tags":["DFS","leetcode","算法"],"title":"lc638.大礼包","uri":"/lc638/"},{"categories":["每日一题"],"content":"1755.最接近目标值的子序列和 ","date":"2021-10-21","objectID":"/lc1775/:1:0","tags":["二分","leetcode","算法"],"title":"lc1755.最接近目标值的子序列和","uri":"/lc1775/"},{"categories":["每日一题"],"content":"折半搜索 数据范围比较小，但是没有到小到可以直接搜索的地步。 可以将整个数据分成两部分分别进行搜索，最后进行合并即可。 考虑这道题，如果是直接暴力求出所有的子集，并且计算每个子集与target的差值，那么时间复杂度是$n*2^n$，这里n的取值是40，直接暴力搜索会超时。 但是如果考虑将n分为两部分，分别对每部分内部进行搜索，时间复杂度可以优化到$n*2^{n/2}$。 之后需要对两部分的子集进行合并，也就是两数之和问题。先将两个子集和进行排序，然后通过双指针进行查找最接近目标值的子序列和。 // #define DEBUG class Solution { public: int minAbsDifference(vector\u003cint\u003e\u0026 nums, int goal) { int n = nums.size(); int ln = n / 2; int rn = n - ln; vector\u003clong long\u003e lsum((1 \u003c\u003c ln), 0); vector\u003cint\u003e lnums(nums.begin(), nums.begin() + ln); vector\u003clong long\u003e rsum((1 \u003c\u003c rn), 0); vector\u003cint\u003e rnums(nums.begin() + ln, nums.end()); for (int i = 0; i \u003c (1 \u003c\u003c ln); i++) { long long cal = 0; for (int j = 0; (1 \u003c\u003c j) \u003c= i; j++) { if ((1 \u003c\u003c j) \u0026 i) { cal += lnums[ln - j - 1]; } } lsum[i] = cal; } for (int i = 0; i \u003c (1 \u003c\u003c rn); i++) { long long cal = 0; for (int j = 0; (1 \u003c\u003c j) \u003c= i; j++) { if ((1 \u003c\u003c j) \u0026 i) { cal += rnums[rn - j - 1]; } } rsum[i] = cal; } long long ans = LONG_MAX; cout \u003c\u003c ans \u003c\u003c endl; // left for (auto\u0026 x: lsum) { ans = min(ans, abs(goal - x)); #ifdef DEBUG cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c abs(goal - x) \u003c\u003c endl; cout \u003c\u003c ans \u003c\u003c endl; #endif } // right for (auto\u0026 x: rsum) { ans = min(ans, abs(goal - x)); #ifdef DEBUG cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c abs(goal - x) \u003c\u003c endl; cout \u003c\u003c ans \u003c\u003c endl; #endif } // left \u0026 right int l = 0, r = rsum.size() - 1; sort(lsum.begin(), lsum.end()); sort(rsum.begin(), rsum.end()); while (l \u003c lsum.size() \u0026\u0026 r \u003e= 0) { int cal = lsum[l] + rsum[r]; #ifdef DEBUG cout \u003c\u003c l \u003c\u003c \" \" \u003c\u003c r \u003c\u003c \" \" \u003c\u003c abs(cal - goal) \u003c\u003c endl; #endif ans = min(ans, abs(cal - goal)); if (cal \u003e goal) { r -= 1; } else { l += 1; } } return ans; } long long min(long long x, long long y) { return x \u003c y ? x : y; } }; ","date":"2021-10-21","objectID":"/lc1775/:1:1","tags":["二分","leetcode","算法"],"title":"lc1755.最接近目标值的子序列和","uri":"/lc1775/"},{"categories":["每日一题"],"content":"参考： https://leetcode-cn.com/problems/closest-subsequence-sum/solution/zhuang-ya-dp-zhi-cong-kan-shu-ju-fan-wei-kve3/ https://www.acwing.com/blog/content/32/ ","date":"2021-10-21","objectID":"/lc1775/:1:2","tags":["二分","leetcode","算法"],"title":"lc1755.最接近目标值的子序列和","uri":"/lc1775/"},{"categories":["每日一题"],"content":"453.最小操作次数使数组元素相等 使其他每个元素就是相当于对一个元素减1 操作到最后所有元素应该等于最小的元素。 class Solution { public: int minMoves(vector\u003cint\u003e\u0026 nums) { int min_ele = *min_element(nums.begin(), nums.end()); int ans = 0; for(auto\u0026 x: nums) { ans += x - min_ele; } return ans; } }; ","date":"2021-10-20","objectID":"/lc453/:1:0","tags":["数组","leetcode","算法"],"title":"lc453.最小操作次数使数组元素相等","uri":"/lc453/"},{"categories":["每日一题"],"content":"211.添加与搜索单词 - 数据结构设计 ","date":"2021-10-19","objectID":"/lc211/:1:0","tags":["设计","leetcode","算法","字典树"],"title":"lc211.添加与搜索单词 - 数据结构设计","uri":"/lc211/"},{"categories":["每日一题"],"content":"Trie的通配符匹配 需要新建一个TrieNode表示Trie树的结点。 对于通配符.需要遍历所有的子树，所以普通的搜索方法不再适用，需要适用DFS/BFS遍历所有的子节点。 后续遍历释放每一个结点的内存 struct trierNode { trierNode* child[26]; bool isEnd; trierNode() { for(int i = 0; i \u003c 26; i++) { child[i] = nullptr; } isEnd = false; } }; class trier { public: trierNode* root; public: trier() { root = new trierNode; } ~trier() { // 后续遍历析构 delhelp(root); } void addWord(string word) { trierNode* cur = root; for(auto\u0026 c: word) { if(cur-\u003echild[c - 'a'] == nullptr) { cur-\u003echild[c - 'a'] = new trierNode; } cur = cur-\u003echild[c - 'a']; } cur-\u003eisEnd = true; } bool search(string word) { trierNode* cur = root; return dfs(cur, word, 0); } private: bool dfs(trierNode* node, string\u0026 word, int idx) { if(node == nullptr) { return false; } if(idx \u003e= word.size()) { return node-\u003eisEnd; } if(word[idx] == '.') { for(int i = 0; i \u003c 26; i++) { if(dfs(node-\u003echild[i], word, idx + 1)) { return true; } } } else { return dfs(node-\u003echild[word[idx] - 'a'], word, idx + 1); } return false; } void delhelp(trierNode* node) { if(node == nullptr) { return; } for(int i = 0; i \u003c 26; i++) { delhelp(node-\u003echild[i]); } delete node; } }; class WordDictionary { public: trier* mt; WordDictionary() { mt = new trier; } ~WordDictionary() { delete mt; } void addWord(string word) { mt-\u003eaddWord(word); } bool search(string word) { return mt-\u003esearch(word); } }; /** * Your WordDictionary object will be instantiated and called as such: * WordDictionary* obj = new WordDictionary(); * obj-\u003eaddWord(word); * bool param_2 = obj-\u003esearch(word); */ ","date":"2021-10-19","objectID":"/lc211/:1:1","tags":["设计","leetcode","算法","字典树"],"title":"lc211.添加与搜索单词 - 数据结构设计","uri":"/lc211/"},{"categories":["每日一题"],"content":"2033.获取单值网格的最小操作数 ","date":"2021-10-18","objectID":"/lc2033/:1:0","tags":["数学","leetcode","算法"],"title":"lc2033.获取单值网格的最小操作数","uri":"/lc2033/"},{"categories":["每日一题"],"content":"中位数 什么情况下，所有的数都可以通过加减x变为同一个数。可以选择第一个数作为base，其他所有的数与base的差值都是x的倍数，那么这些数就可以通过变换变为同一个数 [base, base+x, base+2x, base+3x] 如果这些数字都可以变为同一个数，那么哪一个数字y是最佳的数字呢。 需要找的是min(|x1 - y| + |x2 - y| + |x3 - y| ... + |xn - y|) 那么y就是中位数距离所有的点都是最近的点。 // #define DEBUG class Solution { public: int minOperations(vector\u003cvector\u003cint\u003e\u003e\u0026 grid, int x) { int n = grid.size(), m = grid[0].size(); vector\u003cint\u003e f; int base = grid[0][0]; for(auto\u0026 g: grid) { for(auto\u0026 c: g) { if((c - base) % x != 0) { return -1; } f.push_back(c); } } sort(f.begin(), f.end()); int ans = 0; #ifdef DEBUG printv(f); cout \u003c\u003c f[m * n / 2] \u003c\u003c endl; #endif for(int i = 0; i \u003c f.size(); i++) { ans += abs(f[m * n / 2] - f[i]) / x; } return ans; } void printv(vector\u003cint\u003e\u0026 v) { for(int i = 0; i \u003c v.size(); i++) { cout \u003c\u003c v[i] \u003c\u003c ' '; } cout \u003c\u003c endl; } }; ","date":"2021-10-18","objectID":"/lc2033/:1:1","tags":["数学","leetcode","算法"],"title":"lc2033.获取单值网格的最小操作数","uri":"/lc2033/"},{"categories":["每日一题"],"content":"38.外观数列 ","date":"2021-10-15","objectID":"/lc38/:1:0","tags":["字符串","leetcode","算法"],"title":"lc38.外观数列","uri":"/lc38/"},{"categories":["每日一题"],"content":"字符串模拟 双指针逐位进行模拟。 注意最后结尾的时候，要对最后的字符进行单独处理。 class Solution { public: string countAndSay(int n) { string ans = \"1\"; while(--n) { string t = \"\"; for(int i = 0, j = 0; j \u003c ans.size(); ) { if(ans[j] != ans[i] ) { // j - i \u003e= 0 t += to_string(j - i); t += ans[i]; i = j; } j ++; if(j == ans.size()) { t += to_string(j - i); t += ans[i]; } } ans = t; } return ans; } }; ","date":"2021-10-15","objectID":"/lc38/:1:1","tags":["字符串","leetcode","算法"],"title":"lc38.外观数列","uri":"/lc38/"},{"categories":["每日一题"],"content":"29.两数相除 ","date":"2021-10-12","objectID":"/lc29/:1:0","tags":["type","leetcode","算法"],"title":"lc29.两数相除","uri":"/lc29/"},{"categories":["每日一题"],"content":"二分查找+快速乘 快速乘：根据每一位的权重进行乘法。 对于$y/x$查找第一个$x*?\u003cy$的数。 $T:O(log^2n)$,快速乘$log(n)$，二分查找$log(n)$,$n$为32位数字表示的最大的数字。 class Solution { public: using ll = long long; int divide(int dividend, int divisor) bool neg = false; if((dividend ^ divisor) \u003c 0) { neg = true; } ll x = dividend, y = divisor; if(x \u003c 0) { x = -x; } if(y \u003c 0) { y = -y; } // 找到最后一个y*? \u003c= x ll l = 0, r = x; while(l \u003c r) { ll mid = (r - l + 1 \u003e\u003e 1) + l; cout \u003c\u003c mid \u003c\u003c endl; if(mul(mid, y) \u003c= x) { l = mid; } else { r = mid - 1; } } l = neg ? -l : l; if(l \u003e INT_MAX) return INT_MAX; return l; } ll mul(ll x, ll y) { ll ans = 0; while(x) { if(x \u0026 1) { ans += y; } x \u003e\u003e= 1; y += y; } return ans; } }; ","date":"2021-10-12","objectID":"/lc29/:1:1","tags":["type","leetcode","算法"],"title":"lc29.两数相除","uri":"/lc29/"},{"categories":["每日一题"],"content":"441.排列硬币 二分查找 1-k行求和相当于等差数列求和s=(k+1)k/2 目的是求出来最后一个行的和小于等于n的行。 注意会爆int $T:O(n)$ class Solution { public: int arrangeCoins(int n) { int l = 1, r = n; if(n == 1) return 1; // 找最后一个小于等于n的数 while(l \u003c r) { int mid = (r - l + 1 \u003e\u003e 1) + l; if((long long) mid * (mid + 1) \u003c= n * 2ll) { l = mid; } else { r = mid - 1; } } return l; } }; ","date":"2021-10-10","objectID":"/lc441/:1:0","tags":["二分查找","leetcode","算法"],"title":"lc441.排列硬币","uri":"/lc441/"},{"categories":["每日一题"],"content":"352.将数据流变为多个不相交区间 ","date":"2021-10-09","objectID":"/lc352/:1:0","tags":["平衡树","leetcode","算法"],"title":"lc352.将数据流变为多个不相交区间","uri":"/lc352/"},{"categories":["每日一题"],"content":"有序哈希 可以考虑将一个区间左值作为key，右值作为val进行哈希。 每次加入一个值考虑其最近的两个区间，这里可以考虑第一个左值大于该值的区间p1={l1,r1}和最后一个左值小于等于该值的区间p0={l0,r0}。 p1可以通过upper_bound()得到，p0可以通过迭代器prev得到，这里主要考虑p1前面没有元素的情况。 prev(it, n = 1)获取迭代器的第前n个元素指针，默认n为1 next(it, n = 1)获取迭代器的第后n个元素指针，默认n为1 考虑一下五种情况 l0\u003c=val\u003c=r0在p0区间内，则加入该值不需要任何操作，直接返回即可。 val == r0 + 1 \u0026\u0026 val == l1 - 1，这个时候需要合并两个区间，注意需要提前存储节点值，之后删除结点，合并后的区间为{l0, r1} val == r0 + 1 \u0026\u0026 val != l1 - 1，这个时候需要扩展p0区间，p0={l0, val} val != r0 + 1 \u0026\u0026 val == l1 - 1，这个时候需要扩展p1区间，p1={val, r1} val不满足以上任何一种情况，{val, val}单独是一个区间 class SummaryRanges { public: map\u003cint, int\u003e mp; SummaryRanges() { } void addNum(int val) { // the first one gt val auto p1 = mp.upper_bound(val); // the most close left area auto p0 = (p1 == mp.begin()) ? mp.end() : prev(p1); if(p0 != mp.end() \u0026\u0026 val \u003e= p0-\u003efirst \u0026\u0026 val \u003c= p0-\u003esecond) { // don't do anything // 1. [l0, ..., val, ... , r0] return; } bool left = (p0 != mp.end()) \u0026\u0026 (p0-\u003esecond == val - 1); bool right = (p1 != mp.end()) \u0026\u0026 (p1-\u003efirst == val + 1); if(left \u0026\u0026 right) { // 2. [l0, ..., val, ..., r1] int l = p0-\u003efirst, r = p1-\u003esecond; mp.erase(p0); mp.erase(p1); mp.emplace(l, r); } else if (right) { // 3. [val, ..., r1] int r = p1-\u003esecond; mp.erase(p1); mp.emplace(val, r); } else if (left) { // 4. [l0, val] p0-\u003esecond += 1; } else { mp.emplace(val, val); } } vector\u003cvector\u003cint\u003e\u003e getIntervals() { vector\u003cvector\u003cint\u003e\u003e ans; for(const auto\u0026 [f, s]: mp) { ans.push_back({f, s}); } return ans; } }; /** * Your SummaryRanges object will be instantiated and called as such: * SummaryRanges* obj = new SummaryRanges(); * obj-\u003eaddNum(val); * vector\u003cvector\u003cint\u003e\u003e param_2 = obj-\u003egetIntervals(); */ ","date":"2021-10-09","objectID":"/lc352/:1:1","tags":["平衡树","leetcode","算法"],"title":"lc352.将数据流变为多个不相交区间","uri":"/lc352/"},{"categories":["cpp"],"content":"右值引用：延长临时变量的生命周期，解决将亡值的问题 ","date":"2021-10-08","objectID":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:1:0","tags":["ModernCpp","右值引用"],"title":"ModernCpp-右值引用","uri":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["cpp"],"content":"认识右值引用 考虑如下一种情况，下面这样情况，由于x是一个临时变量，在代码块结束后，因为该变量生命周期结束，再使用其地址将会不安全，这里直接会出现segement fault，因为引用了错误的地址。 这里解决方法有两个，可以选择将x定义在堆上，或者直接返回值。定义在堆上，如果管理不慎会出现内存泄露的问题。返回返回值又会产生额外的开销。 int\u0026 func1() { // x 是左值 int x = 100; return x; } 所以cpp对左值和右值进行了区分。 左值简单理解就是等号左边可以赋值的值，代表变量对内存有所有权(变量是内存的别名)，表达式结束后使用该变量的地址是安全的。 右值是临时变量，表达式结束后就不存在的临时变量。右值又分为将亡值和纯右值。 纯右值指的是纯粹字面量，求值的临时变量，匿名变量等等。注意字符串在类中是纯右值，普通函数中是左值。 将亡值是指的代码段结束后，即将被销毁，但是可以被移动的值，左值会在代码段结束后转换为将亡值。func1中的x在函数代码块运行中是一个左值，但是在函数结束后，他就是一个将亡值，代码段结束后他即将被销毁。将亡值只是一个概念，并不存在真正的将亡值，如果需要这个这个左值延长生命周期，则通过std::move()将左值转换为右值进行引用。 通过右值引用可以延长func1中x的生命周期，但是需要通过std::move()将x转换为右值使用。这里std::move()只是将左值转换为右值，并没有智能指针中转交所有权的意思，被转换的变量仍可以调用这块内存。 int func2() { // x是左值 int x = 100; return x; } int\u0026\u0026 y = func2(); // y会捕获x的将亡值，延长其生命周期 右值引用只可以引用右值，std::move()可以将左值转换为右值，从而延长临时变量的生命周期。左值会在代码段结束后变为将亡值。 非常量左值引用只能引用左值，常量左值引用可以引用右值。 需要注意的是，一个变量虽然引用的是右值，但这个变量仍是一个左值，它不是一个临时对象，也不是纯粹的字面量。 // 注意这里a和b虽然都是引用的右值，但是他们是左值 int\u0026\u0026 a = 2; const int\u0026 b = 2; int\u0026 b = 2; // error ","date":"2021-10-08","objectID":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:1:1","tags":["ModernCpp","右值引用"],"title":"ModernCpp-右值引用","uri":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["cpp"],"content":"实例 两个string对象相加会产生临时的string对象。 这里std::move()只是将左值转换为右值，并没有智能指针中转交所有权的意思，被转换的变量仍可以调用这块内存。 int main() { std::string lv1 = \"string\"; // 左值 std::string\u0026\u0026 rv1 = std::move(lv1); // 临时lv1转换为右值，之后lv1仍是一个左值。 // lv1与rv1共享内存 lv1[0] = 'a'; std::cout \u003c\u003c rv1 \u003c\u003c '\\n'; std::cout \u003c\u003c lv1 \u003c\u003c '\\n'; std::string\u0026\u0026 lv2 = lv1 + lv1; // lv1 + lv1 是一个右值，lv2可以引用右值。 const std::string\u0026 lv3 = lv1 + lv2; // 常量左值引用可以引用右值 return 0; } output: atring atring ","date":"2021-10-08","objectID":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:1:2","tags":["ModernCpp","右值引用"],"title":"ModernCpp-右值引用","uri":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["cpp"],"content":"std::forward todo:例子不是特别懂 进行参数多次引用的传递，std::forward可以将原来传递的参数是左引用还是右引用进行区分。 ","date":"2021-10-08","objectID":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:1:3","tags":["ModernCpp","右值引用"],"title":"ModernCpp-右值引用","uri":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["cpp"],"content":"右值引用的返回问题 标准 type func() { return val; } type\u0026\u0026 y = val; // 延长val的生命周期 不需要在返回值处进行右值引用，这样会引用到已经被销毁的对象。 不需要将返回值转换为右值，这样会导致编译器无法优化。 ","date":"2021-10-08","objectID":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:1:4","tags":["ModernCpp","右值引用"],"title":"ModernCpp-右值引用","uri":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["cpp"],"content":"参考资料: modern-cpp-tutorial ","date":"2021-10-08","objectID":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:1:5","tags":["ModernCpp","右值引用"],"title":"ModernCpp-右值引用","uri":"/moderncpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["每日一题"],"content":"434.字符串中的单词数 ","date":"2021-10-07","objectID":"/lc434/:1:0","tags":["字符串","leetcode","算法"],"title":"lc434.字符串中的单词数","uri":"/lc434/"},{"categories":["每日一题"],"content":"实现split 双指针 class Solution { public: int countSegments(string s) { int cnt = 0; for(int i = 0, j = 0; j \u003c s.size(); ) { if(s[j] != ' ') { while(s[j] != ' ' \u0026\u0026 j \u003c s.size()) { j ++; } cnt += 1; } else { j ++; i = j; } } return cnt; } }; class Solution: def countSegments(self, s: str) -\u003e int: return len([w for w in s.split(\" \") if w != \"\"]) ","date":"2021-10-07","objectID":"/lc434/:1:1","tags":["字符串","leetcode","算法"],"title":"lc434.字符串中的单词数","uri":"/lc434/"},{"categories":["每日一题"],"content":"414.第三大的数 设置三个哨兵a，b，c，依次为$a\u003eb\u003ec$如果一个数满足在区间内，则可以更新对应的数。 如果num \u003e a, c = b, b = a, a = num 如果a \u003e num \u003e b, c = b, b = num 如果b \u003e num \u003e c, c = num class Solution { public: int thirdMax(vector\u003cint\u003e\u0026 nums) { long a = LONG_MIN, b = LONG_MIN, c = LONG_MIN; for(auto\u0026 num: nums) { if(num \u003e a) { c = b; b = a; a = num; } else if (num \u003e b \u0026\u0026 num \u003c a) { c = b; b = num; } else if (num \u003e c \u0026\u0026 num \u003c b) { c = num; } } return c == LONG_MIN ? a : c; } }; ","date":"2021-10-06","objectID":"/lc414/:1:0","tags":["排序","leetcode","算法"],"title":"lc414.第三大的数","uri":"/lc414/"},{"categories":["cpp"],"content":"迭代器模式 对于一个容器提供一种方法顺序访问容器中的各个元素，而不必暴露该对象的内部表示。 常常使用的方法有:next()下一个元素，hasNext()是否有下一个元素，isend()是否遍历完成，Current()当前元素等等方法。 如果抽象基类的虚函数没有被完全实现的话，不能定义派生类函数，否则会报错invalid new-expression of abstract class type 一个简单的以vector为容器的string 迭代器。 /* * @Descripttion: Iterator * @version: * @Author: Stonex * @Date: 2021-10-05 15:06:04 * @LastEditTime: 2021-10-05 16:04:47 */ #include \u003ciostream\u003e#include \u003cvector\u003e /** * @name: base class */ class Iterator { public: Iterator() {}; ~Iterator() {}; virtual std::string First() = 0; virtual std::string Next() = 0; virtual std::string Current() = 0; virtual bool isEnd() = 0; }; /** * @name: base Objuct */ class Object { public: Object() {}; ~Object() {}; virtual Iterator* createIterator() = 0; virtual int Count() = 0; virtual void Push(std::string) = 0; virtual std::string Get(int) = 0; }; class subIterator: public Iterator { public: subIterator(Object* obj_):Iterator(), obj(obj_), cur(0){} ~subIterator() {} std::string First() { return obj-\u003eGet(0); } std::string Next() { if(cur \u003c obj-\u003eCount() - 1) { cur += 1; return obj-\u003eGet(cur); }else { return nullptr; } } std::string Current() { return obj-\u003eGet(cur); } bool isEnd() { if(cur == obj-\u003eCount() - 1){ return true; }else { return false; } } private: Object* obj; int cur; }; class subObject: public Object { public: subObject() {} subObject(std::vector\u003cstd::string\u003e data_) { data.assign(data_.begin(), data_.end()); } Iterator* createIterator() { // TODO: memory leak return new subIterator(this); } ~subObject() {} std::string Get(int x) { if(x \u003e= 0 \u0026\u0026 x \u003c this-\u003eCount() ) { return data[x]; }else { return nullptr; } } int Count() { return data.size(); } void Push(std::string s) { data.push_back(s); } private: std::vector\u003cstd::string\u003e data; }; int main() { subObject obj; obj.Push(\"tom\"); obj.Push(\"bob\"); auto it = obj.createIterator(); std::cout \u003c\u003c it-\u003eFirst() \u003c\u003c std::endl; while (!it-\u003eisEnd()) { std::cout \u003c\u003c it-\u003eNext() \u003c\u003c std::endl; } } ","date":"2021-10-05","objectID":"/designpattern-%E8%BF%AD%E4%BB%A3%E5%99%A8/:0:1","tags":["设计模式","迭代器模式"],"title":"DesignPattern-迭代器","uri":"/designpattern-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["cpp"],"content":"参考资料 modern-cpp-tutorial https://www.zhihu.com/question/35614219 ","date":"2021-10-05","objectID":"/designpattern-%E8%BF%AD%E4%BB%A3%E5%99%A8/:0:2","tags":["设计模式","迭代器模式"],"title":"DesignPattern-迭代器","uri":"/designpattern-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["每日一题"],"content":"482. 密钥格式化 ","date":"2021-10-04","objectID":"/lc482/:1:0","tags":["type","leetcode","算法"],"title":"lc482.密钥格式化","uri":"/lc482/"},{"categories":["每日一题"],"content":"逆序遍历 逆序遍历可以不必计算因为不够而产生的余数部分。 注意原地操作，由于字符串添加或者删除一个字符的时间复杂度是$O(n)$，所以尽量不原地操作。 class Solution { public: string licenseKeyFormatting(string s, int k) { int n = s.size(); string res = \"\"; for(int i = n - 1; i \u003e= 0; ){ int j = 0; while(j \u003c k \u0026\u0026 i \u003e= 0){ if(s[i] != '-'){ res.push_back(toupper(s[i])); j += 1; } i -= 1; } res.push_back('-'); } int idx = 0; while(res.back() == '-'){ res.pop_back(); } reverse(res.begin(), res.end()); return res; } }; ","date":"2021-10-04","objectID":"/lc482/:1:1","tags":["type","leetcode","算法"],"title":"lc482.密钥格式化","uri":"/lc482/"},{"categories":["seata"],"content":"常量 空指针 ","date":"2021-10-01","objectID":"/seata-at/:0:1","tags":["seata"],"title":"seata-at","uri":"/seata-at/"},{"categories":["seata"],"content":"参考资料 modern-cpp-tutorial https://www.zhihu.com/question/35614219 ","date":"2021-10-01","objectID":"/seata-at/:0:2","tags":["seata"],"title":"seata-at","uri":"/seata-at/"},{"categories":["每日一题"],"content":"223.矩形面积 ","date":"2021-09-30","objectID":"/lc223/:1:0","tags":["模拟","leetcode","算法"],"title":"lc223.矩形面积","uri":"/lc223/"},{"categories":["每日一题"],"content":"简单的考虑 计算两个图形的重叠部分，如果两个图形无重复，直接返回两个图的面积和。 考虑不重叠的情况b1x \u003e= ax2 || ax1 \u003e= bx2 || ay2 \u003c= by1 || ay1 \u003e= by2这四种情况存在时，直接返回面积和。 考虑a总在左边的情况，如果ax1\u003ebx1时，将a，b互换 那么最后重叠的面积就是(min(bx2, ax2) - bx1) * (min(ay2, by2) - max(by1, ay2)) class Solution { public: int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) { int all = get(ax2 - ax1, ay2 - ay1) + get(bx2 - bx1, by2 - by1); if(by1 \u003e= ay2 || ay1 \u003e= by2){ return all; } if(ax1 \u003e= bx2 || bx1 \u003e= ax2){ return all; } if(ax1 \u003e bx1){ return computeArea(bx1, by1, bx2, by2, ax1, ay1, ax2, ay2); } return all - get(min(ax2, bx2) - bx1, min(ay2, by2) - max(by1, ay1)); } int get(int a, int b){ return a * b; } }; ","date":"2021-09-30","objectID":"/lc223/:1:1","tags":["模拟","leetcode","算法"],"title":"lc223.矩形面积","uri":"/lc223/"},{"categories":["每日一题"],"content":"考虑矩形在轴上的投影 矩形a在x,y轴投影分别为(ax1, ax2)，(ay1, ay2)，b同理 a,b需要在两个轴上的投影同时存在时，才能计算重叠部分的面积 在某一个轴上投影有重叠的计算方法min(ax2, bx2) - max(ax1, bx1) \u003e 0 class Solution { public: int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) { int all = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1); int x_both = min(ax2, bx2) - max(ax1, bx1); int y_both = min(ay2, by2) - max(ay1, by1); return all - max(x_both, 0) * max(y_both, 0); } }; ","date":"2021-09-30","objectID":"/lc223/:1:2","tags":["模拟","leetcode","算法"],"title":"lc223.矩形面积","uri":"/lc223/"},{"categories":["每日一题"],"content":"437.路径总和 III ","date":"2021-09-28","objectID":"/lc437/:1:0","tags":["二叉树","leetcode","算法"],"title":"lc437.路径总和 III","uri":"/lc437/"},{"categories":["每日一题"],"content":"dfs+bfs 因为从每个结点开始都有可能向下产生指定的路径和，所以我们可以从每个结点开始遍历，找到从该节点向下的所有的路径和。 class Solution { public: int target, cnt; void dfs(TreeNode* root, int sum){ if(root == nullptr){ return; } int cur = sum + root-\u003eval; if(cur == target){ cnt ++; } dfs(root-\u003eleft, cur); dfs(root-\u003eright, cur); } int pathSum(TreeNode* root, int targetSum) { if(root == nullptr){ return 0; } target = targetSum; cnt = 0; queue\u003cTreeNode*\u003e que; que.push(root); while(!que.empty()){ auto f = que.front(); que.pop(); dfs(f, 0); // cout \u003c\u003c f-\u003eval \u003c\u003c ' ' \u003c\u003c cnt \u003c\u003c endl; if(f-\u003eleft){ que.push(f-\u003eleft); } if(f-\u003eright){ que.push(f-\u003eright); } } return cnt; } }; ","date":"2021-09-28","objectID":"/lc437/:1:1","tags":["二叉树","leetcode","算法"],"title":"lc437.路径总和 III","uri":"/lc437/"},{"categories":["每日一题"],"content":"DFS+DFS 当然这里遍历所有节点和寻找指定结点和的过程都可以通过DFS来做，也可以都通过BFS来做，这里再写一种双DFS的写法 先序遍历访问所有的结点 class Solution { public: int target, cnt; void dfs(TreeNode* root, int sum){ if(root == nullptr){ return; } int cur = sum + root-\u003eval; if(cur == target){ cnt ++; } dfs(root-\u003eleft, cur); dfs(root-\u003eright, cur); } void pre_travel(TreeNode* root){ if(root == nullptr){ return; } dfs(root, 0); pre_travel(root-\u003eleft); pre_travel(root-\u003eright); } int pathSum(TreeNode* root, int targetSum) { target = targetSum; cnt = 0; pre_travel(root); return cnt; } }; ","date":"2021-09-28","objectID":"/lc437/:1:2","tags":["二叉树","leetcode","算法"],"title":"lc437.路径总和 III","uri":"/lc437/"},{"categories":["每日一题"],"content":"371.两整数之和 ","date":"2021-09-26","objectID":"/lc371/:1:0","tags":["位运算","leetcode","算法"],"title":"lc371.两整数之和","uri":"/lc371/"},{"categories":["每日一题"],"content":"不使用+进行加法运算 两个数无进位加法的结果是a^b 两个数产生进位的位是a\u0026b，进位的结果就是(a\u0026b)\u003c\u003c1，重复计算进位与原来数相加的结果，直到进位为0. 需要注意的是，进位左移的结果可能超过INT_MAX，所以需要先将其转换为unsigned int进行使用。 class Solution { public: int getSum(int a, int b) { while(b != 0){ // 产生进位的位为a\u0026b, unsigned int carry = (unsigned int)(a \u0026 b) \u003c\u003c 1; a = a ^ b; b = carry; } return a; } }; ","date":"2021-09-26","objectID":"/lc371/:1:1","tags":["位运算","leetcode","算法"],"title":"lc371.两整数之和","uri":"/lc371/"},{"categories":["每日一题"],"content":"583.两个字符串的删除操作 ","date":"2021-09-25","objectID":"/lc583/:1:0","tags":["动态规划","leetcode","算法"],"title":"lc583.两个字符串的删除操作","uri":"/lc583/"},{"categories":["每日一题"],"content":"最长公共子序列 给定两个字符串word1和word2，找出使两个字符串变为相同需要删除的字母的最少的个数 可以把这个问题转换为最长公共子序列问题，假设word1.size() = n,word2.size() = m，最长公共子序列的长度为k，那么两个字符串需要删除的最少的字母的个数就是等于n + m - 2k 最长公共子序列动态规划状态表示f[i][j]表示长度为i的word1与长度为j的word2的最长公共子序列的长度 对于长度分别为i,j，word1[i - 1]==word2[j - 1]时,f[i][j] = f[i - 1][j - 1] + 1，否则为max(f[i-1][j], f[i][j-1]) class Solution { public: int minDistance(string word1, string word2) { // 最长公共子序列 // f[i][j] // word1长度为i，word2长度为j的最长公共子序列 int n = word1.size(), m = word2.size(); vector\u003cvector\u003cint\u003e\u003e f(n + 1, vector\u003cint\u003e(m + 1, 0)); f[0][0] = 0; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= m; j++){ if(word1[i - 1] == word2[j - 1]){ f[i][j] = f[i - 1][j - 1] + 1; }else{ f[i][j] = max(f[i - 1][j], f[i][j - 1]); } } } return n - f[n][m] + m - f[n][m]; } }; ","date":"2021-09-25","objectID":"/lc583/:1:1","tags":["动态规划","leetcode","算法"],"title":"lc583.两个字符串的删除操作","uri":"/lc583/"},{"categories":["每日一题"],"content":"430.扁平化多级双向链表 ","date":"2021-09-24","objectID":"/lc430/:1:0","tags":["链表","leetcode","算法"],"title":"lc430.扁平化多级双向链表","uri":"/lc430/"},{"categories":["每日一题"],"content":"迭代 没碰到一个有child部分的节点，找到当前节点儿子链表的尾结点tail，将该链表添加到当前链表中，当前节点的child结点置空。 /* // Definition for a Node. class Node { public: int val; Node* prev; Node* next; Node* child; }; */ class Solution { public: Node* get_tail(Node* head){ while(head != nullptr \u0026\u0026 head-\u003enext != nullptr){ head = head-\u003enext; } return head; } Node* flatten(Node* head) { Node* cur = head; while(cur){ if(cur-\u003echild == nullptr){ cur = cur-\u003enext; continue; } Node* child_tail = get_tail(cur-\u003echild); child_tail-\u003enext = cur-\u003enext; if(child_tail-\u003enext){ child_tail-\u003enext-\u003eprev = child_tail; } cur-\u003enext = cur-\u003echild; cur-\u003echild-\u003eprev = cur; cur-\u003echild = nullptr; } return head; } }; ","date":"2021-09-24","objectID":"/lc430/:1:1","tags":["链表","leetcode","算法"],"title":"lc430.扁平化多级双向链表","uri":"/lc430/"},{"categories":["每日一题"],"content":"递归实现 递归返回儿子结点的尾结点，然后将子链表添加到原链表上。 /* // Definition for a Node. class Node { public: int val; Node* prev; Node* next; Node* child; }; */ class Solution { public: Node* flatten(Node* head) { flatten_help(head); return head; } Node* flatten_help(Node* head) { Node* cur = head; Node* last = head; while(cur != nullptr){ last = cur; if(cur-\u003echild == nullptr){ cur = cur -\u003e next; continue; } Node* child_end = flatten_help(cur-\u003echild); // cout \u003c\u003c child_end-\u003eval \u003c\u003c endl; child_end-\u003enext = cur-\u003enext; if(child_end-\u003enext){ child_end-\u003enext-\u003eprev = child_end; }else{ child_end-\u003enext = nullptr; } cur-\u003enext = cur-\u003echild; cur-\u003echild-\u003eprev = cur; cur-\u003echild = nullptr; } // cout \u003c\u003c last-\u003eval \u003c\u003c endl; return last; } }; cpp匿名函数实现递归的方法 cpp匿名函数就是一个自动变量，因此在代码块内并不能找到该函数的地址，因此需要在递归函数中传入该匿名函数的地址，才能正确的递归调用,auto f = [](auto\u0026 f, Node* head)-\u003eNode*{ }; /* // Definition for a Node. class Node { public: int val; Node* prev; Node* next; Node* child; }; */ class Solution { public: Node* flatten(Node* head) { flatten_help(head); return head; } Node* flatten_help(Node* head) { Node* cur = head; Node* last = head; while(cur != nullptr){ last = cur; if(cur-\u003echild == nullptr){ cur = cur -\u003e next; continue; } Node* child_end = flatten_help(cur-\u003echild); // cout \u003c\u003c child_end-\u003eval \u003c\u003c endl; child_end-\u003enext = cur-\u003enext; if(child_end-\u003enext){ child_end-\u003enext-\u003eprev = child_end; }else{ child_end-\u003enext = nullptr; } cur-\u003enext = cur-\u003echild; cur-\u003echild-\u003eprev = cur; cur-\u003echild = nullptr; } // cout \u003c\u003c last-\u003eval \u003c\u003c endl; return last; } }; ","date":"2021-09-24","objectID":"/lc430/:1:2","tags":["链表","leetcode","算法"],"title":"lc430.扁平化多级双向链表","uri":"/lc430/"},{"categories":["每日一题"],"content":"725.分隔链表 计算每一部分的长度之后，每次数出指定长度的结点即可。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: int get_list_length(ListNode* head){ int ans = 0; while(head){ ans += 1; head = head-\u003enext; } return ans; } vector\u003cListNode*\u003e splitListToParts(ListNode* head, int k) { int len = get_list_length(head); vector\u003cListNode*\u003e ans(k); int base = len / k, offset = len % k; ListNode* cur = head; for(int i = 0; i \u003c k \u0026\u0026 cur != nullptr; i++){ ans[i] = cur; int target = base; if(offset \u003e 0){ target += 1; offset -= 1; } for(int j = 1; j \u003c target; j++){ cur = cur-\u003enext; } ListNode* ne = cur-\u003enext; cur-\u003enext = nullptr; cur = ne; } return ans; } }; ","date":"2021-09-22","objectID":"/lc725/:1:0","tags":["链表","leetcode","算法"],"title":"lc725.分隔链表","uri":"/lc725/"},{"categories":["每日一题"],"content":"58.最后一个单词的长度 ","date":"2021-09-21","objectID":"/lc58/:1:0","tags":["字符串","leetcode","算法"],"title":"lc58.最后一个单词的长度","uri":"/lc58/"},{"categories":["每日一题"],"content":"从后往前遍历，找到最后一个单词 class Solution { public: int lengthOfLastWord(string s) { int n = s.size(); int idx = n - 1, ans = 0; while(s[idx] == ' '){ idx --; } while(idx \u003e= 0 \u0026\u0026 s[idx] != ' '){ idx --; ans ++; } return ans; } }; ","date":"2021-09-21","objectID":"/lc58/:1:1","tags":["字符串","leetcode","算法"],"title":"lc58.最后一个单词的长度","uri":"/lc58/"},{"categories":["每日一题"],"content":"利用split得到所有空格分开的字符串 class Solution { public: vector\u003cstring\u003e split(string\u0026 s){ vector\u003cstring\u003e ans; int n = s.size(); for(int i = 0, j = 0; j \u003c n;){ if(s[j] == ' '){ if(i == j){ i++, j++; }else{ ans.push_back(s.substr(i, j - i)); j ++; i = j; } }else{ j++; } if(j == n){ if(i != j){ ans.push_back(s.substr(i, j - i)); } } } return ans; } int lengthOfLastWord(string s) { vector\u003cstring\u003e ans = split(s); return ans.back().size(); } }; ","date":"2021-09-21","objectID":"/lc58/:1:2","tags":["字符串","leetcode","算法"],"title":"lc58.最后一个单词的长度","uri":"/lc58/"},{"categories":["每日一题"],"content":"673.最长递增子序列的个数 维护一个计数数组，记录每个递增子序列的个数。 按照最长递增子序列的遍历方式，如果$nums[i] \u003e nums[j]$ 如果$f[i] == f[j] + 1$说明加入当前为以$i$结尾的最长子序列的话，那么可以构成一个新的子序列，可以在$cnt[i]$中叠加$cnt[j]$（不能加一，需要加所有以$j$结尾最长递增子序列的个数） 如果$f[i] \u003c f[j] + 1$说明加入当前为以$i$结尾的最长子序列的长度可以被更新，可以更新$cnt[i]$为$cnt[i] = cnt[j]$。 最后，如果$f[i] = maxn$，最终结果叠加$cnt[i]$，否则用$cnt[i]$更新最终结果 $T:O(n^2)$ class Solution { public: int findNumberOfLIS(vector\u003cint\u003e\u0026 nums) { int n = nums.size(), ans = 0, maxn = 0; vector\u003cint\u003e f(n), cnt(n); for(int i = 0; i \u003c n; i++){ f[i] = 1; cnt[i] = 1; for(int j = 0; j \u003c i; j++){ if(nums[j] \u003c nums[i]){ if(f[j] + 1 == f[i]){ // 如果f[j] + 1 = f[i],表示当前这种又出现了一次最长递增子序列。 // 叠加j的数量 cnt[i] += cnt[j]; }else if(f[j] + 1 \u003e f[i]){ // 如果f[j] + 1 \u003e f[i],表示当前以i结尾的最长递增子序列可以更新。 cnt[i] = cnt[j]; f[i] = f[j] + 1; } } } if(maxn == f[i]){ ans += cnt[i]; }else if(f[i] \u003e maxn){ maxn = f[i]; ans = cnt[i]; } } return ans; } }; ","date":"2021-09-20","objectID":"/lc673/:1:0","tags":["动态规划","leetcode","算法"],"title":"lc673.最长递增子序列的个数","uri":"/lc673/"},{"categories":["每日一题"],"content":"650.只有两个键的键盘 ","date":"2021-09-19","objectID":"/lc650/:1:0","tags":["动态规划","leetcode","算法"],"title":"lc650.只有两个键的键盘","uri":"/lc650/"},{"categories":["每日一题"],"content":"动态规划 $O(n^2)$ 考虑状态$f[i]$为输出恰好为$i$个$A$时的最少操作此时 ${i % j == 0}, f[i] = min{(f[i], f[j] + i / j)}$，对$j$复制一次，粘贴$i/j$次 class Solution { public: int minSteps(int n) { vector\u003cint\u003e f(n + 1, 0); for(int i = 2; i \u003c= n; i++){ f[i] = INT_MAX; for(int j = 1; j \u003c i; j++){ if(i % j == 0){ f[i] = min(f[i], f[j] + i / j); } } } return f[n]; } }; ","date":"2021-09-19","objectID":"/lc650/:1:1","tags":["动态规划","leetcode","算法"],"title":"lc650.只有两个键的键盘","uri":"/lc650/"},{"categories":["每日一题"],"content":"动态规划优化 $O(n\\sqrt{n})$ class Solution { public: int minSteps(int n) { vector\u003cint\u003e f(n + 1, 0); for(int i = 2; i \u003c= n; i++){ f[i] = INT_MAX; for(int j = 1; j * j \u003c= i; j++){ if(i % j == 0){ int a = j, b = i / j; f[i] = min(f[i], f[a] + b); f[i] = min(f[i], f[b] + a); } } } return f[n]; } }; ","date":"2021-09-19","objectID":"/lc650/:1:2","tags":["动态规划","leetcode","算法"],"title":"lc650.只有两个键的键盘","uri":"/lc650/"},{"categories":["每日一题"],"content":"292. Nim 游戏 ","date":"2021-09-18","objectID":"/lc292/:1:0","tags":["博弈论","leetcode","算法"],"title":"lc292.Nim 游戏","uri":"/lc292/"},{"categories":["每日一题"],"content":"博弈论 博弈论问题一般是两方进行对抗的问题 首先如果有3枚以下的石头，那么我方一定获胜。如果有4枚石头，我方一定能获胜。 考虑5颗石头的情况，由于每次只能拿$1-3$颗石头，所以我们应该考虑$f[i],i \\in {4,3,2}$，一旦其中有必败的情况，表示我方一定获胜。 class Solution { public: bool canWinNim(int n) { vector\u003cint\u003e f(n + 1, true); if(n \u003e= 4) f[4] = false; for(int i = 5; i \u003c= n; i++){ f[i] = false; for(int j = i - 1; i - j \u003c= 3; j--){ if(f[j] == false){ f[i] = true; } } } return f[n]; } }; ","date":"2021-09-18","objectID":"/lc292/:1:1","tags":["博弈论","leetcode","算法"],"title":"lc292.Nim 游戏","uri":"/lc292/"},{"categories":["每日一题"],"content":"找规律 我们可以发现当石头的数量是4的倍数时，我们一定失败，否则一定会获胜。 class Solution { public: bool canWinNim(int n) { vector\u003cint\u003e f(4, true); f[0] = false; return f[n % 4]; } }; ","date":"2021-09-18","objectID":"/lc292/:1:2","tags":["博弈论","leetcode","算法"],"title":"lc292.Nim 游戏","uri":"/lc292/"},{"categories":["每日一题"],"content":"类似题目进阶 877. 石子游戏 ","date":"2021-09-18","objectID":"/lc292/:1:3","tags":["博弈论","leetcode","算法"],"title":"lc292.Nim 游戏","uri":"/lc292/"},{"categories":["每日一题"],"content":"36.有效的数独 ","date":"2021-09-17","objectID":"/lc36/:1:0","tags":["遍历","leetcode","算法"],"title":"lc36.有效的数独","uri":"/lc36/"},{"categories":["每日一题"],"content":"暴力遍历 遍历每一行，每一列，每个block进行检查。 class Solution { public: bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) { int m = board.size(), n = board[0].size(); // row for(int i = 0; i \u003c m; i++){ vector\u003cbool\u003e ok(10, false); for(int j = 0; j \u003c n; j++){ if(board[i][j] == '.'){ continue; } int x = board[i][j] - '0'; if(ok[x] == false){ ok[x] = true; }else{ return false; } } } // cout \u003c\u003c \"row ok \\n\"; // col for(int i = 0; i \u003c n; i++){ vector\u003cbool\u003e ok(10, false); for(int j = 0;j \u003c m; j++){ if(board[j][i] == '.'){ continue; } int x = board[j][i] - '0'; if(ok[x] == false){ ok[x] = true; }else{ return false; } } } // cout \u003c\u003c \"col ok \\n\"; // block for(int i = 1; i \u003c m; i += 3){ for(int j = 1; j \u003c n; j += 3){ vector\u003cbool\u003e ok(10, false); for(int k = 0; k \u003c 9; k++){ int ti = i + dir[k][0], tj = j + dir[k][1]; if(board[ti][tj] == '.'){ continue; } int x = board[ti][tj] - '0'; if(ok[x] == false){ ok[x] = true; } else{ return false; } } } } return true; } }; ","date":"2021-09-17","objectID":"/lc36/:1:1","tags":["遍历","leetcode","算法"],"title":"lc36.有效的数独","uri":"/lc36/"},{"categories":["每日一题"],"content":"一次遍历更新所有信息 class Solution { public: bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) { // 一次遍历 int row[9][10]; int col[9][10]; int block[3][3][10]; memset(row, 0, sizeof(row)); memset(col, 0, sizeof(col)); memset(block, 0, sizeof(block)); for(int i = 0; i \u003c board.size(); i++){ for(int j = 0; j \u003c board[0].size(); j++){ if(board[i][j] == '.'){ continue; } int x = board[i][j] - '0'; row[i][x] ++; col[j][x] ++; block[i/3][j/3][x] ++; if(row[i][x] \u003e 1 || col[j][x] \u003e 1 || block[i/3][j/3][x] \u003e 1){ return false; } } } return true; } }; ","date":"2021-09-17","objectID":"/lc36/:1:2","tags":["遍历","leetcode","算法"],"title":"lc36.有效的数独","uri":"/lc36/"},{"categories":["每日一题"],"content":"162. 寻找峰值 ","date":"2021-09-15","objectID":"/lc162/:1:0","tags":["二分查找","leetcode","算法"],"title":"lc162.寻找峰值","uri":"/lc162/"},{"categories":["每日一题"],"content":"寻找最大值 依照题意$-1,n$位置都是比任意值要小，而且数组中没有任意两个数字完全相同，所以 最大值肯定是目标值之一。 class Solution { public: int findPeakElement(vector\u003cint\u003e\u0026 nums) { return max_element(nums.begin(), nums.end()) - nums.begin(); } }; ","date":"2021-09-15","objectID":"/lc162/:1:1","tags":["二分查找","leetcode","算法"],"title":"lc162.寻找峰值","uri":"/lc162/"},{"categories":["每日一题"],"content":"二分查找 考虑一下几种情况 $nums[i] \u003e nums[i - 1] \u0026\u0026 nums[i] \u003e nums[i + 1]$：目标值，满足要求 $nums[i] \u003e nums[i - 1] \u0026\u0026 nums[i] \u003c nums[i + 1]$：向右移动 $nums[i] \u003c nums[i - 1] \u0026\u0026 nums[i] \u003e nums[i + 1]$：向左移动 $nums[i] \u003c nums[i - 1] \u0026\u0026 nums[i] \u003c nums[i + 1]$：可以向左也可以向右移动 如果我们选择第四种情况向右移动的话，不满足条件的三种情况可以化简为 $nums[i] \u003e nums[i + 1]$：向左移动 $nums[i] \u003e nums[i + 1]$：向右移动 那么对于区间$[l, r]$，如果$mid$满足条件，直接返回即可 不满足条件，我们需要对$mid$进行判断，如果$nums[i] \u003e nums[i + 1]$，则答案肯定在左半边$[i + 1, r]$直接舍去，右半边同理 注意这里有c++匿名函数的写法 [外部变量访问方式说明符] (参数表) -\u003e 返回值类型 { 语句块 } []:外部变量访问方式说明符可选=(定义在外部的变量不可以在语句块内修改),\u0026(定义在外部的变量可以在语句块内修改) class Solution { public: int findPeakElement(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); int l = 0, r = n - 1; // 方便进行判断，如果超出数组索引，返回{0, 0}, 否则返回{1, nums[i]},那么超出索引肯定小于索引内的数 auto get = [\u0026](int x) -\u003e pair\u003cint, int\u003e { if(x == -1 || x == n){ return {0, 0}; } return {1, nums[x]}; }; // 肯定会有满足条件的下标，则遍历所有下标 while(l \u003c= r){ int mid = l + r \u003e\u003e 1; if(get(mid) \u003e get(mid - 1) \u0026\u0026 get(mid) \u003e get(mid + 1)){ return mid; }else if(get(mid) \u003e get(mid + 1)){ r = mid; }else{ l = mid + 1; } } return -1; } }; ","date":"2021-09-15","objectID":"/lc162/:1:2","tags":["二分查找","leetcode","算法"],"title":"lc162.寻找峰值","uri":"/lc162/"},{"categories":["每日一题"],"content":"524. 通过删除字母匹配到字典里最长单词 ","date":"2021-09-14","objectID":"/lc524/:1:0","tags":["字符串","leetcode","算法","双指针"],"title":"lc524.通过删除字母匹配到字典里最长单词","uri":"/lc524/"},{"categories":["每日一题"],"content":"排序+双指针 双指针：判断一个字符串是不是另一个字符串的子串采用双指针,$T:O(n+m)$ 如w是s的子序列， 那么将w中每个字母按顺序匹配到w中对应的最左边的字母。 排序：首先按照字符串长度进行排序，在长度相同的情况下，按照字符串的首字母字典序进行排序。 $T:O(klogk+(m+n)*k)$，$k$是字符串数组的长度，$n$是单个字符串的平均长度，m是原串的长度。排序时间复杂度$klogk$，查询k个字符串是不是该串的子串$O(k(n+m))$. class Solution { public: static bool cmp(string\u0026 a, string\u0026 b){ if(a.size() != b.size()){ return a.size() \u003e= b.size(); }else{ return a \u003c b; } } string findLongestWord(string s, vector\u003cstring\u003e\u0026 dictionary) { sort(dictionary.begin(), dictionary.end(), cmp); for(auto\u0026 word: dictionary){ int i = 0, j = 0; for(; i \u003c s.size() \u0026\u0026 j \u003c word.size();){ if(s[i] == word[j]){ i++, j++; }else{ i++; } } if(j == word.size()){ return word; } } return \"\"; } }; ","date":"2021-09-14","objectID":"/lc524/:1:1","tags":["字符串","leetcode","算法","双指针"],"title":"lc524.通过删除字母匹配到字典里最长单词","uri":"/lc524/"},{"categories":["每日一题"],"content":"状态机 预处理目标字符串，使得匹配每个字符串的时间复杂度为$O(n)$ next[i][j]表示在当前下标i的位置，最靠近该位置的字母j出现的位置。 如#leetcode,next[0][l]=1, next[0][e]=2,next[0][t]=4。 通过对每个待匹配的字符串进行进行状态转移，如果没有对应的状态，则说明不存在该子串。 $T:O(n*k + klogk + m * 26)$ class Solution { public: static bool cmp(string\u0026 x, string\u0026 y) { if (x.size() != y.size()) { return x.size() \u003e y.size(); } else { return x \u003c y; } } string findLongestWord(string s, vector\u003cstring\u003e\u0026 dictionary) { int n = s.size(); s = \"#\" + s; sort(dictionary.begin(), dictionary.end(), cmp); // f[i][j], 下标i的最近的右边字母j的位置 auto f = vector\u003cvector\u003cint\u003e\u003e(n + 1, vector\u003cint\u003e(26, -1)); for (int i = n; i \u003e 0; i--) { for (int j = 0; j \u003c 26; j++) { f[i - 1][j] = f[i][j]; } // 除了字母i，其余字母都可以从更靠后的字母中得到 f[i - 1][s[i] - 'a'] = i; } for (auto\u0026 w: dictionary) { int idx = 0; bool ok = true; for (auto\u0026 c: w) { idx = f[idx][c - 'a']; if (idx == -1) { ok = false; break; } } if (ok) { return w; } } return \"\"; } }; ","date":"2021-09-14","objectID":"/lc524/:1:2","tags":["字符串","leetcode","算法","双指针"],"title":"lc524.通过删除字母匹配到字典里最长单词","uri":"/lc524/"},{"categories":["每日一题"],"content":"447. 回旋镖的数量 计算两两点之间的距离 假如相同距离的点为$n$个的话，则满足条件的三元组有$A_{n}^{2} = n * (n - 1)$个 class Solution { public: // A_{n}^{2} = n * (n - 1) int numberOfBoomerangs(vector\u003cvector\u003cint\u003e\u003e\u0026 points) { int ans = 0; for(auto\u0026 p1: points){ unordered_map\u003cint, int\u003e mp; for(auto\u0026 p2: points){ int dis = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]); mp[dis] += 1; } for(auto\u0026 [_, cnt]: mp){ cnt *= cnt - 1; ans += cnt; } } return ans; } }; ","date":"2021-09-13","objectID":"/lc447/:1:0","tags":["哈希表","leetcode","算法"],"title":"lc447.回旋镖的数量","uri":"/lc447/"},{"categories":["每日一题"],"content":"600. 不含连续1的非负整数 ","date":"2021-09-11","objectID":"/lc600/:1:0","tags":["位运算","leetcode","算法","数位DP"],"title":"lc600.不含连续1的非负整数","uri":"/lc600/"},{"categories":["每日一题"],"content":"暴力位运算 $O(n)$ 注意运算符优先级：“单算移关与，异或逻条赋” 关系运算符优先级要比位运算优先级要高。 class Solution { public: bool is_ok(int n ){ for(int i = 0; (1 \u003c\u003c i + 1) \u003c= n; i++){ int cur = 1 \u003c\u003c i, next = 1 \u003c\u003c i + 1; if((cur \u0026 n) \u003e 0 \u0026\u0026 (n \u0026 next) \u003e 0){ return false; } } return true; } int findIntegers(int n) { int ans = 0; for(int i = 0; i \u003c= n; i++){ if(is_ok(i)){ ans += 1; } } return ans; } }; ","date":"2021-09-11","objectID":"/lc600/:1:1","tags":["位运算","leetcode","算法","数位DP"],"title":"lc600.不含连续1的非负整数","uri":"/lc600/"},{"categories":["每日一题"],"content":"DFS $O(m)$, m为满足条件的数字个数 class Solution { public: int ans = 0; int max_n; int findIntegers(int n) { ans = 1; max_n = n; dfs(1); return ans; } void dfs(int x){ if(x \u003e max_n) return; ans += 1; // 最后一位是1,后面只能添加一位1 if(x \u0026 1 == 1){ dfs(x \u003c\u003c 1); }else{ // 最后一位是0,后面可以添加1/0 dfs(x \u003c\u003c 1); dfs((x \u003c\u003c 1) + 1); } } }; ","date":"2021-09-11","objectID":"/lc600/:1:2","tags":["位运算","leetcode","算法","数位DP"],"title":"lc600.不含连续1的非负整数","uri":"/lc600/"},{"categories":["每日一题"],"content":"动态规划 数位DP一般都是询问$[a, b]$区间内，符号条件的个数有多少个。通常需要实现查询$[0, x]$区间内满足条件的个数，则$[a, b]$之间满足的个数应该为$dp[b]-dp[a-1]$ 还需要理解 class Solution { public: int get_len(int n ){ for(int i = 31; i \u003e= 0; i--){ if(n \u003e\u003e i \u0026 1) return i; } return 0; } int findIntegers(int n) { int len = get_len(n); int f[50][2]; f[1][0] = 1, f[1][1] = 2; for(int i = 1; i \u003c= 32; i++){ f[i + 1][0] = f[i][1]; f[i + 1][1] = f[i][1] + f[i][0]; } int ans = 0, pre = 0; for(int i = len; i \u003e= 0; i--){ int cur = n \u003e\u003e i \u0026 1; if(cur == 1) ans += f[i + 1][0]; if(cur == 1 \u0026\u0026 pre == 1) break; pre = cur; if(i == 0) ans += 1; } return ans; } }; ","date":"2021-09-11","objectID":"/lc600/:1:3","tags":["位运算","leetcode","算法","数位DP"],"title":"lc600.不含连续1的非负整数","uri":"/lc600/"},{"categories":["tips"],"content":"运算符优先级口诀 “单算移关与，异或逻条赋” “单”表示单目运算符：逻辑非(!),按位取反(~),自增(++),自减(–),取地址(\u0026),取值(*)； “算”表示算术运算符：乘、除和求余(*,/,%)级别高于加减(+,-)； “关”表示关系运算符：大小关系(\u003e,\u003e=,\u003c,\u003c=)级别高于相等不相等关系(==,!=)； “与”表示按位与(\u0026)； “异”表示按位异或(^)； “或”表示按位或(|)； “逻”表示逻辑运算符：逻辑与(\u0026\u0026)级别高于逻辑或(||)； “条”表示条件运算符(? :)； “赋”表示赋值运算符(=,+=,-=,*=,/=,%=,»=,«=,\u0026=,^=, |=,!=)； 参考 参考链接 ","date":"2021-09-11","objectID":"/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%A3%E8%AF%80/:1:0","tags":["leetcode","算法","运算符优先级"],"title":"tips1-运算符优先级口诀","uri":"/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%A3%E8%AF%80/"},{"categories":["每日一题"],"content":"68. 文本左右对齐 首先理解题目：这道题要求除了最后一行两端对齐，最后一行靠左对齐。 首先先计算每一行可以放哪些单词 之后将计算每行放多少空格，额外需要添加多少空格，最后一个单词空格不足的话，需要额外补足。 最后对最后一行进行从左到右处理。 $T:O(n)$,$n$为单词的数目 class Solution { public: vector\u003cstring\u003e fullJustify(vector\u003cstring\u003e\u0026 words, int maxWidth) { vector\u003cstring\u003e res; vector\u003cvector\u003cstring\u003e\u003e lines; // 每一行可以放哪些单词 int length = 0; vector\u003cstring\u003e line; for(auto\u0026 word: words){ if(length + word.size() \u003e maxWidth){ lines.push_back(line); line.clear(); length = 0; } line.push_back(word); length += word.size(); // 添加新的单词前，需要至少添加一个空格 length++; } if(!line.empty()){ lines.push_back(line); } string line_string; // 依次处理每一行 for(int i = 0; i \u003c lines.size() - 1; i++){ int total_length = 0; auto cur = lines[i]; for(int j = 0; j \u003c cur.size(); j++){ total_length += cur[j].size(); } // 计算每一行平均需要添加的空格数 // 已经左边每个空格额外需要的空个数 int n_words = cur.size() - 1; int n_space = 0, extra_space = 0; if(n_words != 0){ n_space = (maxWidth - total_length) / n_words; extra_space = (maxWidth - total_length) % n_words; } for(int j = 0; j \u003c cur.size(); j++){ if(j \u003c cur.size() - 1){ line_string += cur[j]; line_string += string(n_space, ' '); if(extra_space \u003e 0){ line_string += string(1, ' '); extra_space -= 1; } }else{ line_string += cur[j]; } } // 如果右侧有剩余部分，添加额外空格 int n_empty = maxWidth - line_string.size(); if(n_empty \u003e 0) line_string += string(n_empty, ' '); res.push_back(line_string); line_string.clear(); } if(lines.size() - 1 \u003e= 0){ // 处理最后一行 auto line = lines[lines.size() - 1]; for(int i = 0; i \u003c line.size(); i++){ if(i \u003c line.size() - 1){ line_string += line[i]; line_string += string(1, ' '); }else{ line_string += line[i]; } } int n_empty = maxWidth - line_string.size(); if(n_empty \u003e 0) line_string += string(n_empty, ' '); res.push_back(line_string); } return res; } }; ","date":"2021-09-09","objectID":"/lc68/:1:0","tags":["模拟","leetcode","算法","字符串"],"title":"lc68. 文本左右对齐","uri":"/lc68/"},{"categories":["每日一题"],"content":"502. IPO 如果没有k的限制：依次将资本消耗从小到大进行排序，然后投资capital[i],之后w+=profits[i] 有了k的限制 首先仍是将资本消耗从小到大排序 但是在选择项目时需要考虑利润的因素，每一次需要选择所有满足资本投资capital[i] \u003c w中利润最大的项目，可以利用最大堆获取。 这里需要注意的是，在每次投资之后资本w1会变大为w2，每次只需将w1-\u003ew2之间的项目入堆即可。 $O(n + k)logn$ typedef pair\u003cint, int\u003e PII; class Solution { public: // 如果没有k的限制：依次将资本消耗从小到大进行排序，然后投资capital[i],之后w+=profits[i] // 有了k的限制 // 首先仍是将资本消耗从小到大排序 // 但是在选择项目时需要考虑利润的因素，每一次需要选择所有满足资本投资capital[i] \u003c w中利润最大的项目，可以利用最大堆获取。 // 这里需要注意的是，在每次投资之后资本w1会变大为w2，每次只需将w1-\u003ew2之间的项目入堆即可。 // $O(n + k)logn$ int findMaximizedCapital(int k, int w, vector\u003cint\u003e\u0026 profits, vector\u003cint\u003e\u0026 capital) { vector\u003cPII\u003e projects; int n = profits.size(), idx = 0; priority_queue\u003cint, vector\u003cint\u003e\u003e hp; for(int i = 0; i \u003c n; i++){ projects.push_back({capital[i], profits[i]}); } // 排序 sort(projects.begin(), projects.end()); for(int i = 0; i \u003c k; i++){ while(idx \u003c n \u0026\u0026 projects[idx].first \u003c= w){ hp.push(projects[idx].second); idx++; } if(hp.empty()){ break; }else{ w += hp.top(); hp.pop(); } } return w; } }; ","date":"2021-09-08","objectID":"/lc502/:1:0","tags":["贪心","堆","leetcode","算法"],"title":"lc502. IPO","uri":"/lc502/"},{"categories":["每日一题"],"content":"165. 比较版本号 ","date":"2021-09-01","objectID":"/lc165/:1:0","tags":["字符串","leetcode","算法","双指针"],"title":"lc165. 比较版本号","uri":"/lc165/"},{"categories":["每日一题"],"content":"split后双指针比较 先对字符串做split提取出每个小的版本号 之后对每个小版本号进行比较即可。 $T:O(n)$ $S:O(n)$ class Solution { public: vector\u003cint\u003e split_s(string\u0026 s){ vector\u003cint\u003e res; for(int i = 0, num = 0; i \u003c s.size(); i++){ if(s[i] == '.'){ res.push_back(num); num = 0; }else{ num = num * 10 + s[i] - '0'; if(i == s.size() - 1) res.push_back(num); } } return res; } int compareVersion(string version1, string version2) { vector\u003cint\u003e split_v1 = split_s(version1); vector\u003cint\u003e split_v2 = split_s(version2); int n1 = split_v1.size(), n2 = split_v2.size(); for(int i = 0, j = 0; i \u003c n1 || j \u003c n2; i++, j++){ int x = 0, y = 0; if(i \u003c n1) x = split_v1[i]; if(j \u003c n2) y = split_v2[j]; if(x \u003e y) return 1; if(x \u003c y) return -1; } return 0; } }; ","date":"2021-09-01","objectID":"/lc165/:1:1","tags":["字符串","leetcode","算法","双指针"],"title":"lc165. 比较版本号","uri":"/lc165/"},{"categories":["每日一题"],"content":"直接使用双指针，边split边比较 class Solution { public: unsigned int get_num(string\u0026 version, int\u0026 idx){ if(idx \u003e= version.size()) return 0; unsigned int ans = 0; while(idx \u003c version.size()){ if(version[idx] == '.'){ idx++; break; } ans = ans * 10 + version[idx] - '0'; idx ++; } return ans; } int compareVersion(string version1, string version2) { int idx1 = 0, idx2 = 0; // 类似于split，每次提取出来的两个.之间的数字 // 如果下标已经超过了字符串的大小，则直接返回零进行比较。 while(idx1 \u003c version1.size() || idx2 \u003c version2.size()){ unsigned int n1 = get_num(version1, idx1); unsigned int n2 = get_num(version2, idx2); // cout \u003c\u003c n1 \u003c\u003c ' ' \u003c\u003c n2 \u003c\u003c endl; if(n1 \u003e n2) return 1; if(n1 \u003c n2) return -1; } return 0; } }; ","date":"2021-09-01","objectID":"/lc165/:1:2","tags":["字符串","leetcode","算法","双指针"],"title":"lc165. 比较版本号","uri":"/lc165/"},{"categories":["每日一题"],"content":"1109. 航班预订统计 差分用于快速处理区间的增量。 当我们需要对某一数组$a[n]$,区间$[l,r]$之间添加一个增量$inc$时，也就是对差分数组$d[n]$进行$d[l]+= inc, d[r + 1]-=inc$，之后对差分数组求前缀和，便可以对原数组进行快速的增量处理 $T:O(m + n)$ class Solution { public: vector\u003cint\u003e corpFlightBookings(vector\u003cvector\u003cint\u003e\u003e\u0026 bookings, int n) { vector\u003cint\u003e ans(n, 0); for(auto \u0026book: bookings){ int x = book[0] - 1, y = book[1] - 1, w = book[2]; ans[x] += w; if(y \u003c n - 1) ans[y + 1] -= w; } for(int i = 1; i \u003c ans.size(); i++){ ans[i] += ans[i - 1]; } return ans; } }; ","date":"2021-08-31","objectID":"/lc1109/:1:0","tags":["差分","leetcode","算法"],"title":"lc1109.航班预订统计","uri":"/lc1109/"},{"categories":["每日一题"],"content":"528. 按权重随机选择 题目的意思是根据下标不同的权重产生随机数 $w[i]$代表产生随机数$i$的权重 首先将计算所有数的和，然后依次计算前缀和，均匀分布产生的随机数$randnum$，在两个前缀和$[pre[i-1], pre[i])$之间的范围代表产生该数$i$。 如$w={1,2,3,4}$，分别代表产生$p_{0}=\\frac{1}{10},p_{1}=\\frac{2}{10}，p_{2}=\\frac{3}{10}，p_{3}=\\frac{4}{10}$ 首先计算前缀和数组$pre={0,1,3,6,10}$ 之后通过均匀分布产生一个在$[0,10)$之间的随机数$randnum$,根据$randnum$的取值重新产生新的随机数$i$，$randnum\\in[pre[i-1],pre[i])$，表示产生随机数$i-1$ 也就是在前缀和数组中找到第一个大于$randnum$的前缀和下标$i$，返回$i-1$，或者找到最后一个小于等于$randnum$的前缀和下标$i$，并且返回$i$ ","date":"2021-08-30","objectID":"/lc528/:1:0","tags":["随机数","leetcode","算法"],"title":"lc528.按权重随机选择","uri":"/lc528/"},{"categories":["每日一题"],"content":"第一个大于randnum的前缀和数组下标 $T:O(logn)$ class Solution { public: vector\u003cint\u003e pre = {0}; int range = 0; Solution(vector\u003cint\u003e\u0026 w) { for(auto w_: w){ range += w_; pre.push_back(range); } } int pickIndex() { int randnum = rand() % range; int idx = upper_bound(pre.begin(), pre.end(), randnum) - pre.begin(); return idx - 1; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(w); * int param_1 = obj-\u003epickIndex(); */ ","date":"2021-08-30","objectID":"/lc528/:1:1","tags":["随机数","leetcode","算法"],"title":"lc528.按权重随机选择","uri":"/lc528/"},{"categories":["每日一题"],"content":"最后一个小于等于randnum的数 class Solution { public: vector\u003cint\u003e pre = {0}; int range = 0; Solution(vector\u003cint\u003e\u0026 w) { for(auto w_: w){ range += w_; pre.push_back(range); } } int pickIndex() { int randnum = rand() % range; // 最后一个小于等于randnum的下标i，返回i int l = 0, r = pre.size() - 1; while(l \u003c r){ int mid = (l + r + 1) \u003e\u003e 1; if(pre[mid] \u003c= randnum){ l = mid; }else{ r = mid - 1; } } return l; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(w); * int param_1 = obj-\u003epickIndex(); */ ","date":"2021-08-30","objectID":"/lc528/:1:2","tags":["随机数","leetcode","算法"],"title":"lc528.按权重随机选择","uri":"/lc528/"},{"categories":["每日一题"],"content":"1480. 一维数组的动态和 ","date":"2021-08-28","objectID":"/lc1480/:1:0","tags":["前缀和","leetcode","算法"],"title":"lc1480. 一维数组的动态和","uri":"/lc1480/"},{"categories":["每日一题"],"content":"前缀和 pre[i]表示前i个数的和 返回i+1-\u003eend class Solution { public: vector\u003cint\u003e runningSum(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); vector\u003cint\u003e pre(n + 1, 0); for(int i = 1; i \u003c= n; i++){ pre[i] = pre[i - 1] + nums[i - 1]; } return vector\u003cint\u003e(pre.begin() + 1, pre.end()); } }; ","date":"2021-08-28","objectID":"/lc1480/:1:1","tags":["前缀和","leetcode","算法"],"title":"lc1480. 一维数组的动态和","uri":"/lc1480/"},{"categories":["每日一题"],"content":"881. 救生艇 ","date":"2021-08-26","objectID":"/lc881/:1:0","tags":["贪心","双指针","leetcode","算法"],"title":"lc881. 救生艇","uri":"/lc881/"},{"categories":["每日一题"],"content":"贪心+双指针 $T:O(nlogn)$ class Solution { public: int numRescueBoats(vector\u003cint\u003e\u0026 people, int limit) { sort(people.begin(), people.end()); int n = people.size(), cnt = 0; // 双指针+贪心 // 从小到大进行排序 // i指向最小,j指向最大 // i和j相加小于limit,则i与所有的j都可以组合成一组,此时应该贪心选择最优策略，两个相加重量最大 // i和j相加大于limit,则j与其他所有的i都不可以组成一组,j-- for(int i = 0, j = n - 1; i \u003c= j;){ if(people[i] + people[j] \u003c= limit){ i++;j--; }else{ j--; } cnt += 1; } return cnt; } }; ","date":"2021-08-26","objectID":"/lc881/:1:1","tags":["贪心","双指针","leetcode","算法"],"title":"lc881. 救生艇","uri":"/lc881/"},{"categories":["每日一题"],"content":"797. 所有可能的路径 ","date":"2021-08-25","objectID":"/lc797/:1:0","tags":["DFS","leetcode","算法"],"title":"lc797.所有可能的路径","uri":"/lc797/"},{"categories":["每日一题"],"content":"DFS 有向无环图DAG不会重复访问同一个点，所以不需要记录这些点是否访问过。 class Solution { public: vector\u003cvector\u003cint\u003e\u003e res; void dfs(vector\u003cvector\u003cint\u003e\u003e\u0026 g, int begin, vector\u003cint\u003e\u0026 path, int n ){ if(begin == n){ res.push_back(path); return; } for(int i = 0; i \u003c g[begin].size(); i++){ path.push_back(g[begin][i]); dfs(g, g[begin][i], path, n); path.pop_back(); } } vector\u003cvector\u003cint\u003e\u003e allPathsSourceTarget(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { vector\u003cint\u003e path; int n = graph.size() - 1; path.push_back(0); dfs(graph, 0, path, n); return res; } }; ","date":"2021-08-25","objectID":"/lc797/:1:1","tags":["DFS","leetcode","算法"],"title":"lc797.所有可能的路径","uri":"/lc797/"},{"categories":["算法基础课"],"content":"位运算 ","date":"2021-08-24","objectID":"/ch1_%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["算法基础课","leetcode","算法","位运算"],"title":"acwing基础课ch1-位运算","uri":"/ch1_%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"位的统计问题 计算n的二进制表示中第k位 先把第k位移动到最后一位， 然后进行判断。 lowbit(x)运算：返回x的最后一位1的位置 -x = ~x + 1 x \u0026 -x 1010 -\u003e10 101000 -\u003e 1000 二进制中1的个数 暴力统计每个数中的每一位 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; int a[N], n; void cal_bits(int\u0026 x){ int res = 0; while(x){ if(x \u0026 1) res += 1; x = x \u003e\u003e 1; } x = res; } int main(){ cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026a[i]); for(int i = 0; i \u003c n; i++){ cal_bits(a[i]); printf(\"%d \", a[i]); } return 0; } x \u0026 (-x)-\u003elow_bit(x)得到二进制中最右边的1的位置。 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; int x, n; int low_bits(int x){ return x \u0026 (-x); } int main(){ cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026x); int res = 0; while(x) { x = x - low_bits(x); res += 1; } cout \u003c\u003c res \u003c\u003c ' '; } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E4%BD%8D%E8%BF%90%E7%AE%97/:1:1","tags":["算法基础课","leetcode","算法","位运算"],"title":"acwing基础课ch1-位运算","uri":"/ch1_%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"前缀和 ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:1:0","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"一维前缀和 利用存储的部分前缀和快速计算部分数组的和 前缀和数组长度为n+1 s[0] = 0, s[i]表示nums[i]前所有数的和，不包括nums[i] s[i]表示前i个数的前缀和 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; int a[N], s[N]; int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026a[i]); for(int i = 1; i \u003c= n; i++){ s[i] = s[i - 1] + a[i - 1]; } // 注意这里输入的数据是前l, r个数字。 while(m--){ int l, r; cin \u003e\u003e l \u003e\u003e r; printf(\"%d\\n\", s[r] - s[l - 1]); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:1:1","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"二维前缀和-\u003e计算指定区域内的和 $s[i][j]$表示的是前i行，前j列的区域和。 #include \u003ciostream\u003e using namespace std; const int N = 1010; int a[N][N], s[N][N]; int main(){ int n, m, q; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c m; j++){ scanf(\"%d\", \u0026a[i][j]); } } for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= m; j++){ s[i][j] = a[i - 1][j - 1] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; } } while(q-- ){ int x1, y1, x2, y2; scanf(\"%d%d%d%d\", \u0026x1, \u0026y1, \u0026x2, \u0026y2); printf(\"%d\\n\", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:1:2","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"差分 构造一个新的数组使原数组成为该数组的前缀和。 作用：用O(1)的时间让某个区间[l, r]全部加上一个值 原数组求差分数组相当于差分数组在对应位置插入原数组的值，a[l] + c, a[r+1] - c。 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; int a[N], b[N]; void insert(int l, int r, int c){ b[l] += c; b[r + 1] -= c; } int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); // 原数组相当于差分数组在对应位置插入原数组的值 for(int i = 1; i \u003c= n; i++) insert(i, i, a[i]); while(m--){ int l, r, c; scanf(\"%d%d%d\",\u0026l, \u0026r, \u0026c); // 进行插入操作 insert(l, r, c); } // 对b数组求前缀和得到修改以后的数组 for(int i = 1; i \u003c= n; i++){ b[i] += b[i-1]; printf(\"%d \",b[i]); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:2:0","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"二维差分数组 在二维区域内$a[x1][y1]-\u003ea[x2][y2]$区域间所有的数加上一个数c. 等同于其差分数组$b[x1][y1] += c$，$b[x2+1][y1]-=c$，$b[x1][y2+1]-=c$，$b[x2+1][y2+1]+=c$ #include \u003ciostream\u003e using namespace std; const int N = 1010; int a[N][N], b[N][N]; void insert(int x1,int y1,int x2,int y2, int c){ b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main(){ int n, m, q; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= m; j++){ scanf(\"%d\", \u0026a[i][j]); insert(i, j, i, j, a[i][j]); } } while(q-- ){ int x1, y1, x2, y2, c; scanf(\"%d%d%d%d%d\", \u0026x1, \u0026y1, \u0026x2, \u0026y2, \u0026c); insert(x1, y1, x2, y2, c); } for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= m; j++){ // 计算前缀和 b[i][j] = b[i - 1][j] + b[i][j - 1] + b[i][j] - b[i - 1][j - 1]; printf(\"%d \", b[i][j]); } printf(\"\\n\"); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:2:1","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"双指针 ","date":"2021-08-24","objectID":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":["算法基础课","leetcode","算法","双指针"],"title":"acwing基础课ch1-双指针","uri":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法基础课"],"content":"两个序列双指针 归并排序 ","date":"2021-08-24","objectID":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/:1:1","tags":["算法基础课","leetcode","算法","双指针"],"title":"acwing基础课ch1-双指针","uri":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法基础课"],"content":"一个序列同向双指针 双指针利用某种性质将暴力(n^2)的算法优化到O(n). 实现split() 最长连续不重复子序列 暴力做法：枚举以i为结尾的所有数组，j表示离当前i最远的不重复数组。 暴力做法：TLE #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cunordered_set\u003e using namespace std; const int N = 1e5+10; int a[N]; int main(){ int res = 0, n = 0; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026a[i]); for(int i = 0; i \u003c n; i++){ unordered_set\u003cint\u003e uset; for(int j = i; j \u003e= 0; j--){ // check if(uset.find(a[j]) != uset.end()){ break; }else{ res = max(i - j + 1, res); } uset.insert(a[j]); } } cout \u003c\u003c res; return 0; } 双指针 利用反证法，如果以i结尾的子数组最长不重复对应左节点为j，那么i+1结尾最长不重复数组对应左节点大于 等于j。且如果左节点大于j的话，一定是由于新加入的i+1导致的。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cunordered_set\u003e using namespace std; const int N = 1e5+10; int a[N]; int main(){ int res = 0, n = 0; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026a[i]); unordered_set\u003cint\u003e uset; for(int i = 0, j = 0; i \u003c n; i++){ // 删除j, 直到当前j -\u003e i 中没有重复数字。 while(j \u003c i \u0026\u0026 uset.find(a[i]) != uset.end()){ uset.erase(a[j]); j++; } // 产生的重复是由a[i]导致的 uset.insert(a[i]); res = max(i - j + 1, res); } cout \u003c\u003c res; return 0; } 数组元素的目标和 给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。 求A[i] + B[j] = x i正序枚举，j倒序枚举，如果$A[i] + B[j] \u003e t$则$A[i+1]+B[j]\u003et$,所以j可以从$j+1$开始枚举。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int a[N], b[N]; int main(){ int n, m, t; cin \u003e\u003e n \u003e\u003e m \u003e\u003e t; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } for(int i = 0; i \u003c m; i++){ scanf(\"%d\", \u0026b[i]); } for(int i = 0, j = m - 1; i \u003c n; i++){ while(j \u003e= 0 \u0026\u0026 a[i] + b[j] \u003e t) j--; if(a[i] + b[j] == t){ printf(\"%d %d\", i, j); break; } } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/:1:2","tags":["算法基础课","leetcode","算法","双指针"],"title":"acwing基础课ch1-双指针","uri":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法基础课"],"content":"排序 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:0:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"分类 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:1:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"复杂度分析 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:2:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"快速排序 基于分治思想 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"主要步骤 确定分界点x，随机(一般为左端点) 调整范围，左半边小于等于x，右半边大于等于x（双指针）。 如果忘记了双指针方法，可以暴力开数组求解。 递归处理左右区间。 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:1","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"复杂度分析 最坏时间复杂度发生在数组有序的时候，数组有序时，每次划分的区间都是左边界，时间复杂度时$O(n^2)$ 最好时间复杂度：切分点在数组中间，$C_n = 2C_{n/2} + n$,$T:O(nlogn)$ 平均时间复杂度：切分点的期望是在数组中间，因此平均复杂度就是最好的时间复杂度。 空间复杂度：$O(logn)$递归栈调用，最差为$O(n)$ ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:2","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"Acwing785. 快速排序 快速选择切分，递归进行左右半边的区间排序 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5 + 10; int a[N]; int Quick_Select(int a[], int l, int r){ if(l \u003e= r) { return l; } swap(a[l], a[l+r\u003e\u003e1]); int x = a[l] ,i = l, j = r+1; // 如果超出了数据范围break即可 while(i \u003c j){ // i最差为r while(i \u003c r \u0026\u0026 a[++i] \u003c x); // j最差为l while(j \u003e l \u0026\u0026 a[--j] \u003e x); if(i \u003c j) swap(a[i], a[j]); } swap(a[l], a[j]); return j; } void Quick_Sort(int a[], int l, int r){ if(l \u003e= r) return; int j = Quick_Select(a, l, r); // cout \u003c\u003c l \u003c\u003c ' ' \u003c\u003c r \u003c\u003c ' ' \u003c\u003c j \u003c\u003c endl; Quick_Sort(a, l, j-1); Quick_Sort(a, j+1, r); } int main(){ int n; scanf(\"%d\",\u0026n); for(int i = 0;i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } Quick_Sort(a, 0, n-1); for(int i = 0;i \u003c n; i++){ printf(\"%d \", a[i]); } return 0; } 高级短代码做法 一直选取做边界会超时 选择中值或者随机取值则不会超时。 while循环结束后$q[l…j]\u003c=x, q[j+1…r]\u003e=x$ j的取值范围为$l, r-1$，所以不会一直不划分边界 只能取大于或者小于号是因为交换原来的数字进行了限位，不会产生数组溢出的问题。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5 + 10; int a[N]; void Quick_Sort(int a[], int l, int r){ if(l \u003e= r) return; // 注意这里i,j都与开始值差一位 int x = a[l], i = l - 1, j = r + 1; // 循环结束后,a[l...j] \u003c= x, a[j+1...r] \u003e= x while(i \u003c j){ // 这里不能用等号，是因为交换让目标值做限位的作用 while(a[++i] \u003c x); while(a[--j] \u003e x); if(i \u003c j) swap(a[i], a[j]); } cout \u003c\u003cl \u003c\u003c ' '\u003c\u003c r \u003c\u003c ' ' \u003c\u003c j \u003c\u003c ' ' \u003c\u003c endl; // j取值范围时[l, r-1]不存在0和n区间无限循环 // j最小值大于等于l Quick_Sort(a, l, j); Quick_Sort(a, j+1, r); } int main(){ int n; scanf(\"%d\",\u0026n); for(int i = 0;i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } Quick_Sort(a, 0, n-1); for(int i = 0;i \u003c n; i++){ printf(\"%d \", a[i]); } return 0; } 快慢指针版本，数据量较大时候，由于多次交换，会超时。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5 + 10; int a[N]; void Quick_Sort(int a[], int l, int r){ // 快慢指针版本 if(l \u003e= r) return; swap(a[l], a[l + r \u003e\u003e 1]); int x = a[l], i = l; for(int j = l+1; j \u003c= r; j++){ if(a[j] \u003c= x){ swap(a[j], a[++i]); } } swap(a[i], a[l]); Quick_Sort(a, l, i-1); Quick_Sort(a, i+1, r); } int main(){ int n; scanf(\"%d\",\u0026n); for(int i = 0;i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } Quick_Sort(a, 0, n-1); for(int i = 0;i \u003c n; i++){ printf(\"%d \", a[i]); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:3","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"786. 第k个小的数 排序 $T:O(nlogn), S:O(logn)$ 大顶堆 $T:O(nlogk),S:O(k)$，结果有序 快速选择 平均复杂度：$T:O(n),S:O(logn)$ 最坏复杂度：$T:O(n^2),S:O(n)$ 快慢指针的快速选择切分 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cstdlib.h\u003e using namespace std; const int N = 1e5+10; int a[N]; int Quick_Select(int a[], int l, int r, int k){ if(l \u003e= r) return a[l]; // 添加随机性 int rand_idx = rand() % (r - l + 1) + l; swap(a[rand_idx], a[l]); int x = a[l], i = l, j = r + 1; while(i \u003c j){ // i 最差为 r while(i \u003c r \u0026\u0026 a[++i] \u003c x); // j 最差为 l while(j \u003e l \u0026\u0026 a[--j] \u003e x); if(i \u003c j) swap(a[i], a[j]); } swap(a[l], a[j]); if(j - l + 1 == k) return a[j]; else if(j - l + 1 \u003e k) return Quick_Select(a, l, j - 1, k); else return Quick_Select(a, j + 1, r, k - (j - l + 1)); } int main(){ int n, k; cin \u003e\u003e n \u003e\u003e k; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } int l = 0, r = n - 1; cout \u003c\u003c Quick_Select(a, l, r, k) \u003c\u003c endl; return 0; } 高级基于快速排序的快速选择。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int a[N]; int Quick_Sort(int a[], int l, int r, int k){ if(l \u003e= r) return a[l]; int x = a[l], i = l - 1, j = r + 1; while(i \u003c j){ while(a[++i] \u003c x); while(a[--j] \u003e x); if(i \u003c j) swap(a[i], a[j]); } if(j - l + 1 \u003e= k) Quick_Sort(a, l, j, k); else Quick_Sort(a, j+1, r, k - (j - l + 1)); } int main(){ int n, k; cin \u003e\u003e n \u003e\u003e k; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } cout \u003c\u003c Quick_Sort(a, 0, n-1, k); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:4","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"归并排序 本质：将两个排序好的队列进行合并的过程。 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"步骤 确定分界点。 递归划分区间。 双执政归并合并两个有序序列。 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:1","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"复杂度分析 $T:O(nlogn)$ $S:O(n)$，辅助数组进行赋值操作 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:2","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"787. 归并排序 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e6 + 10; int a[N]; int temp[N]; void merge(int a[], int l, int mid, int r){ int i = l, j = mid+1, cur = 0; while(i \u003c= mid \u0026\u0026 j \u003c= r){ if(a[i] \u003c= a[j]){ temp[cur++] = a[i++]; }else{ temp[cur++] = a[j++]; } } while(i \u003c= mid) temp[cur++] = a[i++]; while(j \u003c= r) temp[cur++] = a[j++]; for(int i = l, j = 0; j \u003c cur; i++, j++){ a[i] = temp[j]; } } void merge_sort(int a[], int l, int r){ if(l \u003e= r) return; int mid = l + r \u003e\u003e 1; merge_sort(a, l, mid); merge_sort(a, mid+1, r); merge(a, l, mid, r); } int main(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } merge_sort(a, 0, n-1); for(int i = 0; i \u003c n; i++){ printf(\"%d \", a[i]); } } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:3","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"788. 逆序对的数量 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:4","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"归并思想 i 前面的数均小于j $T:O(nlogn)$ $S:O(n)$ #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; typedef long long LL; const int N = 1e5+10; int a[N]; int temp[N]; LL merge_reverse_num(int a[], int l, int r){ if(l \u003e= r) return 0; int mid = l + r \u003e\u003e 1; LL res = merge_reverse_num(a, l, mid) + merge_reverse_num(a, mid+1, r); int i = l, j = mid + 1, cur = 0; while(i \u003c= mid \u0026\u0026 j \u003c= r){ if(a[i] \u003c= a[j]){ temp[cur++] = a[i++]; }else{ // a[i] \u003e a[j] -\u003e + mid - i + 1 res += mid - i + 1; temp[cur++] = a[j++]; } } while(i \u003c= mid) temp[cur++] = a[i++]; while(j \u003c= r) temp[cur++] = a[j++]; for(int i = l, j = 0; j \u003c cur; i++, j++){ a[i] = temp[j]; } return res; } int main(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } printf(\"%ld\", merge_reverse_num(a, 0, n-1)); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:5","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"暴力(LTE) #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; typedef long long LL; const int N = 1e5+10; int a[N]; int main(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } LL res = 0; for(int i = 0; i \u003c n; i++){ for(int j = i+1; j \u003c n; j++){ if(a[i] \u003e a[j]) res += 1; } } printf(\"%ld\", res); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:6","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"高精度运算 ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:0:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"数据存储 利用数组倒序存储大的数据，进位在最后一位添加一个数十分方便。 ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:1:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"高精度加法 模拟加法进位 字符串输入，取反存入数组中 计算返回数组倒序输出。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cstring\u003e using namespace std; vector\u003cint\u003e add(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B){ vector\u003cint\u003e res; int up = 0; for(int i = 0; i \u003c A.size() || i \u003c B.size() || up; i++){ if(i \u003c A.size()) up += A[i]; if(i \u003c B.size()) up += B[i]; res.push_back(up % 10); up = up / 10; } return res; } int main(){ string a, b; vector\u003cint\u003e A, B; cin \u003e\u003e a \u003e\u003e b; // 注意这里的字符串转换 for(int i = a.size() - 1; i \u003e= 0; i--) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i \u003e= 0; i--) B.push_back(b[i] - '0'); vector\u003cint\u003e C = add(A, B); for(int i = C.size() - 1; i \u003e= 0; i--) printf(\"%d\", C[i]); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:2:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"高精度减法 保证A\u003e=B $A-B(A\u003e=B)$，$-(B-A)(A\u003cB)$ 注意减法会有前导零，要删除前导零 关键点有两个：如何判断两个数大小和如何进行模拟减法。 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; bool cmp(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B){ if(A.size() != B.size()) return A.size() \u003e B.size(); else{ for(int i = A.size() - 1;i \u003e= 0; i--){ if(A[i] != B[i]) return A[i] \u003e B[i]; } } return true; } vector\u003cint\u003e sub(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B){ vector\u003cint\u003e res; int help = 0; for(int i = 0; i \u003c A.size(); i++){ help += A[i]; if(i \u003c B.size()) help -= B[i]; if(help \u003e= 0){ res.push_back(help); help = 0; }else{ res.push_back(help + 10); help = -1; } } while(res.size() \u003e 1 \u0026\u0026 res.back() == 0) res.pop_back(); return res; } int main(){ string a, b; vector\u003cint\u003e A, B, C; cin \u003e\u003e a \u003e\u003e b; for(int i = a.size() - 1;i \u003e= 0; i--) A.push_back(a[i] - '0'); for(int i = b.size() - 1;i \u003e= 0; i--) B.push_back(b[i] - '0'); if(cmp(A, B)){ C = sub(A, B); }else{ C = sub(B, A); printf(\"-\"); } for(int i = C.size() - 1; i \u003e= 0; i--) printf(\"%d\", C[i]); } ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:3:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"高精度乘法 每一项乘乘数，每次处理结果的最后一位，其余作为进位。 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; vector\u003cint\u003e mul(vector\u003cint\u003e\u0026 A, int b){ vector\u003cint\u003e res; int t = 0; for(int i = 0; i \u003c A.size(); i++){ t += A[i] * b; // 添加个位 res.push_back(t % 10); // 进位 t /= 10; } // 处理多余的进位 while(t){ res.push_back(t % 10); t /= 10; } // 去除前导0 while(res.size() \u003e 1 \u0026\u0026 res.back() == 0) res.pop_back(); return res; } int main(){ string a; int b; cin \u003e\u003e a \u003e\u003e b; vector\u003cint\u003e A, C; for(int i = a.size() - 1; i \u003e= 0; i--) A.push_back(a[i] - '0'); C = mul(A, b); for(int i = C.size() - 1; i \u003e= 0; i--) printf(\"%d\", C[i]); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:4:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"高精度除法 除法是正着计算的，其余都是按照逆运算进行进位的。 商的位数小于等于被除数的位数。 上次除的余数*10 / 除数 就是该位的结果，之后更新除数即可。 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e using namespace std; // 商的位数小于等于被除数的位数。 // 模拟除法 // 上次除的余数*10 / 除数 就是该位的结果 // 之后更新除数即可。 // A/b = C ... k vector\u003cint\u003e div(vector\u003cint\u003e\u0026 A, int b, int\u0026 k){ vector\u003cint\u003e res(A.size()); for(int i = A.size() - 1; i \u003e= 0; i--){ k = k * 10 + A[i]; res[i] = k / b; k = k % b; } while(res.size() \u003e 1 \u0026\u0026 res.back() == 0) res.pop_back(); return res; } int main(){ string a; int b, k = 0; vector\u003cint\u003e A, C; cin \u003e\u003e a \u003e\u003e b; for(int i = a.size() - 1; i \u003e= 0; i--) A.push_back(a[i] - '0'); C = div(A, b, k); for(int i = C.size() - 1; i \u003e= 0; i--) printf(\"%d\", C[i]); printf(\"\\n%d\", k); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:5:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"哈希表 将一个复杂的数据结构进行映射。 (key-value)pair的关系。 ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:1:0","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"哈希表基本元素 key-value映射 哈希函数 哈希冲突解决方法 ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:1:1","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"哈希函数 一般取模(x%MOD) MOD是大于数据规模的最小质数 ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:1:2","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"哈希冲突 不同的key通过哈希函数后产生了相同的value（映射）。 拉链法 产生了冲突之后，将产生哈希冲突的值用链表的方式存储在相应的idx之后 插入：在哈希值的链表上插入一个值。 查找：找到哈希值，在哈希值对应的链上查找。 删除：删除链表的一个节点 #include \u003ciostream\u003e const int N = 1e5+10; using namespace std; struct Listnode{ int val; Listnode* next; Listnode(int x = 0, Listnode* ne = nullptr):val(x), next(ne) {} }; // 哈希值 Listnode* h[N] = {nullptr}; void insert(int x){ // 负数情况 int t = (x % N + N) % N; Listnode* add = new Listnode(x, nullptr); if(h[t] == nullptr){ h[t] = add; }else{ add -\u003e next = h[t] -\u003e next; h[t] -\u003e next = add; } } bool find(int x){ int t = (x % N + N) % N; Listnode* root = h[t]; while(root != nullptr){ if(root -\u003e val == x){ return true; } root = root -\u003e next; } return false; } int main(){ int n; cin \u003e\u003e n; while(n--) { char op; int x; cin \u003e\u003e op \u003e\u003e x; if(op == 'I'){ insert(x); }else{ if(find(x)) cout \u003c\u003c \"Yes\" \u003c\u003c endl; else cout \u003c\u003c \"No\" \u003c\u003c endl; } } return 0; } 开放寻址法 产生了冲突之后，向后查找直到找到一个位置value没有任何key存在在这个位置 添加： 查找：计算哈希值，查找哈希序列，如果遇到目标值，返回该目标值的下标。否则继续查找到一个合适位置。 删除：打一个特殊标记，不需要真的删除 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e using namespace std; const int N = 2e5+3; const int null = 0; int h[N], n; // 开放寻址法 int find(int x){ // 负数取余数仍是负数 // 处理负数的情况 int t = (x % N + N) % N; // 直到遇到空的节点，结束搜素 while(h[t] != null){ // 如果找到目标值返回目标值的索引 if(h[t] == x){ break; } t ++; if(t == N - 1){ t = 1; } } // 如果没找到目标值，返回它应该在的位置 return t; } int main(){ cin \u003e\u003e n; while(n-- ){ char op; int x; cin \u003e\u003e op \u003e\u003e x; int t = find(x); if(op == 'I'){ h[t] = x; }else{ if(h[t] == x) cout \u003c\u003c \"Yes\" \u003c\u003c endl; else cout \u003c\u003c \"No\" \u003c\u003c endl; } } return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:1:3","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"字符串哈希 ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:2:0","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"字符串前缀哈希法 将字符串转换为一个k进制的数。 然后将这个数取余数可以得到这个字符串的哈希值 注意不能有字母映射为0，对P，Q取经验值时不会存在哈希冲突。 首先求出一个字符串所有前缀的哈希值 然后可以根据前缀的哈希值就可以在$O(1)$时间内求出任一子串的哈希值 $h[l, r] = h[r] - h[l-1] * p ^{(r - l + 1)}$ ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:2:1","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"字符串哈希 处理多次询问子串是否相同的情况 #include \u003ciostream\u003e using namespace std; typedef unsigned long long ull; const int N = 1e5+10, P = 131; ull h[N], p[N]; // 返回前缀和 ull find(int l, int r){ return h[r] - h[l - 1] * p[r - l + 1]; } int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; string s; cin \u003e\u003e s; p[0] = 1; // 计算前缀 for(int i = 1; i \u003c= n; i++){ p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + s[i - 1]; } while(m-- ){ int l1, r1, l2, r2; cin \u003e\u003e l1 \u003e\u003e r1 \u003e\u003e l2 \u003e\u003e r2; if(find(l1, r1) == find(l2, r2)) cout \u003c\u003c \"Yes\" \u003c\u003c endl; else cout \u003c\u003c \"No\" \u003c\u003c endl; } } ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:2:2","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"堆/优先队列 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:0","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"堆是什么 堆是一颗完全二叉树。 大顶堆：父亲结点的值大于左右子树的结点。 小顶堆：父亲结点的值小于左右子树的结点。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:1","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"堆的操作与优点 优点 O(1)时间内找出最大或最小的数 添加或者删除一个数需要O(logn)的时间复杂度 支持操作-最小堆 向上调整：把欲调整节点与其父亲节点比较，直到其小于父亲节点。 向下调整：将当前结点与左右孩子比较，直到其比左右儿子都小。 存储方式 使用一维数组进行存储，1号点为根节点，同时使用一个变量记录节点的总数。 使用数组静态表示堆$heap[i]$从1开始，该节点左孩子为$heap[2i]$,该节点右孩子为$heap[2i+1]$。 因为堆为完全二叉树，所以数组肯定可以放满。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:2","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"建立堆 先将堆初始化（数组初始化）。 从n/2到1向下调整每一个数。 时间复杂度$O(n)$，而通过插入每一个元素建立堆的时间复杂度是$O(nlogn)$ ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:3","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"向堆中插入一个数 将欲添加元素添加至堆的最后。 将该元素向上调整至合适的位置。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:4","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"求堆顶元素 返回第一个元素即可 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:5","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"删除堆顶元素 把最后一个元素覆盖堆顶元素 删除最后一个元素，缩小数据规模 之后将第一个元素向下调整 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:6","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"删除任意一个元素 将第k个元素与最后一个元素交换 之后删除最后一个元素 然后再将第k个元素分别向上/向下调整（因为不知道交换之后的元素具体位置）。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:7","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"修改任意一个元素 修改第k个元素 然后将第k个元素分别向上/向下调整。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:8","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"堆排序 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int h[N], cnt, n, m; void down(int idx){ int t = idx; if(idx * 2 \u003c= cnt \u0026\u0026 h[idx * 2] \u003c h[t]) t = idx * 2; if(idx * 2 + 1 \u003c= cnt \u0026\u0026 h[idx * 2 + 1] \u003c h[t]) t = idx * 2 + 1; swap(h[t], h[idx]); if(t != idx){ down(t); } } void up(int idx){ int t = idx; if(idx / 2 \u003e 0 \u0026\u0026 h[idx / 2] \u003e h[t]) t = idx / 2; swap(h[t], h[idx]); if(t != idx){ up(t) } } int popTop(){ int ret = h[1]; swap(h[cnt], h[1]); cnt--; down(1); return ret; } // 建堆过程，向下调整 // 时间复杂度O(n) void creatHeap(){ cnt = n; for(int i = n / 2; i \u003e= 1; i--){ down(i); } } int main(){ cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e h[i]; creatHeap(); for(int i = 1; i \u003c= m; i++){ cout \u003c\u003c popTop() \u003c\u003c ' '; } return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:2:0","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"字典树 ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:1:0","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"作用 高效地存储与查找字符串。(O(logn)的时间复杂度进行查找) 支持两种操作：插入一个字符串(insert) 查找是否存在一个字符串(qury) 一个关键点：字典树是通过边存储字符串的。 静态实现 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; // 最多有N*26个节点 int son[N][26], cnt[N], idx; char str[N], op[2]; // 插入一个字符串 void insert(char str[]){ int p = 0; for(int i = 0; str[i]; i++){ int u = str[i] - 'a'; if(!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p]++ ; } // 查询一个字符串，并且返回该字符串出现的次数。 int query(char str[]){ int p = 0; for(int i = 0; str[i]; i++){ int u = str[i] - 'a'; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main(){ int n; scanf(\"%d\", \u0026n); while(n-- ){ scanf(\"%s%s\", \u0026op, \u0026str); if(op[0] == 'I'){ insert(str); }else{ printf(\"%d\\n\", query(str)); } } return 0; } OOP实现 无内存管理，存在内存泄漏 #include \u003ciostream\u003e using namespace std; class Trie{ private: int cnt = 0; Trie* next[26] = {nullptr}; public: Trie(){} void insert(string\u0026 s){ Trie* root = this; for(int i = 0; i \u003c s.size(); i++){ int x = s[i] - 'a'; if(root -\u003e next[x] == nullptr) root -\u003e next[x] = new Trie(); root = root -\u003e next[x]; } root -\u003e cnt += 1; } int qury(string\u0026 s){ Trie* root = this; for(int i = 0; i \u003c s.size(); i++){ int x = s[i] - 'a'; if(root -\u003e next[x] == nullptr) return 0; root = root -\u003e next[x]; } return root-\u003ecnt; } }; int main(){ int n; cin \u003e\u003e n; Trie* root = new Trie(); while(n--){ char op; string s; cin \u003e\u003e op \u003e\u003e s; if(op == 'I'){ root -\u003e insert(s); }else{ cout \u003c\u003c root -\u003e qury(s) \u003c\u003c endl; } } return 0; } 内存管理-\u003e析构函数 #include \u003ciostream\u003e using namespace std; class TrieNode{ public: int cnt = 0; TrieNode* ne[26] = {nullptr}; }; class Trie{ private: TrieNode* root; void delRoot(TrieNode* root){ if(root == nullptr){ return; } for(int i = 0; i \u003c 26; i++){ delRoot(root -\u003e ne[i]); } delete root; } public: Trie(){ root = new TrieNode(); } void insert(string s){ TrieNode* t = root; for(int i = 0; i \u003c s.size(); i++){ int x = s[i] - 'a'; if(t -\u003e ne[x] == nullptr) t -\u003e ne[x] = new TrieNode(); t = t -\u003e ne[x]; } t -\u003e cnt += 1; } int qury(string s){ TrieNode* t = root; for(int i = 0; i \u003c s.size(); i++){ int x = s[i] - 'a'; if(t -\u003e ne[x] == nullptr) return 0; t = t -\u003e ne[x]; } return t -\u003e cnt; } ~Trie(){ delRoot(root); } }; int main(){ int n; cin \u003e\u003e n; Trie myTrie; while(n--){ char op; string s; cin \u003e\u003e op \u003e\u003e s; if(op == 'I'){ myTrie.insert(s); }else{ cout \u003c\u003c myTrie.qury(s) \u003c\u003c endl; } } return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:1:1","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"最大异或对 ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:2:0","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"题目描述 找出一个数组中异或最大的两个数。 ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:2:1","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"暴力 枚举所有的数的组合，分别计算异或值$O(n^2)$ ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:2:2","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"字典树 首先建立每个数的二进制字典树 之后查询字典树，对于每一位优先选择相反的位以获得该位最大的收益。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; // 每个数有31位，所以有31*n个节点 int son[N * 31][2], a[N], index = 0; void insert(int x){ int p = 0; //根节点 // 倒序，最高位靠近根节点。 for(int i = 30; i \u003e= 0; i--){ int u = x \u003e\u003e i \u0026 1; if(!son[p][u]) son[p][u] = ++index; p = son[p][u]; } } int qury(int x){ int p = 0, res = 0; for(int i = 30; i \u003e= 0; i--){ int u = x \u003e\u003e i \u0026 1; if(son[p][!u]){ p = son[p][!u]; // 该位与查询数不同，异或值为1 res += 1 \u003c\u003c i; }else{ p = son[p][u]; } } return res; } int main(){ int n, res = 0; cin \u003e\u003e n; // 建立字典树 for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); insert(a[i]); } // 对于每个数字，查询z for(int i = 0; i \u003c n; i++) res = max(res, qury(a[i])); cout \u003c\u003c res; return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:3:0","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"字符串问题 ","date":"2021-08-24","objectID":"/ch2_string/:1:0","tags":["算法基础课","leetcode","算法","字符串"],"title":"acwing基础课ch2-字符串问题","uri":"/ch2_string/"},{"categories":["算法基础课"],"content":"字符串单模匹配 给你一个字符串haystack和needle，找出needle再haystack中第一个出现的位置。 如果needle未曾出现再haystack时，返回-1。 如果needle是空串，返回0 28. 实现 strStr() ","date":"2021-08-24","objectID":"/ch2_string/:1:1","tags":["算法基础课","leetcode","算法","字符串"],"title":"acwing基础课ch2-字符串问题","uri":"/ch2_string/"},{"categories":["算法基础课"],"content":"暴力算法 枚举haystack中的每个字串 $T:O(m*n)$ ssssssclass Solution { public: int strStr(string haystack, string needle) { if(needle == \"\"){ return 0; } if(haystack.size() \u003c needle.size()){ return -1; } for(int i = 0; i \u003c haystack.size(); i++){ bool flag = true; for(int j = 0;j \u003c needle.size(); j++){ if(haystack[i+j] != needle[j]){ flag = false; break; } } if(flag){ return i; } } return -1; } }; ","date":"2021-08-24","objectID":"/ch2_string/:1:2","tags":["算法基础课","leetcode","算法","字符串"],"title":"acwing基础课ch2-字符串问题","uri":"/ch2_string/"},{"categories":["算法基础课"],"content":"KMP算法 s[n]为目标串，p[n]为模式串 next[i] = j 以i-1为结尾的字符串与前缀匹配的最长的长度为j（p[1,j]和p[i-j, i-1]匹配） 图中的j是模式串的位置，如果第i个数匹配不成功，向后移动查看p[ne[j]+1]和s[i]是否能匹配成功。 如何计算next数组-\u003e类似的思想，如果不匹配，向后移动ne[j]个字符。 匹配成功j = ne[j]向后移动继续匹配下一个串 理解j=ne[j]是向后移动：j是已经匹配了的字符串的长度，继续匹配第j+1个字符 ne数组：ne[i]:与下标i结尾的后缀相同的前缀的长度，取值范围为$0-\u003ei-1$，前缀的长度小于当前子串长度 $T:O(2*m+n)$，$j$在while(j \u0026\u0026 p[i] != p[j + 1])​中最多减$m$次，而$j$在for循环中最多加$m$次。 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003calgorithm\u003e #define N 1000001 char s[N], p[N]; int n, m; int ne[N]; using namespace std; int main(){ // 从第1个字符开始 cin \u003e\u003e n \u003e\u003e p + 1 \u003e\u003e m \u003e\u003e s + 1; // ne[1] = 0,因为第一个不匹配时 // 都可以让目标串向后移动一位 // 求ne数组：ne[i]:与下标i结尾的后缀相同的前缀的长度 for(int i = 2, j = 0; i \u003c= n; i++){ while(j \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j += 1; ne[i] = j; } // 查看next数组 j = 0,意味着从零开始匹配，ne[0]无意义。 // for(int i = 0; i \u003c= n; i++){ // cout \u003c\u003c ne[i] \u003c\u003c ' ' ; // } // cout \u003c\u003c endl; // KMP匹配 // i表示开始匹配的目标串的下标 // j表示匹配的长度 for(int i = 1, j = 0; i \u003c= m; i++){ while(j \u0026\u0026 s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j += 1; if(j == n){ // 计数从1开始所以不用减去1 cout \u003c\u003c i - n \u003c\u003c ' '; // 一定要是ne[j]不能是把整个字符串右移。 j = ne[j]; } } // cout \u003c\u003c ne[n+1]; return 0; } ","date":"2021-08-24","objectID":"/ch2_string/:1:3","tags":["算法基础课","leetcode","算法","字符串"],"title":"acwing基础课ch2-字符串问题","uri":"/ch2_string/"},{"categories":["算法基础课"],"content":"并查集 ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:0","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"并查集是什么 Union,Find,Set 并查集包含Union,Find,Set3个关键词，是一种维护集合的基本操作。 并查集是一种用树表示的集合，树根的编号表示集合的编号。 ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:1","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"并查集实现的方法 并查集由两个任务： 合并：合并两个集合。 查找：判断两个元素是否在一个集合内。 实现：数组实现，索引表示结点编号，数组的值表示索引的根节点。 同一个集合中只能包含一个根节点(father[i] = i)。 查找父节点 int findFather(int x, int father[]){ while(x != father[x]){ x = father[x]; } return x; } 合并结点 一定要使用根节点进行合并。 查找它们的根节点，如果他们根节点不同，则属于不同的集合才可以进行合并。 void Union(int a, int b, int fa[]){ fa[find(a)] = find(b); } 路径压缩 把当前查询结点的路径上所有节点的父亲都指向根节点。 int find(int x, int fa[]){ if(x != far[x]) fa[x] = find(fa[x]); return fa[x]; } ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:2","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"写法 静态 int fa[N]; // 初始化 for(int i = 1; i \u003c= n; i++){ fa[i] = i; } // find int find(int x){ if(x = fa[x]) return x; f[x] = find(f[x]); return f[x]; } // 合并 void Union(int x){ fa[find(x)] = find(y); } // 查询 int qury(int x, int y){ return find(y) == find(y); } OOP class findUnionSet{ private: vector\u003cint\u003e f; public: findUnionSet(int n = N){ f = vector\u003cint\u003e(n + 1, 0); for(int i = 1; i \u003c= n; i++){ f[i] = i; } } int find(int x) { if(x == f[x]) return x; f[x] = find(f[x]); return f[] } void un(int x, int y) { f[find(x)] = find(y); } bool qury(int x, int y) { return find(x) == find(y); } }; ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:3","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"Ac836.合并集合 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; const int N = 1e5+10; class findUnionSet{ private: vector\u003cint\u003e f; public: findUnionSet(int n = N){ f = vector\u003cint\u003e(n + 1, 0); for(int i = 1; i \u003c= n; i++){ f[i] = i; } } int find(int x) { if(x != f[x]) f[x] = find(f[x]); return f[x]; } void un(int x, int y) { f[find(x)] = find(y); } bool qury(int x, int y) { return find(x) == find(y); } }; int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; findUnionSet myun; while(m--){ char op; int x, y; cin \u003e\u003e op \u003e\u003e x \u003e\u003e y; if(op == 'M'){ myun.un(x, y); } else{ if(myun.qury(x, y)) cout \u003c\u003c \"Yes\" \u003c\u003c endl; else cout \u003c\u003c \"No\" \u003c\u003c endl; } } return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:0","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"图基础 ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:1:0","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"有向图 节点之间存在方向 存储方法 邻接矩阵：二维数组。 邻接表：n个单链表，类似于哈希表的拉链法。 邻接表存储模板 // 邻接表 int h[N], e[N * 2], ne[N * 2], idx; // add a -\u003e b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:1:1","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"树与图的深度优先搜索 有向图DFS模板 // 需要标记数组st[N], 遍历节点的每个相邻的边 void dfs(int u) { st[u] = true; // 标记，j for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { dfs(j); } } } 树的重心 后序遍历 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; const int N = 1e5+10; // h表示每个节点的链表头节点，e表示使用的下标为idx的节点的值 // ne表示下标为idx的节点的下一个节点，idx表示当前使用的节点个数。 // 注意所有节点的链表节点头要初始化为-1 int h[N], e[N*2], ne[N*2], idx; bool vis[N]; int n, ans = N; // 有向图邻接表 // a-\u003eb插入一个节点 void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } // 相当于是后序遍历，dfs返回每个子树节点的个数。 int dfs(int u){ vis[u] = true; int num = 1, res = 0; for(int i = h[u]; i != -1; i = ne[i]){ int j = e[i]; if(!vis[j]){ vis[j] = true; int t = dfs(j); res = max(res, t); num += t; } } // n-num为树上半部分的节点数 res = max(res, n - num); ans = min(res, ans); return num; } int main(){ memset(h, -1, sizeof(h)); cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ int a, b; cin \u003e\u003e a \u003e\u003e b; // 无向图 add(a, b), add(b, a); } dfs(1); cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:1:2","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"树与图的宽度优先搜索 解决权重相同的最短路问题 使用队列进行宽度优先搜索 queue \u003c- head while(queue){ t \u003c- queue head 标记t已经访问 拓展t } 图中点的层次 相同权重的最短路问题 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e using namespace std; const int N = 1e5+10; int h[N], e[N], ne[N], idx; // d表示每个节点到1节点的距离。 int d[N]; int n, m; void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int bfs(int x){ queue\u003cint\u003e que; que.push(x); memset(d, -1, sizeof(d)); d[x] = 0; while(!que.empty()){ int t = que.front(); que.pop(); for(int i = h[t]; i != -1; i = ne[i]){ int j = e[i]; if(d[j] == -1){ d[j] = d[t] + 1; que.push(j); } } } return d[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(h, -1, sizeof(h)); while(m--){ int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b); } cout \u003c\u003c bfs(1) \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:1:3","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"拓扑排序 有向图 宽度优先搜索的应用。 起点在其对应的终点前面。 有向无环图一定存在拓扑序列，也称为拓扑图。 步骤 所有入度为0的点入队 依次出队，删除入度为0的点，修改该点的邻接点的入度数 如果邻接点的入度数为0，将该邻接点入队。 ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:2:0","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"有向图的拓扑序列 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cqueue\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int N = 1e5+10; int h[N], e[N*2], ne[N*2], idx; // d存储每个节点的入度个数。 int d[N]; int n, m; void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; d[b] += 1; } bool topsort(vector\u003cint\u003e\u0026 res){ queue\u003cint\u003e que; for(int i = 1; i \u003c= n; i++){ if(d[i] == 0){ que.push(i); } } int in_que = 0; while(!que.empty()){ int t = que.front(); // 出队顺序就是拓扑排序的顺序 res.push_back(t); que.pop(); in_que += 1; for(int i = h[t]; i != -1; i = ne[i]){ int j = e[i]; d[j] -= 1; if(d[j] == 0){ que.push(j); } } } return in_que == n; } int main(){ memset(h, -1, sizeof(h)); cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c m; i++){ int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b); } vector\u003cint\u003e res; if(topsort(res)){ for(int i = 0; i \u003c res.size(); i++){ cout \u003c\u003c res[i] \u003c\u003c ' '; } cout \u003c\u003c endl; }else{ cout \u003c\u003c -1 \u003c\u003c endl; } return 0; } ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:2:1","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"搜索算法 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:1:0","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"DFS与BFS DFS: stack， $O(h)$，h指的是深度 BFS： queue, $O(2^h)$，具有最短路的性质 DFS可以使用递归树进行理清思路 剪枝：直接判断当前状态不合法，直接不继续向下搜索。 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:2:0","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"DFS习题 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:3:0","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"全排列（无重复数字） 回溯搜索 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 10; int a[N], vis[N], path[N]; // c表示当前路径上的个数 void dfs(int n, int c){ // 递归终止条件 if(c \u003e= n){ for(int i = 0; i \u003c n; i++ ) cout \u003c\u003c path[i] \u003c\u003c ' '; cout \u003c\u003c endl; return; } for(int i = 0; i \u003c n; i++){ if(vis[i] == 0){ // 递归 vis[i] = 1; path[c] = a[i]; dfs(n, c + 1); // 回溯 vis[i] = 0; } } } int main(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ a[i] = i + 1; } dfs(n, 0); return 0; } 使用next_permutation() #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 10; int a[N]; int main(){ int n; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++){ a[i] = i; } do{ for(int i = 1; i \u003c= n; i++){ cout \u003c\u003c a[i] \u003c\u003c ' '; } cout \u003c\u003c endl; }while(next_permutation(a+1, a+1+n)); return 0; } ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:3:1","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"子集问题 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:3:2","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"八皇后问题 相同行，列，对角线不能存在皇后 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 10; char g[N][N]; int n; int dx[] = {-1, -1, -1, 1, 1, 1}, dy[] = {-1, 0, 1, -1, 0, 1}; // 检查每行每列是否满足要求 bool check(int x, int y){ for(int i = 0; i \u003c 6; i++){ int x1 = x + dx[i], y1 = y + dy[i]; while(x1 \u003e= 0 \u0026\u0026 x1 \u003c n \u0026\u0026 y1 \u003e= 0 \u0026\u0026 y1 \u003c n){ if(g[x1][y1] == 'Q') return false; x1 = x1 + dx[i], y1 = y1 + dy[i]; } } return true; } void dfs(int cur){ if(cur \u003e= n){ for(int i = 0; i \u003c n; i++) cout \u003c\u003c g[i] \u003c\u003c endl; cout \u003c\u003c endl; return; } for(int i = 0; i \u003c n; i++){ if(check(cur, i)){ g[cur][i] = 'Q'; dfs(cur+1); g[cur][i] = '.'; } } } int main(){ cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c n; j++){ g[i][j] = '.'; } } dfs(0); return 0; } ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:3:3","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"BFS习题 宽度优先搜索最大的优势就是最短路径，所有的路径权重都是1的情况。 队列 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:4:0","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"AC844. 走迷宫 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cqueue\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 100; // a存储整个地图，vis存储每个节点到原点的距离。 int a[N][N]; int vis[N][N]; int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1}; int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c m; j++){ scanf(\"%d\", \u0026a[i][j]); } } queue\u003cPII\u003e que; que.push({0, 0}); while(!que.empty()){ // 队头元素 auto f = que.front(); que.pop(); int row = f.first, col = f.second; if(row == n - 1 \u0026\u0026 col == m - 1){ cout \u003c\u003c vis[row][col] \u003c\u003c endl; break; } // 队头元素进行拓展 for(int i = 0; i \u003c 4; i++){ int x =row + dx[i], y = col + dy[i]; if(x \u003e= 0 \u0026\u0026 x \u003c n \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c m){ if(vis[x][y] == 0 \u0026\u0026 a[x][y] == 0){ que.push({x, y}); vis[x][y] = vis[row][col] + 1; } } } } return 0; } ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:4:1","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"最小生成树与二分图 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:1:0","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"最小生成树 生成树：包含所有节点的无环图。 最小生成树：权值和最小的生成树。 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:2:0","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"朴素Prim算法 $O(n^2)$ 初始化所有点的距离 遍历n个点，每次将一个点加入到最小生成树集合S 找到距离S最近的点，将其加入集合，并且用改点更新其他点的距离。 #include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 510, INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dis[N]; // dis表示点到集合的距离 bool st[N]; // st表示点是否在集合中 int prim(){ memset(dis, 0x3f, sizeof(dis)); int res = 0; for(int i = 0; i \u003c n; i++){ int t = -1; for(int j = 1; j \u003c= n; j++){ if(!st[j] \u0026\u0026 (t == -1 || dis[t] \u003e dis[j])){ t = j; } } // 无法继续更新，无最小生成树。 if(i \u0026\u0026 dis[t] == INF) return INF; // 第一个边不能加入最小生成树 if(i) res += dis[t]; st[t] = true; for(int j = 1;j \u003c= n; j++){ // 注意这里是到集合的最短距离 dis[j] = min(dis[j], g[t][j]); } } return res; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(g, 0x3f, sizeof(g)); while(m-- ){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if(t == INF) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c t \u003c\u003cendl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:2:1","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"Kruskal算法 $O(mlogm)$ 将所有边按照权重从小到大排序。 枚举每条边a,b权重为c 如果a，b不连通，将该条边加入最小生成树的集合当中 用并查集判断a，b是否在同一个连通块当中 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 2e5+10; int p[N], n, m; struct edge{ int a, b, w; bool operator\u003c(edge ne){ return w \u003c ne.w; } }Edge[N]; int find(int x){ // 路径压缩 if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main(){ cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c m; i++){ int a, b, w; cin \u003e\u003e a \u003e\u003e b \u003e\u003e w; Edge[i] = {a, b, w}; } // 1. 从小到大排序 sort(Edge, Edge + m); for(int i = 1; i \u003c= n; i++) p[i] = i; // 2.遍历所有的边 int res = 0, cnt = 0; for(int i = 0; i \u003c m; i++){ int a = Edge[i].a, b = Edge[i].b, w = Edge[i].w; a = find(a), b = find(b); // a, b不属于同一个集合，将其加入集合 if(a != b){ cnt += 1; res += w; p[a] = b; } } if(cnt != n - 1) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:2:2","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"二分图问题 二分图：将所有点分为两个集合，所有的边都在集合外部，集合内无边。 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:3:0","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"染色法判定二分图 如果一个点染色， 则所有与该点相连的点的颜色都可以确定。 二分图中当且仅当不含有奇数环(反证)。 判断染色是否有矛盾。 $O(n)$ #include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 100010, M = 200010; int n, m; // 注意这里建图初始化为M条边 int h[M], e[M], ne[M], idx; int color[N]; void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } bool dfs(int x, int c){ color[x] = c; for(int i = h[x]; i != -1; i = ne[i]){ int j = e[i]; if(!color[j]){ // 如果没染色进行染色 if(!dfs(j, 3 - c)) return false; }else{ // 如果已经染色，判断染色是否冲突，是否有奇数环 if(color[j] == c) return false; } } return true; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(h, -1, sizeof(h)); while(m-- ){ int a, b; scanf(\"%d%d\", \u0026a, \u0026b); add(a, b); add(b, a); } bool flag = true; for(int i = 1; i \u003c= n; i++){ if(!color[i]){ if(dfs(i, 1) == false){ flag = false; break; } } } if(flag == false){ cout \u003c\u003c \"No\" \u003c\u003c endl; }else{ cout \u003c\u003c \"Yes\" \u003c\u003c endl; } return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:3:1","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"匈牙利算法 二分图的最大匹配 二分图的两个集合可以一一匹配的最大的边数。 $O(nm)$ #include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e using namespace std; const int N = 510, M = 100010; int n1, n2, m; int h[N], e[M], ne[M], idx; int match[N]; // match表示右边的点对应的左边的点 bool st[N]; // st表示对于某个左边的点而言，右边的点是否访问过 void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } bool find(int x){ for(int i = h[x]; i != -1; i = ne[i]){ int j = e[i]; if(!st[j]){ st[j] = true; // 如果未匹配，或者可以更改匹配 if(match[j] == 0 || find(match[j])){ match[j] = x; return true; } } } return false; } int main(){ cin \u003e\u003e n1 \u003e\u003e n2 \u003e\u003e m; memset(h, -1, sizeof h); while(m --){ int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b); } int cnt = 0; for(int i = 1; i \u003c= n1; i++){ // 每个点只访问一次 memset(st, false, sizeof st); if(find(i)) cnt += 1; } cout \u003c\u003c cnt \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:3:2","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"最短路问题 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:1:0","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"单源最短路 从起点到其他所有点的最短距离。 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:2:0","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"所有边权都是正数 Dijkstra基于贪心 朴素Dijkstra $T:O(n^2)，n为点的数量，m为边的数量$，适合于稠密图 初始化dis数组，$dis[1]=0$,$dis[i]=inf$，S为已经确定最短路径的点集 迭代n次，每次确定一个点的最短路径。 找到不在S中距离源点最近的点t，并将t加入到S（$n^2$次） 用t更新其他点的距离:$dis \u003e dis[t] + dis(t-\u003ex)$（$m$次） #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; const int N = 510; const int INF = 0x3f3f3f3f; // 稠密图，使用邻接矩阵 int n, m; int g[N][N]; int dis[N]; // 从1到每个点的最短距离 bool st[N]; // 已经确定距离的点集 int dijkstra(){ // 1.初始化为INF memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; // 2.循环n次，每次确定一个点 for(int i = 0; i \u003c n; i++){ // 3.找到当前距离1最近的点 int t = -1; for(int j = 1; j \u003c= n; j++){ if(!st[j] \u0026\u0026 (t == -1 || dis[j] \u003c dis[t])){ t = j; } } // 将该点加入确定的点的集合 st[t] = true; // 4.更新其他点的距离 for(int j = 1; j \u003c= n; j++){ dis[j] = min(dis[j], dis[t] + g[t][j]); } } if(dis[n] == 0x3f3f3f3f) return -1; else return dis[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m; // 存在重边，重边只用保留长度最短的边 memset(g, 0x3f, sizeof(g)); while(m--){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; g[a][b] = min(g[a][b], c); } int t = dijkstra(); cout \u003c\u003c t \u003c\u003c endl; return 0; } 堆优化Dijkstra $T:O(mlogn)$适合于稀疏图 初始化dis数组，$dis[1]=0$,$dis[i]=inf$，S为已经确定最短路径的点集 迭代n次，每次确定一个点的最短路径，因为使用堆优化，所以每次确定最短路径时间为$logn$。 用堆找到不在S中距离源点最近的点t，并将t加入到S（$n$次） 用t更新其他点的距离:$dis \u003e dis[t] + dis(t-\u003ex)$（$mlogn$次，实际为$mlogm$,因为无法堆中无法更新指定点的距离，存在冗余）。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e#include \u003cvector\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 1e6+10; int h[N], ne[N], e[N], w[N], idx; int n, m; int dis[N]; bool st[N]; void add(int a, int b, int c){ e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int dijkstra(){ // 1. 初始化 memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e\u003e heap; heap.push({dis[1], 1}); while(heap.size()){ // 2. 找到距离最短的点，并且标记 auto t = heap.top(); heap.pop(); int node = t.second, distance = t.first; // 已经访问过，这个为冗余边 if(st[node]) continue; st[node] = true; // 3. 用当前点更新其他点的距离。 for(int i = h[node]; i != -1; i = ne[i]){ int j = e[i]; if(dis[j] \u003e dis[node] + w[i]){ dis[j] = dis[node] + w[i]; heap.push({dis[j], j}); } } } if(dis[n] == 0x3f3f3f3f) return -1; else return dis[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(h, -1, sizeof(h)); while(m-- ){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); } int t = dijkstra(); cout \u003c\u003c t \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:2:1","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"存在负边权 如果存在负权回路，最短路可能不存在。 Bellman-Ford 连续进行松弛，每次松弛时把每条边都更新一下，若在n次松弛后还能更新，则说明图中有负环。 $T:O(mn)$ 迭代k次（k的意义:路径长度为k的最短路径），注意把dis进行backup，防止更新过程对下一个产生影响。 遍历所有的边，对于a-\u003eb,w更新dis[b] = min(dis[b], backup[a] + w) 注意要对所有点的距离进行备份，防止在更新过程中收到影响。 bellman - ford算法擅长解决有边数限制的最短路问题 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; const int N = 510, M = 10100; int dis[N], backup[N], n, m, k; struct edge{ int a, b, w; edge(int x, int y, int z):a(x), b(y), w(z){}; edge(){}; }Edge[M]; int bellman_ford(){ // 初始化距离为无穷，并且要把1点的距离置为0 memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; // dis数组意义，迭代k次，路径长度为k的最短距离为dis for(int i = 0; i \u003c k; i++){ memcpy(backup, dis, sizeof(dis)); // 注意要备份 for(int j = 0; j \u003c m; j++){ int a = Edge[j].a, b = Edge[j].b, w = Edge[j].w; dis[b] = min(dis[b], backup[a] + w); } } if(dis[n] \u003e 0x3f3f3f3f / 2) return -1; else return dis[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for(int i = 0; i \u003c m; i++){ int a, b, w; cin \u003e\u003e a \u003e\u003e b \u003e\u003e w; Edge[i] = {a, b, w}; } int t = bellman_ford(); if(t == -1) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c t \u003c\u003c endl; return 0; } SPFA $T:O(m),最坏O(mn)$ SPFA不能存在负权回路 对bellman-ford算法的距离更新进行优化，当a进行更新时，b才会更新。 BFS进行优化，队列中存储距离变小的节点，队列中存储可以更新其他点的点。 当队列不为空，队头出队。 并且访问队头元素所有的边，如果目标点的距离可以被更新则将其加入到队列中。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e using namespace std; const int N = 1e5+10, M = 1e5+10; int dis[N], h[N], n, m; int e[M], ne[M], w[M], idx = 0; // st表示当前节点是否在队列中 // 如果当前节点在队列中，则不可以通过其他节点更新该点。 bool st[N]; void add(int a, int b, int c){ e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int spfa(){ // 1.初始化所有节点距离，将1节点入队 memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; queue\u003cint\u003e que; que.push(1); st[1] = true; // 2.队列不为空时，使用队头节点更新其他节点。 while(!que.empty()){ int t = que.front(); que.pop(); st[t] = false; // 该节点已经不再队列中 for(int i = h[t]; i != -1; i = ne[i]){ int node = e[i], distance = w[i]; if(dis[node] \u003e dis[t] + distance){ dis[node] = dis[t] + distance; // 2.1如果该节点被更新，入队。 if(!st[node]){ que.push(node); // 标记该节点 st[node] = true; } } } } if(dis[n] == 0x3f3f3f3f) return -1; else return dis[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(h, -1, sizeof(h)); while(m--){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); } int t = spfa(); if(t == -1) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c t \u003c\u003c endl; return 0; } SPFA判断负环 用cnt数组记录从源点到该点最短距离经过的边数。 更新距离的过程中同时更新边数，dis[b] = dis[a] + w -\u003e cnt[b] = cnt[a] + 1 如果更新的cnt \u003e n则表示存在负环。 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:2:2","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"多源最短路 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:3:0","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"Floyd算法 基于动态规划d[k,i,j] = d[k-1,i,k]+d[k-1,k,j],k表示只经过1-\u003ek这些点 $O(n^3)$ 枚举中间变量k 枚举起点i，枚举终点j,d[i][j] = min(d[i][j], d[i][k] + d[k][j]) #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int N = 210, INF = 1e9; int n, m, q; int d[N][N]; void floyd(){ for(int k = 1; k \u003c= n; k++){ for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= n; j++){ d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } int main(){ cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= n; j++){ // 初始化自己到自己的距离0，自己到其他点的距离为无穷 if(i == j) d[i][j] = 0; else d[i][j] = INF; } } while(m-- ){ int a, b, w; cin \u003e\u003e a \u003e\u003e b \u003e\u003e w; d[a][b] = min(w, d[a][b]); } floyd(); while(q-- ){ int a, b; cin \u003e\u003e a \u003e\u003e b; if(d[a][b] \u003e INF / 2) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c d[a][b] \u003c\u003c endl; } return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:3:1","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["每日一题"],"content":"787. K 站中转内最便宜的航班 Bellman_ford算法解决有边数限制的最短路问题 K站中转就是最多有k+1条边的最短路问题 acwing模板题 const int N = 110; const int M = N * N / 2; struct edge{ int a, b, w; edge(int x, int y, int z):a(x), b(y), w(z){}; edge(){}; }Edge[M]; class Solution { public: int bellman_ford(int n, int m, int k, int src, int dst){ int dis[N], backup[N]; // 初始化距离，并且设置起点为 0 memset(dis, 0x3f, sizeof(dis)); dis[src] = 0; for(int i = 0; i \u003c k + 1; i++){ // 备份 memcpy(backup, dis, sizeof(dis)); for(int j = 0; j \u003c m; j++){ int a = Edge[j].a, b = Edge[j].b, w = Edge[j].w; dis[b] = min(dis[b], backup[a] + w); // cout \u003c\u003c dis[dst] \u003c\u003c endl; } } if(dis[dst] == 0x3f3f3f3f) return -1; return dis[dst]; } int findCheapestPrice(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 flights, int src, int dst, int k) { int idx = 0; for(auto\u0026 flight: flights){ Edge[idx++] = edge{flight[0], flight[1], flight[2]}; } return bellman_ford(n, idx, k, src, dst); } }; ","date":"2021-08-24","objectID":"/lc787/:1:0","tags":["最短路问题","leetcode","算法","Bellman_ford"],"title":"lc787. K站中转内最便宜的航班","uri":"/lc787/"},{"categories":["每日一题"],"content":"1646. 获取生成数组中的最大值 分两种情况 奇数：nums[i] = nums[i / 2] 偶数：nums[i] = nums[i / 2] + nums[i / 2 + 1] ","date":"2021-08-23","objectID":"/lc1646/:1:0","tags":["模拟","leetcode","算法"],"title":"lc1646.获取生成数组中的最大值","uri":"/lc1646/"},{"categories":["每日一题"],"content":"模拟 class Solution { public: int getMaximumGenerated(int n) { if(n \u003c= 0) return 0; vector\u003cint\u003e nums(n + 1, 0); nums[1] = 1; int res = 1; for(int i = 2; i \u003c= n; i++){ if(i % 2 == 0){ nums[i] = nums[i / 2]; }else{ nums[i] = nums[i / 2] + nums[i / 2 + 1]; } res = max(res, nums[i]); } return res; } }; ","date":"2021-08-23","objectID":"/lc1646/:1:1","tags":["模拟","leetcode","算法"],"title":"lc1646.获取生成数组中的最大值","uri":"/lc1646/"},{"categories":["每日一题"],"content":"789. 逃脱阻碍者 起始点和阻碍者应该同时沿着最短路向目标移动。 由于类似于棋盘的网格状，因此最短路径距离就是曼哈顿距离。 存在以下三种情况。 存在任一阻碍者到达目标的最短路比起始点短，返回false 存在任一阻碍者到达目标的最短路与起始点相同，二者同时到达，返回false 所有阻碍者到达目标的最短路都比起始点远，则可以从起点到达目标点，返回true class Solution { public: int calmanhattanDistance(vector\u003cint\u003e\u0026 p1, vector\u003cint\u003e p2){ return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]); } bool escapeGhosts(vector\u003cvector\u003cint\u003e\u003e\u0026 ghosts, vector\u003cint\u003e\u0026 target) { int okDistance = calmanhattanDistance(target, {0, 0}); for(auto\u0026 ghost: ghosts){ int curDistance = calmanhattanDistance(target, ghost); if(curDistance \u003c= okDistance){ return false; } } return true; } }; ","date":"2021-08-22","objectID":"/lc789/:1:0","tags":["数学","leetcode","算法","最短路问题"],"title":"lc789.逃脱阻碍者","uri":"/lc789/"},{"categories":["每日一题"],"content":"443. 压缩字符串 ","date":"2021-08-21","objectID":"/lc443/:1:0","tags":["字符串","leetcode","算法","双指针"],"title":"lc443. 压缩字符串","uri":"/lc443/"},{"categories":["每日一题"],"content":"使用额外空间 两种情况进行判断是否需要在结果中添加该字符 如果该字符是最后一个字符 或者该字符与下一个字符不相同 $T:O(n)$ $S:O(n)$ class Solution { public: int compress(vector\u003cchar\u003e\u0026 chars) { int n = chars.size(), left = 0; string s; for(int i = 0; i \u003c n; i++){ if(i == n - 1 || chars[i] != chars[i + 1]){ s += chars[i]; int cnt = i - left + 1; left = i + 1; if(cnt == 1) continue; s += to_string(cnt); } } for(int i = 0; i \u003c s.size(); i++){ chars[i] = s[i]; } return s.size(); } }; ","date":"2021-08-21","objectID":"/lc443/:1:1","tags":["字符串","leetcode","算法","双指针"],"title":"lc443. 压缩字符串","uri":"/lc443/"},{"categories":["每日一题"],"content":"不使用额外空间 双指针 read指向已经读取的字符下标，write指向已经更新的压缩的字符下标 两种情况进行判断是否需要在结果中添加该字符 如果该字符是最后一个字符 或者该字符与下一个字符不相同 class Solution { public: int compress(vector\u003cchar\u003e\u0026 chars) { int write = 0, left = 0; int n = chars.size(); for(int read = 0; read \u003c n; read++ ){ // 如果是最后一个或者与下一个相等 if(read == n - 1 || chars[read] != chars[read + 1] ){ // 记录字母 chars[write++] = chars[read]; int cnt = read - left + 1; left = read + 1; // 如果只有一个字母跳过。 if(cnt == 1) continue; string s_cnt = to_string(cnt); for(int i = 0; i \u003c s_cnt.size(); i++){ chars[write++] = s_cnt[i]; } } } return write; } }; ","date":"2021-08-21","objectID":"/lc443/:1:2","tags":["字符串","leetcode","算法","双指针"],"title":"lc443. 压缩字符串","uri":"/lc443/"},{"categories":["每日一题"],"content":"541. 反转字符串 II 按照题意进行翻转即可，使用reverse传入泛型指针进行翻转 class Solution { public: string reverseStr(string s, int k) { int n = s.size(), cur = 0; while(cur + 2 * k \u003c n){ reverse(s.begin() + cur, s.begin() + cur + k); cur += 2 * k; } if(n - cur \u003c k){ reverse(s.begin() + cur, s.end()); }else{ reverse(s.begin() + cur, s.begin() + cur + k); } return s; } }; ","date":"2021-08-20","objectID":"/lc541/:1:0","tags":["字符串","leetcode","算法"],"title":"lc541.反转字符串II","uri":"/lc541/"},{"categories":["每日一题"],"content":"345. 反转字符串中的元音字母 ","date":"2021-08-19","objectID":"/lc345/:1:0","tags":["字符串","leetcode","算法","双指针"],"title":"lc345.反转字符串中的元音字母","uri":"/lc345/"},{"categories":["每日一题"],"content":"双指针 这里可以使用string.find(c)，如果找到了该字母返回该字母的下标，否则返回std::npos，这个是一个固定值。npos 是一个常数，用来表示不存在的位置。 i找到左边元音字母，j找到右边元音字母。 class Solution { public: string aeiou = \"aeiouAEIOU\"; string reverseVowels(string s) { for(int i = 0, j = s.size() - 1; i \u003c j;){ if(aeiou.find(s[i]) == aeiou.npos){ i++; continue; } if(aeiou.find(s[j]) == aeiou.npos){ j--; continue; } swap(s[i], s[j]); i++; j--; } return s; } }; ","date":"2021-08-19","objectID":"/lc345/:1:1","tags":["字符串","leetcode","算法","双指针"],"title":"lc345.反转字符串中的元音字母","uri":"/lc345/"},{"categories":["每日一题"],"content":"516. 最长回文子序列 ","date":"2021-08-12","objectID":"/lc516/:1:0","tags":["type","leetcode","算法"],"title":"lc516.最长回文子序列","uri":"/lc516/"},{"categories":["每日一题"],"content":"暴力 枚举所有的子序列(子集) $T:O(n2^n)$ class Solution { public: int ans = 1; void dfs(string\u0026 s, string\u0026 path, int idx){ // cout \u003c\u003c path \u003c\u003c endl; bool isok = true; for(int i = 0, j = path.size() - 1; i \u003c j; i++, j--){ if(path[i] != path[j]){ isok = false; break; } } if(isok) ans = max(ans, int(path.size())); for(int i = idx; i \u003c s.size(); i++){ path.push_back(s[i]); dfs(s, path, i + 1); path.pop_back(); } } int longestPalindromeSubseq(string s) { string path; dfs(s, path, 0); return ans; } }; ","date":"2021-08-12","objectID":"/lc516/:1:1","tags":["type","leetcode","算法"],"title":"lc516.最长回文子序列","uri":"/lc516/"},{"categories":["每日一题"],"content":"动态规划 状态定义：$f[i][j]$表示$i,j$之间的最长回文子序列的长度 状态转移:$f[i][j] = f[i+1][j-1] + 2,f[i]=f[j]$,$f[i][j] = max(f[i+1][j], f[i][j-1]), f[i]!=f[j]$ 注意这里状态转移会用到$i+1$所以不能从小到大进行枚举，需要大到小进行枚举 $T:O(n^2)$ class Solution { public: int longestPalindromeSubseq(string s) { int n = s.size(); vector\u003cvector\u003cint\u003e\u003e f(n, vector\u003cint\u003e(n, 0)); for(int i = n - 1; i \u003e= 0; i--){ f[i][i] = 1; for(int j = i + 1; j \u003c n; j++){ if(s[i] == s[j]){ f[i][j] = f[i + 1][j - 1] + 2; }else{ f[i][j] = max(f[i][j - 1], f[i + 1][j]); } } } return f[0][n - 1]; } }; ","date":"2021-08-12","objectID":"/lc516/:1:2","tags":["type","leetcode","算法"],"title":"lc516.最长回文子序列","uri":"/lc516/"},{"categories":["每日一题"],"content":"446. 等差数列划分 II - 子序列 ","date":"2021-08-11","objectID":"/lc446/:1:0","tags":["子集","leetcode","动态规划","等差数组"],"title":"lc446.等差数列划分 II - 子序列","uri":"/lc446/"},{"categories":["每日一题"],"content":"暴力枚举所有子序列 枚举子集就是枚举所有的子序列 typedef long long LL; class Solution { public: int ans = 0; void dfs(vector\u003cint\u003e\u0026 nums, vector\u003cLL\u003e\u0026 path, int cur){ if(path.size() \u003e= 3){ for(int i = 1; i \u003c path.size(); i++){ if(path[i] - path[i - 1] != path[1] - path[0]){ return; } } ans += 1; } for(int i = cur; i \u003c nums.size(); i++){ path.push_back(nums[i]); dfs(nums, path, i + 1); path.pop_back(); } } int numberOfArithmeticSlices(vector\u003cint\u003e\u0026 nums) { vector\u003cLL\u003e path; dfs(nums, path, 0); return ans; } }; ","date":"2021-08-11","objectID":"/lc446/:1:1","tags":["子集","leetcode","动态规划","等差数组"],"title":"lc446.等差数列划分 II - 子序列","uri":"/lc446/"},{"categories":["每日一题"],"content":"413. 等差数列划分 ","date":"2021-08-10","objectID":"/lc413/:1:0","tags":["双指针","leetcode","算法","等差数列"],"title":"lc413.等差数列划分","uri":"/lc413/"},{"categories":["每日一题"],"content":"暴力 枚举所有的子数组，之后对每一个数组进行判断是否满足等差数列的条件 $O(n^3)$：$O(n^2)$枚举所有数组，$O(n)$判断该数组是否满足条件 class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); int res = 0; for(int i = 0; i \u003c n; i++){ for(int j = i + 1; j \u003c n; j++){ if(isOk(i, j, nums)){ res += 1; } } } return res; } bool isOk(int x, int y, vector\u003cint\u003e\u0026 nums){ if(y - x + 1 \u003c 3) return false; int d = nums[x + 1] - nums[x]; for(int i = x + 2; i \u003c= y; i++){ if(nums[i] - nums[i - 1] != d){ return false; } } return true; } }; ","date":"2021-08-10","objectID":"/lc413/:1:1","tags":["双指针","leetcode","算法","等差数列"],"title":"lc413.等差数列划分","uri":"/lc413/"},{"categories":["每日一题"],"content":"双指针 枚举以$i$为起点的最长等差子序列 $i -\u003e j$为长度为$len$的等差数列 长度为$len$的等差数列包含$\\sum_{k = 3}^{k = len}$个的长度至少为3的等差子序列 其求和$\\sum_{k = 3}^{k = len}$为$a1 = 1, an = len - 3 + 1$的等差数列。 class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e\u0026 nums) { int res = 0, n = nums.size(); // 枚举以i为起点的最长等差子序列 for(int i = 0; i \u003c n - 1; ){ int j = i + 1; int d = nums[j] - nums[i]; // i -\u003e j为等差数列 while(j + 1 \u003c n \u0026\u0026 nums[j + 1] - nums[j] == d){ j++; } int len = j - i + 1; // 这里要注意：i之后为上一个等差数列的最后一个数j // 不是j+1,因为与j与j+1不能延长上一个等差数列，但是他们可以构成新的等差数列。 // 如 1 2 3 5 7 // 1 2 3 -\u003e i = 0, j = 2 // 之后 // 3 5 7 -\u003e i = 2, j = 4 i = j; if(len \u003c 3) continue; // i -\u003e j 构成了长为len的等差数列 // 长度为len的等差数列包含$\\sum_{k = 3}^{k = len}$所有的子序列 // 其求和为$a1 = 1, an = len - 3 + 1$的等差数列 int a1 = 1, an = len - 3 + 1; res += (a1 + an) * an / 2; } return res; } }; ","date":"2021-08-10","objectID":"/lc413/:1:2","tags":["双指针","leetcode","算法","等差数列"],"title":"lc413.等差数列划分","uri":"/lc413/"},{"categories":["每日一题"],"content":"802. 找到最终的安全状态 ","date":"2021-08-05","objectID":"/lc802/:1:0","tags":["图","leetcode","算法","拓扑排序"],"title":"lc802.找到最终的安全状态","uri":"/lc802/"},{"categories":["每日一题"],"content":"染色法(DFS) 理解题目的意思：无论怎么走必定到达终点 也就是说该节点不能与环相连接 三色标记 label[i]表示当前结点的状态 0: 未访问 1: 可以到达环，或者在环中 2: 可以在有限步到达终点，不会进入到环。 T:O(m+n) S:O(n) class Solution { public: // **理解题目的意思**：**无论怎么走**必定到达终点 // 也就是说该节点不能与环相连接 // 三色标记 label[i]表示当前结点的状态 // 0: 未访问 // 1: 可以到达环，或者在环中 // 2: 可以在有限步到达终点，不会进入到环。 // T:O(m+n) // S:O(n) vector\u003cint\u003e eventualSafeNodes(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { int n = graph.size(); vector\u003cint\u003e label(n, 0); function \u003cbool(int)\u003e safe = [\u0026](int x){ if(label[x] \u003e 0){ return label[x] == 2; } label[x] = 1; for(auto \u0026y :graph[x]){ if(safe(y) == false){ return false; } } label[x] = 2; return true; }; vector\u003cint\u003e res; for(int i = 0; i \u003c n; i++){ if(safe(i)){ res.push_back(i); } } return res; } }; ","date":"2021-08-05","objectID":"/lc802/:1:1","tags":["图","leetcode","算法","拓扑排序"],"title":"lc802.找到最终的安全状态","uri":"/lc802/"},{"categories":["每日一题"],"content":"拓扑排序 将所有边翻转，原来终点(出度为0)反转后入度为零 在环内或者可以到达环的点，反转后经过拓扑排序入度肯定不为0. class Solution { public: vector\u003cint\u003e eventualSafeNodes(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { int n = graph.size(); vector\u003cvector\u003cint\u003e\u003e rg(n, vector\u003cint\u003e()); vector\u003cint\u003e res; vector\u003cint\u003e indegree(n, 0); // 反向图 for(int i = 0; i \u003c n; i++){ auto node = graph[i]; for(auto\u0026 to_node: node){ rg[to_node].push_back(i); indegree[i] += 1; } } // 拓扑排序 queue\u003cint\u003e que; // 添加入度为0的点 for(int i = 0; i \u003c n; i++){ if(indegree[i] == 0){ que.push(i); } } while(!que.empty()){ int x = que.front(); que.pop(); for(auto\u0026 y: rg[x]){ indegree[y]--; if(indegree[y] == 0){ que.push(y); } } } // 把最后入度为0的点添加到结果集。 for(int i = 0; i \u003c n; i++){ if(indegree[i] == 0){ res.push_back(i); } } return res; } }; ","date":"2021-08-05","objectID":"/lc802/:1:2","tags":["图","leetcode","算法","拓扑排序"],"title":"lc802.找到最终的安全状态","uri":"/lc802/"},{"categories":["每日一题"],"content":"611.有效三角形的个数 ","date":"2021-08-04","objectID":"/lc611/:1:0","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"DFS超时 $T:O(2^n)$ class Solution { public: int res = 0; void dfs(vector\u003cint\u003e\u0026 nums, vector\u003cint\u003e\u0026 path, int idx){ if(path.size() \u003e= 3){ int a = path[0], b = path[1], c = path[2]; // cout \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c ' ' \u003c\u003c c \u003c\u003c ' ' \u003c\u003c res \u003c\u003c endl; if((a + b \u003e c) \u0026\u0026 (abs(a - b) \u003c c)){ res += 1; } return ; } for(int i = idx; i \u003c nums.size(); i++){ path.push_back(nums[i]); dfs(nums, path, i + 1); path.pop_back(); } } int triangleNumber(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e path; dfs(nums, path, 0); return res; } }; ","date":"2021-08-04","objectID":"/lc611/:1:1","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"暴力枚举 O(n^3) 超时 class Solution: def triangleNumber(self, nums: List[int]) -\u003e int: res = 0 n = len(nums) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): fisrt, second, third = nums[i], nums[j], nums[k] if fisrt + second \u003e third and abs(fisrt - second) \u003c third: res += 1 return res ","date":"2021-08-04","objectID":"/lc611/:1:2","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"预排序+双指针 注意逆向扫描，正向扫描不对，逆向扫描可以保证两边之差肯定小于第三边，只需要判断两边之和是否大于第三边。 如果l，r满足条件，则l-\u003er-1 与r构成的三角形都满足。 $T:O(n^2)$ class Solution { public: int triangleNumber(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); int res = 0; for(int i = nums.size() - 1; i \u003e= 0; i--){ int l = 0, r = i - 1; // 已经保证两数之差小于第三边 while(l \u003c r){ // 如果 l + r \u003e nums[i] // l -\u003e r - 1 与 r 以及num[i]肯定可以组成三角形 if(nums[l] + nums[r] \u003e nums[i]){ res += r - l; r -= 1; }else{ // 否则增大l边 l += 1; } } } return res; } }; ","date":"2021-08-04","objectID":"/lc611/:1:3","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"581. 最短无序连续子数组 ","date":"2021-08-03","objectID":"/lc581/:1:0","tags":["双指针","leetcode","算法"],"title":"lc581.最短无序连续子数组","uri":"/lc581/"},{"categories":["每日一题"],"content":"排序+双指针 T:O(nlogn) class Solution { public: int findUnsortedSubarray(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e cpy(nums.begin(), nums.end()); sort(cpy.begin(), cpy.end()); int l = -1, r = nums.size(); for(int i = 0; i \u003c nums.size(); i++){ if(nums[i] == cpy[i]){ l = i; }else{ break; } } if(l == nums.size() - 1) return 0; for(int i = nums.size() - 1; i \u003e= 0; i--){ if(nums[i] == cpy[i]){ r = i; }else{ break; } } return r - l - 1; } }; 找规律 T:O(n) 一次遍历，最大的数决定右边界，最小的数决定左边界。 class Solution { public: int findUnsortedSubarray(vector\u003cint\u003e\u0026 nums) { // 一次遍历，最大的数决定右边界，最小的数决定左边界。 // 数组可以分为3部分numsA, numsB, numsC; // numsB重新排序可以将整个数组变为升序排列。 // 对于numsA中每一个数numsA[i] \u003c numB[j]/numsC[j], j \u003e i; // 从右向左遍历数组，记录右边的最小值 // 如果当前数比最小值大，则该数的位置为左边界 int minx = INT_MAX, left = -1; for(int i = nums.size() - 1; i \u003e= 0; i--){ if(minx \u003c nums[i]){ left = i; }else{ minx = nums[i]; } } int maxx = INT_MIN, right = nums.size() - 1; for(int i = 0; i \u003c nums.size(); i++){ if(maxx \u003e nums[i]){ right = i; }else{ maxx = nums[i]; } } if(left == -1) return 0; return right - left + 1; } }; ","date":"2021-08-03","objectID":"/lc581/:1:1","tags":["双指针","leetcode","算法"],"title":"lc581.最短无序连续子数组","uri":"/lc581/"},{"categories":["每日一题"],"content":"743. 网络延迟时间 ","date":"2021-08-02","objectID":"/lc743/:1:0","tags":["图","leetcode","算法","最短路问题"],"title":"lc743.网络延迟时间","uri":"/lc743/"},{"categories":["每日一题"],"content":"dijkstra最短路问题 题意为找距离k最短路径中的最大值作为传递时间 Cpp Tips:在对象内初始化vector注意事项 class内部成员vector\u003cint\u003e x(n, 0)不可以使用，这样会被编译器认为是返回值为vector\u003cint\u003e的成员函数，报错unknown type. 但是可以通过复制构造函数进行构造c++11/c++15 参考链接 class t{ public: // vector\u003cint\u003e s(5, 0); // 编译错误，unknown type of 5 vector\u003cint\u003e s = vector\u003cint\u003e(5, 0); // 复制构造函数 } 稠密图：朴素dijkstra() T:O(mn + n*n) const int N = 110, M = 6100; class Solution { public: int h[N], e[M], w[M], ne[M]; bool vis[N]; int dis[N]; int idx = 0, n = 0; int dijkstra(int k){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[k] = 0; // dijkstra找到距离起点最短距离的最长路径(无堆优化) // T: O(nm) for(int i = 0; i \u003c n; i++){ int find = -1; for(int j = 1; j \u003c= n; j++){ if(vis[j] == false \u0026\u0026 (find == -1 || dis[j] \u003c dis[find] )){ find = j; } } vis[find] = true; for(int u = h[find]; u != -1; u = ne[u]){ int x = e[u]; dis[x] = min(dis[find] + w[u], dis[x]); } } for(int i = 1; i \u003c= n ; i++){ if(dis[i] == 0x3f3f3f3f) return -1; } return *max_element(dis+1, dis+n+1); } int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e\u0026 times, int n_, int k) { n = n_; for(int i = 1; i \u003c= n; i++){ h[i] = -1; } for(auto\u0026 edge: times){ add(edge[0], edge[1], edge[2]); } int res = dijkstra(k); if(res != -1){ return res; }else{ return -1; } } void add(int a, int b, int w_){ e[idx] = b; w[idx] = w_; ne[idx] = h[a]; h[a] = idx++; } }; 稀疏图：堆优化dijkstra() T:O(nlogm) const int N = 110, M = 6100; typedef pair\u003cint, int\u003e PII; class Solution { public: int h[N], e[M], w[M], ne[M]; bool vis[N]; int dis[N]; int idx = 0, n = 0; int dijkstra(int k){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[k] = 0; // dijkstra堆优化，优化找最短路径的过程 // 稀疏图 // T: O(mlogn) priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e \u003e heap; heap.push({dis[k], k}); while(heap.size()){ auto t = heap.top(); heap.pop(); int distance = t.first, node = t.second; if(vis[node]) continue; vis[node] = true; for(int u = h[node]; u != -1; u = ne[u]){ int x = e[u]; if(dis[x] \u003e dis[node] + w[u]){ dis[x] = dis[node] + w[u]; heap.push({dis[x], x}); } } } for(int i = 1; i \u003c= n ; i++){ if(dis[i] == 0x3f3f3f3f) return -1; } return *max_element(dis+1, dis+n+1); } int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e\u0026 times, int n_, int k) { n = n_; for(int i = 1; i \u003c= n; i++){ h[i] = -1; } for(auto\u0026 edge: times){ add(edge[0], edge[1], edge[2]); } int res = dijkstra(k); if(res != -1){ return res; }else{ return -1; } } void add(int a, int b, int w_){ e[idx] = b; w[idx] = w_; ne[idx] = h[a]; h[a] = idx++; } }; ","date":"2021-08-02","objectID":"/lc743/:1:1","tags":["图","leetcode","算法","最短路问题"],"title":"lc743.网络延迟时间","uri":"/lc743/"},{"categories":["每日一题"],"content":"987. 二叉树的垂序遍历 利用三元组记录每个节点[列，行，节点值] 之后进行排序，默认的排序方式就是先按列从小到大排序，再按行从小到大排序，最后按节点值排序 这里用到了c++的元组tuple，元组像pair一样。 构造可以使用列表推导的方式进行构造tuple\u003cint, float, int\u003e t = {1, 1.0, 2}; 但是元组直接访问元素很复杂，使用std::get\u003cidx\u003e(t);,返回值是引用可以直接修改。 get的参数必须是编译是的常数(constant) for each循环可以对tuple直接进行解包，for(const auto\u0026 [n1, n2, n3]: rec) std::tie(n1, n2, n3) = t可以tuple中每个值的引用 c++17标准auto [n1, n2, n3] = t /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ typedef pair\u003cint, int\u003e PII; typedef tuple\u003cint, int, int\u003e TIII; class Solution { public: vector\u003cTIII\u003e rec; void dfs(PII cur, TreeNode* root){ if(root == nullptr){ return; } // 列, 行, 节点值 rec.push_back({cur.second, cur.first, root-\u003eval}); dfs({cur.first + 1, cur.second - 1}, root-\u003eleft); dfs({cur.first + 1, cur.second + 1}, root-\u003eright); } vector\u003cvector\u003cint\u003e\u003e verticalTraversal(TreeNode* root) { dfs({0, 0}, root); vector\u003c vector\u003cint\u003e\u003e res; sort(rec.begin(), rec.end()); int pre = INT_MIN, idx = -1; for(const auto\u0026 [col, row, val]: rec){ if(idx == -1 || pre != col){ res.push_back({}); idx += 1; } res[idx].push_back(val); pre = col; } return res; } }; ","date":"2021-07-31","objectID":"/lc987/:1:0","tags":["二叉树","leetcode","算法"],"title":"lc987.二叉树的垂序遍历","uri":"/lc987/"},{"categories":["每日一题"],"content":"171. Excel 表列序号 ","date":"2021-07-30","objectID":"/lc171/:1:0","tags":["进制转换","算法","leetcode"],"title":"lc171.Excel表列序号","uri":"/lc171/"},{"categories":["每日一题"],"content":"正向遍历 class Solution { public: int titleToNumber(string columnTitle) { // 正向遍历-\u003e叠加权重 int ans = 0, n = columnTitle.size(); for(int i = 0; i \u003c n; i++){ ans = columnTitle[i] - 'A' + ans * 26 + 1; } return ans; } }; ","date":"2021-07-30","objectID":"/lc171/:1:1","tags":["进制转换","算法","leetcode"],"title":"lc171.Excel表列序号","uri":"/lc171/"},{"categories":["每日一题"],"content":"反向遍历 计算每一位的权重 class Solution { public: int titleToNumber(string columnTitle) { // 反向-\u003e计算位权重 int ans = 0, n = columnTitle.size(); long long weight = 1; for(int i = n - 1; i \u003e= 0; i--){ ans += (columnTitle[i] - 'A' + 1) * weight; weight *= 26; } return ans; } }; ","date":"2021-07-30","objectID":"/lc171/:1:2","tags":["进制转换","算法","leetcode"],"title":"lc171.Excel表列序号","uri":"/lc171/"},{"categories":["每日一题"],"content":"212.单词搜索 II ","date":"2021-07-30","objectID":"/lc212/:1:0","tags":["字符串","算法","leetcode"],"title":"lc212.单词搜索 II","uri":"/lc212/"},{"categories":["每日一题"],"content":"字典树+dfs 首先将目标单词依次插入到字典树当中，方便dfs时进行查询 对所有起点进行dfs，如果当前字符与字典树匹配，继续搜索，否则停止搜索。 注意：因为同一个单词中一个位置只允许出现一次，所有需要先用#进行标记，使用完后回复现场。 $T:O(mn3^{l-1})$，$m$是网格的长度，$n$是网格的宽度，$l$指的是单词的最长长度，要搜索$m*n$个网格点，每个网格搜索3个方向，每个方向搜索长度为$l-1$ $S:O(k*l)$，k是待搜索字符串的个数，l是字符串的最长的长度 struct Trie_Node{ unordered_map\u003cchar, Trie_Node*\u003e children; string word; Trie_Node(){ this-\u003eword = \"\"; } }; void Insert_Trie(Trie_Node* root, string\u0026 s){ for(auto\u0026 c: s){ if(root-\u003echildren.count(c) == 0){ root-\u003echildren[c] = new Trie_Node(); } root = root-\u003echildren[c]; } root-\u003eword = s; } class Solution { public: void dfs(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, Trie_Node* root, int x, int y, set\u003cstring\u003e\u0026 ans, int len){ if(len \u003e 10){ return; } char ch = board[x][y]; if(root-\u003echildren.count(ch) == 0){ return; } root = root-\u003echildren[ch]; if(root-\u003eword != \"\"){ ans.insert(root-\u003eword); } // 同一个单词内不允许访问两次，进行标记 board[x][y] = '#'; for(int i = 0; i \u003c 4; i++){ int tx = x + dir[i][0], ty = y + dir[i][1]; if(tx \u003e= 0 \u0026\u0026 tx \u003c board.size() \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c board[0].size()){ if(board[tx][ty] != '#') dfs(board, root, tx, ty, ans, len + 1); } } board[x][y] = ch; } vector\u003cstring\u003e findWords(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, vector\u003cstring\u003e\u0026 words) { Trie_Node* root = new Trie_Node(); vector\u003cstring\u003e res; set\u003cstring\u003e ans; // 把所有需要查询的结点加入到字典树当中 for(auto\u0026 word: words){ Insert_Trie(root, word); } // 遍历网格查找是否有合适的单词 for(int i = 0; i \u003c board.size(); i++){ for(int j = 0; j \u003c board[0].size(); j++){ dfs(board, root, i, j, ans, 0); } } for(auto\u0026 word: ans){ res.push_back(word); } return res; } }; ","date":"2021-07-30","objectID":"/lc212/:1:1","tags":["字符串","算法","leetcode"],"title":"lc212.单词搜索 II","uri":"/lc212/"},{"categories":["每日一题"],"content":"1104. 二叉树寻路 ","date":"2021-07-29","objectID":"/lc1104/:1:0","tags":["二叉树","leetcode","算法"],"title":"lc1104.二叉树寻路","uri":"/lc1104/"},{"categories":["每日一题"],"content":"完全二叉树规律 $i_{father} = i_{child}/2$ 所以先找到该节点对称的结点，再利用完全二叉树的规律即可 完全二叉树一行的开始是$2^{row - 1}$,结束是$2^{row}-1$ 下一行的开始是$2^{row}$ class Solution { public: vector\u003cint\u003e pathInZigZagTree(int label) { if(label == 1){ return {label}; } // rowStart 是这一行的开始 2**(row - 1) // rowStart * 2 是下一行的开始 2**row // 这一行的结束就是rowStart - 1 = 2**row-1 int row = 1, rowStart = 1; while(rowStart * 2 \u003c= label){ row += 1; rowStart *= 2; } vector\u003cint\u003e res(row, 0); while(row){ res[row - 1] = label; // 找到对称结点除以2,就是父亲节点 label = (rowStart * 2 - 1 - label + rowStart) / 2; rowStart /= 2; row -= 1; } return res; } }; ","date":"2021-07-29","objectID":"/lc1104/:1:1","tags":["二叉树","leetcode","算法"],"title":"lc1104.二叉树寻路","uri":"/lc1104/"},{"categories":["每日一题"],"content":"1337. 矩阵中战斗力最弱的 K 行 ","date":"2021-07-29","objectID":"/lc1337/:1:0","tags":["堆","二分查找","leetcode","算法"],"title":"lc1337.矩阵中战斗力最弱的K行","uri":"/lc1337/"},{"categories":["每日一题"],"content":"二分查找+topK 1总是排在前面，所以我们只需要通过二分查找找到最后一个1的位置。 再利用最小堆找出topK小的数 T:O(mlogn+klogm) O(mlogn):二分查找 O(m):构建优先队列，参考：https://www.zhihu.com/question/20729324 O(klogm):topK typedef pair\u003cint, int\u003e PII; class Solution { public: vector\u003cint\u003e kWeakestRows(vector\u003cvector\u003cint\u003e\u003e\u0026 mat, int k) { // O(mlogn):二分查找 vector\u003cPII\u003e cmp; for(int i = 0; i \u003c mat.size(); i++){ int l = -1, r = mat[i].size() - 1; while(l \u003c r){ int mid = (l + r + 1) \u003e\u003e 1; if(mat[i][mid] == 1){ l = mid; }else{ r = mid - 1; } } cmp.push_back({l, i}); } // O(m):构建优先队列 priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e\u003e q(cmp.begin(), cmp.end()); vector\u003cint\u003e ans; // O(klogm):topK for (int i = 0; i \u003c k; ++i) { ans.push_back(q.top().second); q.pop(); } return ans; } }; ","date":"2021-07-29","objectID":"/lc1337/:1:1","tags":["堆","二分查找","leetcode","算法"],"title":"lc1337.矩阵中战斗力最弱的K行","uri":"/lc1337/"},{"categories":["每日一题"],"content":"678. 有效的括号字符串 使用两个栈分别记录左括号和星号（栈内记录其下标），遇到右括号时，首先匹配左括号栈，之后匹配星号栈。 对于左括号栈和星号栈的剩余部分，需要星号匹配左括号，所以星号的下标应该大于左括号。从栈顶开始比较两个栈的下标。 class Solution { public: bool checkValidString(string s) { int cnt = 0; stack\u003cint\u003e l_st; stack\u003cint\u003e s_st; for(int i = 0; i \u003c s.size(); i++){ if(s[i] == '('){ l_st.push(i); }else if(s[i] == '*'){ s_st.push(i); } if(s[i] == ')'){ if(!l_st.empty()){ l_st.pop(); }else if(!s_st.empty()){ s_st.pop(); }else{ return false; } } } while(!l_st.empty()){ if(s_st.empty()){ return false; } if(l_st.top() \u003c s_st.top()){ l_st.pop(); s_st.pop(); }else{ return false; } } return true; } }; ","date":"2021-07-29","objectID":"/lc678/:1:0","tags":["栈","leetcode","算法"],"title":"lc678.有效的括号字符串","uri":"/lc678/"},{"categories":["每日一题"],"content":"543.二叉树的直径 某个结点二叉树的高度等于左右子树中最高的高度+1。 二叉树最大直径，可以在计算高度过程中计算每个结点左右子树的最大路径长度(max(l+r))。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int ans = 0; int diameterOfBinaryTree(TreeNode* root) { height(root); return ans; } int height(TreeNode* root) { if (root == nullptr) { return 0; } int l = height(root-\u003eleft); int r = height(root-\u003eright); ans = max(ans, l + r); return max(l, r) + 1; } }; ","date":"0001-01-01","objectID":"/lc543/:1:0","tags":["树","leetcode","算法"],"title":"lc543.二叉树的直径","uri":"/lc543/"},{"categories":["tools"],"content":"Python模块的位置 ","date":"0001-01-01","objectID":"/python3_module/:1:0","tags":["Python","module"],"title":"Python3_Module","uri":"/python3_module/"},{"categories":["tools"],"content":"查看python模块的位置 python3 -m site 或者在python3命令行中利用sys包查看路径 import sys print(sys.path) ","date":"0001-01-01","objectID":"/python3_module/:1:1","tags":["Python","module"],"title":"Python3_Module","uri":"/python3_module/"},{"categories":["tools"],"content":"dist-packages和site-packages dist-packages路径中安装的是pip安装的官方模块 site-packages路径中安装的是第三方模块 ","date":"0001-01-01","objectID":"/python3_module/:1:2","tags":["Python","module"],"title":"Python3_Module","uri":"/python3_module/"},{"categories":["tools"],"content":"参考 https://www.cnblogs.com/andylhc/p/9673709.html ","date":"0001-01-01","objectID":"/python3_module/:1:3","tags":["Python","module"],"title":"Python3_Module","uri":"/python3_module/"}]