[{"categories":["每日一题"],"content":"516. 最长回文子序列 ","date":"2021-08-12","objectID":"/lc516/:1:0","tags":["type","leetcode","算法"],"title":"lc516.最长回文子序列","uri":"/lc516/"},{"categories":["每日一题"],"content":"暴力 枚举所有的子序列(子集) $T:O(n2^n)$ class Solution { public: int ans = 1; void dfs(string\u0026 s, string\u0026 path, int idx){ // cout \u003c\u003c path \u003c\u003c endl; bool isok = true; for(int i = 0, j = path.size() - 1; i \u003c j; i++, j--){ if(path[i] != path[j]){ isok = false; break; } } if(isok) ans = max(ans, int(path.size())); for(int i = idx; i \u003c s.size(); i++){ path.push_back(s[i]); dfs(s, path, i + 1); path.pop_back(); } } int longestPalindromeSubseq(string s) { string path; dfs(s, path, 0); return ans; } }; ","date":"2021-08-12","objectID":"/lc516/:1:1","tags":["type","leetcode","算法"],"title":"lc516.最长回文子序列","uri":"/lc516/"},{"categories":["每日一题"],"content":"动态规划 状态定义：$f[i][j]$表示$i,j$之间的最长回文子序列的长度 状态转移:$f[i][j] = f[i+1][j-1] + 2,f[i]=f[j]$,$f[i][j] = max(f[i+1][j], f[i][j-1]), f[i]!=f[j]$ 注意这里状态转移会用到$i+1$所以不能从小到大进行枚举，需要大到小进行枚举 $T:O(n^2)$ class Solution { public: int longestPalindromeSubseq(string s) { int n = s.size(); vector\u003cvector\u003cint\u003e\u003e f(n, vector\u003cint\u003e(n, 0)); for(int i = n - 1; i \u003e= 0; i--){ f[i][i] = 1; for(int j = i + 1; j \u003c n; j++){ if(s[i] == s[j]){ f[i][j] = f[i + 1][j - 1] + 2; }else{ f[i][j] = max(f[i][j - 1], f[i + 1][j]); } } } return f[0][n - 1]; } }; ","date":"2021-08-12","objectID":"/lc516/:1:2","tags":["type","leetcode","算法"],"title":"lc516.最长回文子序列","uri":"/lc516/"},{"categories":["每日一题"],"content":"413. 等差数列划分 ","date":"2021-08-10","objectID":"/lc413/:1:0","tags":["双指针","leetcode","算法","等差数列"],"title":"lc413.等差数列划分","uri":"/lc413/"},{"categories":["每日一题"],"content":"暴力 枚举所有的子数组，之后对每一个数组进行判断是否满足等差数列的条件 $O(n^3)$：$O(n^2)$枚举所有数组，$O(n)$判断该数组是否满足条件 class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); int res = 0; for(int i = 0; i \u003c n; i++){ for(int j = i + 1; j \u003c n; j++){ if(isOk(i, j, nums)){ res += 1; } } } return res; } bool isOk(int x, int y, vector\u003cint\u003e\u0026 nums){ if(y - x + 1 \u003c 3) return false; int d = nums[x + 1] - nums[x]; for(int i = x + 2; i \u003c= y; i++){ if(nums[i] - nums[i - 1] != d){ return false; } } return true; } }; ","date":"2021-08-10","objectID":"/lc413/:1:1","tags":["双指针","leetcode","算法","等差数列"],"title":"lc413.等差数列划分","uri":"/lc413/"},{"categories":["每日一题"],"content":"双指针 枚举以$i$为起点的最长等差子序列 $i -\u003e j$为长度为$len$的等差数列 长度为$len$的等差数列包含$\\sum_{k = 3}^{k = len}$个的长度至少为3的等差子序列 其求和$\\sum_{k = 3}^{k = len}$为$a1 = 1, an = len - 3 + 1$的等差数列。 class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e\u0026 nums) { int res = 0, n = nums.size(); // 枚举以i为起点的最长等差子序列 for(int i = 0; i \u003c n - 1; ){ int j = i + 1; int d = nums[j] - nums[i]; // i -\u003e j为等差数列 while(j + 1 \u003c n \u0026\u0026 nums[j + 1] - nums[j] == d){ j++; } int len = j - i + 1; // 这里要注意：i之后为上一个等差数列的最后一个数j // 不是j+1,因为与j与j+1不能延长上一个等差数列，但是他们可以构成新的等差数列。 // 如 1 2 3 5 7 // 1 2 3 -\u003e i = 0, j = 2 // 之后 // 3 5 7 -\u003e i = 2, j = 4 i = j; if(len \u003c 3) continue; // i -\u003e j 构成了长为len的等差数列 // 长度为len的等差数列包含$\\sum_{k = 3}^{k = len}$所有的子序列 // 其求和为$a1 = 1, an = len - 3 + 1$的等差数列 int a1 = 1, an = len - 3 + 1; res += (a1 + an) * an / 2; } return res; } }; ","date":"2021-08-10","objectID":"/lc413/:1:2","tags":["双指针","leetcode","算法","等差数列"],"title":"lc413.等差数列划分","uri":"/lc413/"},{"categories":["每日一题"],"content":"802. 找到最终的安全状态 ","date":"2021-08-05","objectID":"/lc802/:1:0","tags":["图","leetcode","算法","拓扑排序"],"title":"lc802.找到最终的安全状态","uri":"/lc802/"},{"categories":["每日一题"],"content":"染色法(DFS) 理解题目的意思：无论怎么走必定到达终点 也就是说该节点不能与环相连接 三色标记 label[i]表示当前结点的状态 0: 未访问 1: 可以到达环，或者在环中 2: 可以在有限步到达终点，不会进入到环。 T:O(m+n) S:O(n) class Solution { public: // **理解题目的意思**：**无论怎么走**必定到达终点 // 也就是说该节点不能与环相连接 // 三色标记 label[i]表示当前结点的状态 // 0: 未访问 // 1: 可以到达环，或者在环中 // 2: 可以在有限步到达终点，不会进入到环。 // T:O(m+n) // S:O(n) vector\u003cint\u003e eventualSafeNodes(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { int n = graph.size(); vector\u003cint\u003e label(n, 0); function \u003cbool(int)\u003e safe = [\u0026](int x){ if(label[x] \u003e 0){ return label[x] == 2; } label[x] = 1; for(auto \u0026y :graph[x]){ if(safe(y) == false){ return false; } } label[x] = 2; return true; }; vector\u003cint\u003e res; for(int i = 0; i \u003c n; i++){ if(safe(i)){ res.push_back(i); } } return res; } }; ","date":"2021-08-05","objectID":"/lc802/:1:1","tags":["图","leetcode","算法","拓扑排序"],"title":"lc802.找到最终的安全状态","uri":"/lc802/"},{"categories":["每日一题"],"content":"拓扑排序 将所有边翻转，原来终点(出度为0)反转后入度为零 在环内或者可以到达环的点，反转后经过拓扑排序入度肯定不为0. class Solution { public: vector\u003cint\u003e eventualSafeNodes(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { int n = graph.size(); vector\u003cvector\u003cint\u003e\u003e rg(n, vector\u003cint\u003e()); vector\u003cint\u003e res; vector\u003cint\u003e indegree(n, 0); // 反向图 for(int i = 0; i \u003c n; i++){ auto node = graph[i]; for(auto\u0026 to_node: node){ rg[to_node].push_back(i); indegree[i] += 1; } } // 拓扑排序 queue\u003cint\u003e que; // 添加入度为0的点 for(int i = 0; i \u003c n; i++){ if(indegree[i] == 0){ que.push(i); } } while(!que.empty()){ int x = que.front(); que.pop(); for(auto\u0026 y: rg[x]){ indegree[y]--; if(indegree[y] == 0){ que.push(y); } } } // 把最后入度为0的点添加到结果集。 for(int i = 0; i \u003c n; i++){ if(indegree[i] == 0){ res.push_back(i); } } return res; } }; ","date":"2021-08-05","objectID":"/lc802/:1:2","tags":["图","leetcode","算法","拓扑排序"],"title":"lc802.找到最终的安全状态","uri":"/lc802/"},{"categories":["每日一题"],"content":"611.有效三角形的个数 ","date":"2021-08-04","objectID":"/lc611/:1:0","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"DFS超时 $T:O(2^n)$ class Solution { public: int res = 0; void dfs(vector\u003cint\u003e\u0026 nums, vector\u003cint\u003e\u0026 path, int idx){ if(path.size() \u003e= 3){ int a = path[0], b = path[1], c = path[2]; // cout \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c ' ' \u003c\u003c c \u003c\u003c ' ' \u003c\u003c res \u003c\u003c endl; if((a + b \u003e c) \u0026\u0026 (abs(a - b) \u003c c)){ res += 1; } return ; } for(int i = idx; i \u003c nums.size(); i++){ path.push_back(nums[i]); dfs(nums, path, i + 1); path.pop_back(); } } int triangleNumber(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e path; dfs(nums, path, 0); return res; } }; ","date":"2021-08-04","objectID":"/lc611/:1:1","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"暴力枚举 O(n^3) 超时 class Solution: def triangleNumber(self, nums: List[int]) -\u003e int: res = 0 n = len(nums) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): fisrt, second, third = nums[i], nums[j], nums[k] if fisrt + second \u003e third and abs(fisrt - second) \u003c third: res += 1 return res ","date":"2021-08-04","objectID":"/lc611/:1:2","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"预排序+双指针 注意逆向扫描，正向扫描不对，逆向扫描可以保证两边之差肯定小于第三边，只需要判断两边之和是否大于第三边。 如果l，r满足条件，则l-\u003er-1 与r构成的三角形都满足。 $T:O(n^2)$ class Solution { public: int triangleNumber(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); int res = 0; for(int i = nums.size() - 1; i \u003e= 0; i--){ int l = 0, r = i - 1; // 已经保证两数之差小于第三边 while(l \u003c r){ // 如果 l + r \u003e nums[i] // l -\u003e r - 1 与 r 以及num[i]肯定可以组成三角形 if(nums[l] + nums[r] \u003e nums[i]){ res += r - l; r -= 1; }else{ // 否则增大l边 l += 1; } } } return res; } }; ","date":"2021-08-04","objectID":"/lc611/:1:3","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"581. 最短无序连续子数组 ","date":"2021-08-03","objectID":"/lc581/:1:0","tags":["双指针","leetcode","算法"],"title":"lc581.最短无序连续子数组","uri":"/lc581/"},{"categories":["每日一题"],"content":"排序+双指针 T:O(nlogn) class Solution { public: int findUnsortedSubarray(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e cpy(nums.begin(), nums.end()); sort(cpy.begin(), cpy.end()); int l = -1, r = nums.size(); for(int i = 0; i \u003c nums.size(); i++){ if(nums[i] == cpy[i]){ l = i; }else{ break; } } if(l == nums.size() - 1) return 0; for(int i = nums.size() - 1; i \u003e= 0; i--){ if(nums[i] == cpy[i]){ r = i; }else{ break; } } return r - l - 1; } }; 找规律 T:O(n) 一次遍历，最大的数决定右边界，最小的数决定左边界。 class Solution { public: int findUnsortedSubarray(vector\u003cint\u003e\u0026 nums) { // 一次遍历，最大的数决定右边界，最小的数决定左边界。 // 数组可以分为3部分numsA, numsB, numsC; // numsB重新排序可以将整个数组变为升序排列。 // 对于numsA中每一个数numsA[i] \u003c numB[j]/numsC[j], j \u003e i; // 从右向左遍历数组，记录右边的最小值 // 如果当前数比最小值大，则该数的位置为左边界 int minx = INT_MAX, left = -1; for(int i = nums.size() - 1; i \u003e= 0; i--){ if(minx \u003c nums[i]){ left = i; }else{ minx = nums[i]; } } int maxx = INT_MIN, right = nums.size() - 1; for(int i = 0; i \u003c nums.size(); i++){ if(maxx \u003e nums[i]){ right = i; }else{ maxx = nums[i]; } } if(left == -1) return 0; return right - left + 1; } }; ","date":"2021-08-03","objectID":"/lc581/:1:1","tags":["双指针","leetcode","算法"],"title":"lc581.最短无序连续子数组","uri":"/lc581/"},{"categories":["每日一题"],"content":"743. 网络延迟时间 ","date":"2021-08-02","objectID":"/lc743/:1:0","tags":["图","leetcode","算法","最短路问题"],"title":"lc743.网络延迟时间","uri":"/lc743/"},{"categories":["每日一题"],"content":"dijkstra最短路问题 题意为找距离k最短路径中的最大值作为传递时间 Cpp Tips:在对象内初始化vector注意事项 class内部成员vector\u003cint\u003e x(n, 0)不可以使用，这样会被编译器认为是返回值为vector\u003cint\u003e的成员函数，报错unknown type. 但是可以通过复制构造函数进行构造c++11/c++15 参考链接 class t{ public: // vector\u003cint\u003e s(5, 0); // 编译错误，unknown type of 5 vector\u003cint\u003e s = vector\u003cint\u003e(5, 0); // 复制构造函数 } 稠密图：朴素dijkstra() T:O(mn + n*n) const int N = 110, M = 6100; class Solution { public: int h[N], e[M], w[M], ne[M]; bool vis[N]; int dis[N]; int idx = 0, n = 0; int dijkstra(int k){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[k] = 0; // dijkstra找到距离起点最短距离的最长路径(无堆优化) // T: O(nm) for(int i = 0; i \u003c n; i++){ int find = -1; for(int j = 1; j \u003c= n; j++){ if(vis[j] == false \u0026\u0026 (find == -1 || dis[j] \u003c dis[find] )){ find = j; } } vis[find] = true; for(int u = h[find]; u != -1; u = ne[u]){ int x = e[u]; dis[x] = min(dis[find] + w[u], dis[x]); } } for(int i = 1; i \u003c= n ; i++){ if(dis[i] == 0x3f3f3f3f) return -1; } return *max_element(dis+1, dis+n+1); } int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e\u0026 times, int n_, int k) { n = n_; for(int i = 1; i \u003c= n; i++){ h[i] = -1; } for(auto\u0026 edge: times){ add(edge[0], edge[1], edge[2]); } int res = dijkstra(k); if(res != -1){ return res; }else{ return -1; } } void add(int a, int b, int w_){ e[idx] = b; w[idx] = w_; ne[idx] = h[a]; h[a] = idx++; } }; 稀疏图：堆优化dijkstra() T:O(nlogm) const int N = 110, M = 6100; typedef pair\u003cint, int\u003e PII; class Solution { public: int h[N], e[M], w[M], ne[M]; bool vis[N]; int dis[N]; int idx = 0, n = 0; int dijkstra(int k){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[k] = 0; // dijkstra堆优化，优化找最短路径的过程 // 稀疏图 // T: O(mlogn) priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e \u003e heap; heap.push({dis[k], k}); while(heap.size()){ auto t = heap.top(); heap.pop(); int distance = t.first, node = t.second; if(vis[node]) continue; vis[node] = true; for(int u = h[node]; u != -1; u = ne[u]){ int x = e[u]; if(dis[x] \u003e dis[node] + w[u]){ dis[x] = dis[node] + w[u]; heap.push({dis[x], x}); } } } for(int i = 1; i \u003c= n ; i++){ if(dis[i] == 0x3f3f3f3f) return -1; } return *max_element(dis+1, dis+n+1); } int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e\u0026 times, int n_, int k) { n = n_; for(int i = 1; i \u003c= n; i++){ h[i] = -1; } for(auto\u0026 edge: times){ add(edge[0], edge[1], edge[2]); } int res = dijkstra(k); if(res != -1){ return res; }else{ return -1; } } void add(int a, int b, int w_){ e[idx] = b; w[idx] = w_; ne[idx] = h[a]; h[a] = idx++; } }; ","date":"2021-08-02","objectID":"/lc743/:1:1","tags":["图","leetcode","算法","最短路问题"],"title":"lc743.网络延迟时间","uri":"/lc743/"},{"categories":["每日一题"],"content":"987. 二叉树的垂序遍历 利用三元组记录每个节点[列，行，节点值] 之后进行排序，默认的排序方式就是先按列从小到大排序，再按行从小到大排序，最后按节点值排序 这里用到了c++的元组tuple，元组像pair一样。 构造可以使用列表推导的方式进行构造tuple\u003cint, float, int\u003e t = {1, 1.0, 2}; 但是元组直接访问元素很复杂，使用std::get\u003cidx\u003e(t);,返回值是引用可以直接修改。 get的参数必须是编译是的常数(constant) for each循环可以对tuple直接进行解包，for(const auto\u0026 [n1, n2, n3]: rec) std::tie(n1, n2, n3) = t可以tuple中每个值的引用 c++17标准auto [n1, n2, n3] = t /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ typedef pair\u003cint, int\u003e PII; typedef tuple\u003cint, int, int\u003e TIII; class Solution { public: vector\u003cTIII\u003e rec; void dfs(PII cur, TreeNode* root){ if(root == nullptr){ return; } // 列, 行, 节点值 rec.push_back({cur.second, cur.first, root-\u003eval}); dfs({cur.first + 1, cur.second - 1}, root-\u003eleft); dfs({cur.first + 1, cur.second + 1}, root-\u003eright); } vector\u003cvector\u003cint\u003e\u003e verticalTraversal(TreeNode* root) { dfs({0, 0}, root); vector\u003c vector\u003cint\u003e\u003e res; sort(rec.begin(), rec.end()); int pre = INT_MIN, idx = -1; for(const auto\u0026 [col, row, val]: rec){ if(idx == -1 || pre != col){ res.push_back({}); idx += 1; } res[idx].push_back(val); pre = col; } return res; } }; ","date":"2021-07-31","objectID":"/lc987/:1:0","tags":["二叉树","leetcode","算法"],"title":"lc987.二叉树的垂序遍历","uri":"/lc987/"},{"categories":["每日一题"],"content":"171. Excel 表列序号 ","date":"2021-07-30","objectID":"/lc171/:1:0","tags":["进制转换","算法","leetcode"],"title":"lc171.Excel表列序号","uri":"/lc171/"},{"categories":["每日一题"],"content":"正向遍历 class Solution { public: int titleToNumber(string columnTitle) { // 正向遍历-\u003e叠加权重 int ans = 0, n = columnTitle.size(); for(int i = 0; i \u003c n; i++){ ans = columnTitle[i] - 'A' + ans * 26 + 1; } return ans; } }; ","date":"2021-07-30","objectID":"/lc171/:1:1","tags":["进制转换","算法","leetcode"],"title":"lc171.Excel表列序号","uri":"/lc171/"},{"categories":["每日一题"],"content":"反向遍历 计算每一位的权重 class Solution { public: int titleToNumber(string columnTitle) { // 反向-\u003e计算位权重 int ans = 0, n = columnTitle.size(); long long weight = 1; for(int i = n - 1; i \u003e= 0; i--){ ans += (columnTitle[i] - 'A' + 1) * weight; weight *= 26; } return ans; } }; ","date":"2021-07-30","objectID":"/lc171/:1:2","tags":["进制转换","算法","leetcode"],"title":"lc171.Excel表列序号","uri":"/lc171/"},{"categories":["每日一题"],"content":"1104. 二叉树寻路 ","date":"2021-07-29","objectID":"/lc1104/:1:0","tags":["二叉树","leetcode","算法"],"title":"lc1104.二叉树寻路","uri":"/lc1104/"},{"categories":["每日一题"],"content":"完全二叉树规律 $i_{father} = i_{child}/2$ 所以先找到该节点对称的结点，再利用完全二叉树的规律即可 完全二叉树一行的开始是$2^{row - 1}$,结束是$2^{row}-1$ 下一行的开始是$2^{row}$ class Solution { public: vector\u003cint\u003e pathInZigZagTree(int label) { if(label == 1){ return {label}; } // rowStart 是这一行的开始 2**(row - 1) // rowStart * 2 是下一行的开始 2**row // 这一行的结束就是rowStart - 1 = 2**row-1 int row = 1, rowStart = 1; while(rowStart * 2 \u003c= label){ row += 1; rowStart *= 2; } vector\u003cint\u003e res(row, 0); while(row){ res[row - 1] = label; // 找到对称结点除以2,就是父亲节点 label = (rowStart * 2 - 1 - label + rowStart) / 2; rowStart /= 2; row -= 1; } return res; } }; ","date":"2021-07-29","objectID":"/lc1104/:1:1","tags":["二叉树","leetcode","算法"],"title":"lc1104.二叉树寻路","uri":"/lc1104/"}]