[{"categories":["每日一题"],"content":"292. Nim 游戏 ","date":"2021-09-18","objectID":"/lc292/:1:0","tags":["博弈论","leetcode","算法"],"title":"lc292.Nim 游戏","uri":"/lc292/"},{"categories":["每日一题"],"content":"博弈论 博弈论问题一般是两方进行对抗的问题 首先如果有3枚以下的石头，那么我方一定获胜。如果有4枚石头，我方一定能获胜。 考虑5颗石头的情况，由于每次只能拿$1-3$颗石头，所以我们应该考虑$f[i],i \\in {4,3,2}$，一旦其中有必败的情况，表示我方一定获胜。 class Solution { public: bool canWinNim(int n) { vector\u003cint\u003e f(n + 1, true); if(n \u003e= 4) f[4] = false; for(int i = 5; i \u003c= n; i++){ f[i] = false; for(int j = i - 1; i - j \u003c= 3; j--){ if(f[j] == false){ f[i] = true; } } } return f[n]; } }; ","date":"2021-09-18","objectID":"/lc292/:1:1","tags":["博弈论","leetcode","算法"],"title":"lc292.Nim 游戏","uri":"/lc292/"},{"categories":["每日一题"],"content":"找规律 我们可以发现当石头的数量是4的倍数时，我们一定失败，否则一定会获胜。 class Solution { public: bool canWinNim(int n) { vector\u003cint\u003e f(4, true); f[0] = false; return f[n % 4]; } }; ","date":"2021-09-18","objectID":"/lc292/:1:2","tags":["博弈论","leetcode","算法"],"title":"lc292.Nim 游戏","uri":"/lc292/"},{"categories":["每日一题"],"content":"类似题目进阶 877. 石子游戏 ","date":"2021-09-18","objectID":"/lc292/:1:3","tags":["博弈论","leetcode","算法"],"title":"lc292.Nim 游戏","uri":"/lc292/"},{"categories":["每日一题"],"content":"36.有效的数独 ","date":"2021-09-17","objectID":"/lc36/:1:0","tags":["遍历","leetcode","算法"],"title":"lc36.有效的数独","uri":"/lc36/"},{"categories":["每日一题"],"content":"暴力遍历 遍历每一行，每一列，每个block进行检查。 class Solution { public: bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) { int m = board.size(), n = board[0].size(); // row for(int i = 0; i \u003c m; i++){ vector\u003cbool\u003e ok(10, false); for(int j = 0; j \u003c n; j++){ if(board[i][j] == '.'){ continue; } int x = board[i][j] - '0'; if(ok[x] == false){ ok[x] = true; }else{ return false; } } } // cout \u003c\u003c \"row ok \\n\"; // col for(int i = 0; i \u003c n; i++){ vector\u003cbool\u003e ok(10, false); for(int j = 0;j \u003c m; j++){ if(board[j][i] == '.'){ continue; } int x = board[j][i] - '0'; if(ok[x] == false){ ok[x] = true; }else{ return false; } } } // cout \u003c\u003c \"col ok \\n\"; int dir[9][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1},{1, 0}, {1, 1}, {0, 0}}; // block for(int i = 1; i \u003c m; i += 3){ for(int j = 1; j \u003c n; j += 3){ vector\u003cbool\u003e ok(10, false); for(int k = 0; k \u003c 9; k++){ int ti = i + dir[k][0], tj = j + dir[k][1]; if(board[ti][tj] == '.'){ continue; } int x = board[ti][tj] - '0'; if(ok[x] == false){ ok[x] = true; } else{ return false; } } } } return true; } }; ","date":"2021-09-17","objectID":"/lc36/:1:1","tags":["遍历","leetcode","算法"],"title":"lc36.有效的数独","uri":"/lc36/"},{"categories":["每日一题"],"content":"一次遍历更新所有信息 class Solution { public: bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) { // 一次遍历 int row[9][10]; int col[9][10]; int block[3][3][10]; memset(row, 0, sizeof(row)); memset(col, 0, sizeof(col)); memset(block, 0, sizeof(block)); for(int i = 0; i \u003c board.size(); i++){ for(int j = 0; j \u003c board[0].size(); j++){ if(board[i][j] == '.'){ continue; } int x = board[i][j] - '0'; row[i][x] ++; col[j][x] ++; block[i/3][j/3][x] ++; if(row[i][x] \u003e 1 || col[j][x] \u003e 1 || block[i/3][j/3][x] \u003e 1){ return false; } } } return true; } }; ","date":"2021-09-17","objectID":"/lc36/:1:2","tags":["遍历","leetcode","算法"],"title":"lc36.有效的数独","uri":"/lc36/"},{"categories":["每日一题"],"content":"212.单词搜索 II ","date":"2021-09-16","objectID":"/lc212/:1:0","tags":["字典树","leetcode","算法","字符串"],"title":"lc212.单词搜索II","uri":"/lc212/"},{"categories":["每日一题"],"content":"字典树+dfs 首先将目标单词依次插入到字典树当中，方便dfs时进行查询 对所有起点进行dfs，如果当前字符与字典树匹配，继续搜索，否则停止搜索。 注意：因为同一个单词中一个位置只允许出现一次，所有需要先用#进行标记，使用完后回复现场。 $T:O(mn3^{l-1})$，$m$是网格的长度，$n$是网格的宽度，$l$指的是单词的最长长度，要搜索$m*n$个网格点，每个网格搜索3个方向，每个方向搜索长度为$l-1$ $S:O(k*l)$，k是待搜索字符串的个数，l是字符串的最长的长度 struct Trie_Node{ unordered_map\u003cchar, Trie_Node*\u003e children; string word; Trie_Node(){ this-\u003eword = \"\"; } }; void Insert_Trie(Trie_Node* root, string\u0026 s){ for(auto\u0026 c: s){ if(root-\u003echildren.count(c) == 0){ root-\u003echildren[c] = new Trie_Node(); } root = root-\u003echildren[c]; } root-\u003eword = s; } class Solution { public: int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}}; void dfs(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, Trie_Node* root, int x, int y, set\u003cstring\u003e\u0026 ans, int len){ if(len \u003e 10){ return; } char ch = board[x][y]; if(root-\u003echildren.count(ch) == 0){ return; } root = root-\u003echildren[ch]; if(root-\u003eword != \"\"){ ans.insert(root-\u003eword); } // 同一个单词内不允许访问两次，进行标记 board[x][y] = '#'; for(int i = 0; i \u003c 4; i++){ int tx = x + dir[i][0], ty = y + dir[i][1]; if(tx \u003e= 0 \u0026\u0026 tx \u003c board.size() \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c board[0].size()){ if(board[tx][ty] != '#') dfs(board, root, tx, ty, ans, len + 1); } } board[x][y] = ch; } vector\u003cstring\u003e findWords(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, vector\u003cstring\u003e\u0026 words) { Trie_Node* root = new Trie_Node(); vector\u003cstring\u003e res; set\u003cstring\u003e ans; // 把所有需要查询的结点加入到字典树当中 for(auto\u0026 word: words){ Insert_Trie(root, word); } // 遍历网格查找是否有合适的单词 for(int i = 0; i \u003c board.size(); i++){ for(int j = 0; j \u003c board[0].size(); j++){ dfs(board, root, i, j, ans, 0); } } for(auto\u0026 word: ans){ res.push_back(word); } return res; } }; ","date":"2021-09-16","objectID":"/lc212/:1:1","tags":["字典树","leetcode","算法","字符串"],"title":"lc212.单词搜索II","uri":"/lc212/"},{"categories":["每日一题"],"content":"162. 寻找峰值 ","date":"2021-09-15","objectID":"/lc162/:1:0","tags":["二分查找","leetcode","算法"],"title":"lc162.寻找峰值","uri":"/lc162/"},{"categories":["每日一题"],"content":"寻找最大值 依照题意$-1,n$位置都是比任意值要小，而且数组中没有任意两个数字完全相同，所以 最大值肯定是目标值之一。 class Solution { public: int findPeakElement(vector\u003cint\u003e\u0026 nums) { return max_element(nums.begin(), nums.end()) - nums.begin(); } }; ","date":"2021-09-15","objectID":"/lc162/:1:1","tags":["二分查找","leetcode","算法"],"title":"lc162.寻找峰值","uri":"/lc162/"},{"categories":["每日一题"],"content":"二分查找 考虑一下几种情况 $nums[i] \u003e nums[i - 1] \u0026\u0026 nums[i] \u003e nums[i + 1]$：目标值，满足要求 $nums[i] \u003e nums[i - 1] \u0026\u0026 nums[i] \u003c nums[i + 1]$：向右移动 $nums[i] \u003c nums[i - 1] \u0026\u0026 nums[i] \u003e nums[i + 1]$：向左移动 $nums[i] \u003c nums[i - 1] \u0026\u0026 nums[i] \u003c nums[i + 1]$：可以向左也可以向右移动 如果我们选择第四种情况向右移动的话，不满足条件的三种情况可以化简为 $nums[i] \u003e nums[i + 1]$：向左移动 $nums[i] \u003e nums[i + 1]$：向右移动 那么对于区间$[l, r]$，如果$mid$满足条件，直接返回即可 不满足条件，我们需要对$mid$进行判断，如果$nums[i] \u003e nums[i + 1]$，则答案肯定在左半边$[i + 1, r]$直接舍去，右半边同理 注意这里有c++匿名函数的写法 [外部变量访问方式说明符] (参数表) -\u003e 返回值类型 { 语句块 } []:外部变量访问方式说明符可选=(定义在外部的变量不可以在语句块内修改),\u0026(定义在外部的变量可以在语句块内修改) class Solution { public: int findPeakElement(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); int l = 0, r = n - 1; // 方便进行判断，如果超出数组索引，返回{0, 0}, 否则返回{1, nums[i]},那么超出索引肯定小于索引内的数 auto get = [\u0026](int x) -\u003e pair\u003cint, int\u003e { if(x == -1 || x == n){ return {0, 0}; } return {1, nums[x]}; }; // 肯定会有满足条件的下标，则遍历所有下标 while(l \u003c= r){ int mid = l + r \u003e\u003e 1; if(get(mid) \u003e get(mid - 1) \u0026\u0026 get(mid) \u003e get(mid + 1)){ return mid; }else if(get(mid) \u003e get(mid + 1)){ r = mid; }else{ l = mid + 1; } } return -1; } }; ","date":"2021-09-15","objectID":"/lc162/:1:2","tags":["二分查找","leetcode","算法"],"title":"lc162.寻找峰值","uri":"/lc162/"},{"categories":["每日一题"],"content":"524. 通过删除字母匹配到字典里最长单词 ","date":"2021-09-14","objectID":"/lc524/:1:0","tags":["字符串","leetcode","算法","双指针"],"title":"lc524.通过删除字母匹配到字典里最长单词","uri":"/lc524/"},{"categories":["每日一题"],"content":"排序+双指针 双指针：判断一个字符串是不是另一个字符串的子串采用双指针,$T:O(n)$ 排序：首先按照字符串长度进行排序，在长度相同的情况下，按照字符串的首字母字典序进行排序。 $T:O(mlogm+m*n)$，$m$是字符串数组的长度，$n$是单个字符串的平均长度。排序时间复杂度$mlogm$，查询m个字符串是不是该串的子串$O(mn)$. class Solution { public: static bool cmp(string\u0026 a, string\u0026 b){ if(a.size() != b.size()){ return a.size() \u003e= b.size(); }else{ return a \u003c b; } } string findLongestWord(string s, vector\u003cstring\u003e\u0026 dictionary) { sort(dictionary.begin(), dictionary.end(), cmp); for(auto\u0026 word: dictionary){ int i = 0, j = 0; for(; i \u003c s.size() \u0026\u0026 j \u003c word.size();){ if(s[i] == word[j]){ i++, j++; }else{ i++; } } if(j == word.size()){ return word; } } return \"\"; } }; ","date":"2021-09-14","objectID":"/lc524/:1:1","tags":["字符串","leetcode","算法","双指针"],"title":"lc524.通过删除字母匹配到字典里最长单词","uri":"/lc524/"},{"categories":["每日一题"],"content":"447. 回旋镖的数量 计算两两点之间的距离 假如相同距离的点为$n$个的话，则满足条件的三元组有$A_{n}^{2} = n * (n - 1)$个 class Solution { public: // A_{n}^{2} = n * (n - 1) int numberOfBoomerangs(vector\u003cvector\u003cint\u003e\u003e\u0026 points) { int ans = 0; for(auto\u0026 p1: points){ unordered_map\u003cint, int\u003e mp; for(auto\u0026 p2: points){ int dis = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]); mp[dis] += 1; } for(auto\u0026 [_, cnt]: mp){ cnt *= cnt - 1; ans += cnt; } } return ans; } }; ","date":"2021-09-13","objectID":"/lc447/:1:0","tags":["哈希表","leetcode","算法"],"title":"447.回旋镖的数量","uri":"/lc447/"},{"categories":["每日一题"],"content":"600. 不含连续1的非负整数 ","date":"2021-09-11","objectID":"/lc600/:1:0","tags":["位运算","leetcode","算法","数位DP"],"title":"lc600.不含连续1的非负整数","uri":"/lc600/"},{"categories":["每日一题"],"content":"暴力位运算 $O(n)$ 注意运算符优先级：“单算移关与，异或逻条赋” 关系运算符优先级要比位运算优先级要高。 class Solution { public: bool is_ok(int n ){ for(int i = 0; (1 \u003c\u003c i + 1) \u003c= n; i++){ int cur = 1 \u003c\u003c i, next = 1 \u003c\u003c i + 1; if((cur \u0026 n) \u003e 0 \u0026\u0026 (n \u0026 next) \u003e 0){ return false; } } return true; } int findIntegers(int n) { int ans = 0; for(int i = 0; i \u003c= n; i++){ if(is_ok(i)){ ans += 1; } } return ans; } }; ","date":"2021-09-11","objectID":"/lc600/:1:1","tags":["位运算","leetcode","算法","数位DP"],"title":"lc600.不含连续1的非负整数","uri":"/lc600/"},{"categories":["每日一题"],"content":"DFS $O(m)$, m为满足条件的数字个数 class Solution { public: int ans = 0; int max_n; int findIntegers(int n) { ans = 1; max_n = n; dfs(1); return ans; } void dfs(int x){ if(x \u003e max_n) return; ans += 1; // 最后一位是1,后面只能添加一位1 if(x \u0026 1 == 1){ dfs(x \u003c\u003c 1); }else{ // 最后一位是0,后面可以添加1/0 dfs(x \u003c\u003c 1); dfs((x \u003c\u003c 1) + 1); } } }; ","date":"2021-09-11","objectID":"/lc600/:1:2","tags":["位运算","leetcode","算法","数位DP"],"title":"lc600.不含连续1的非负整数","uri":"/lc600/"},{"categories":["每日一题"],"content":"动态规划 数位DP一般都是询问$[a, b]$区间内，符号条件的个数有多少个。通常需要实现查询$[0, x]$区间内满足条件的个数，则$[a, b]$之间满足的个数应该为$dp[b]-dp[a-1]$ 还需要理解 class Solution { public: int get_len(int n ){ for(int i = 31; i \u003e= 0; i--){ if(n \u003e\u003e i \u0026 1) return i; } return 0; } int findIntegers(int n) { int len = get_len(n); int f[50][2]; f[1][0] = 1, f[1][1] = 2; for(int i = 1; i \u003c= 32; i++){ f[i + 1][0] = f[i][1]; f[i + 1][1] = f[i][1] + f[i][0]; } int ans = 0, pre = 0; for(int i = len; i \u003e= 0; i--){ int cur = n \u003e\u003e i \u0026 1; if(cur == 1) ans += f[i + 1][0]; if(cur == 1 \u0026\u0026 pre == 1) break; pre = cur; if(i == 0) ans += 1; } return ans; } }; ","date":"2021-09-11","objectID":"/lc600/:1:3","tags":["位运算","leetcode","算法","数位DP"],"title":"lc600.不含连续1的非负整数","uri":"/lc600/"},{"categories":["tips"],"content":"运算符优先级口诀 “单算移关与，异或逻条赋” “单”表示单目运算符：逻辑非(!),按位取反(~),自增(++),自减(–),取地址(\u0026),取值(*)； “算”表示算术运算符：乘、除和求余(*,/,%)级别高于加减(+,-)； “关”表示关系运算符：大小关系(\u003e,\u003e=,\u003c,\u003c=)级别高于相等不相等关系(==,!=)； “与”表示按位与(\u0026)； “异”表示按位异或(^)； “或”表示按位或(|)； “逻”表示逻辑运算符：逻辑与(\u0026\u0026)级别高于逻辑或(||)； “条”表示条件运算符(? :)； “赋”表示赋值运算符(=,+=,-=,*=,/=,%=,»=,«=,\u0026=,^=, |=,!=)； 参考 参考链接 ","date":"2021-09-11","objectID":"/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%A3%E8%AF%80/:1:0","tags":["leetcode","算法","运算符优先级"],"title":"tips1-运算符优先级口诀","uri":"/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%A3%E8%AF%80/"},{"categories":["每日一题"],"content":"68. 文本左右对齐 首先理解题目：这道题要求除了最后一行两端对齐，最后一行靠左对齐。 首先先计算每一行可以放哪些单词 之后将计算每行放多少空格，额外需要添加多少空格，最后一个单词空格不足的话，需要额外补足。 最后对最后一行进行从左到右处理。 $T:O(n)$,$n$为单词的数目 class Solution { public: vector\u003cstring\u003e fullJustify(vector\u003cstring\u003e\u0026 words, int maxWidth) { vector\u003cstring\u003e res; vector\u003cvector\u003cstring\u003e\u003e lines; // 每一行可以放哪些单词 int length = 0; vector\u003cstring\u003e line; for(auto\u0026 word: words){ if(length + word.size() \u003e maxWidth){ lines.push_back(line); line.clear(); length = 0; } line.push_back(word); length += word.size(); // 添加新的单词前，需要至少添加一个空格 length++; } if(!line.empty()){ lines.push_back(line); } string line_string; // 依次处理每一行 for(int i = 0; i \u003c lines.size() - 1; i++){ int total_length = 0; auto cur = lines[i]; for(int j = 0; j \u003c cur.size(); j++){ total_length += cur[j].size(); } // 计算每一行平均需要添加的空格数 // 已经左边每个空格额外需要的空个数 int n_words = cur.size() - 1; int n_space = 0, extra_space = 0; if(n_words != 0){ n_space = (maxWidth - total_length) / n_words; extra_space = (maxWidth - total_length) % n_words; } for(int j = 0; j \u003c cur.size(); j++){ if(j \u003c cur.size() - 1){ line_string += cur[j]; line_string += string(n_space, ' '); if(extra_space \u003e 0){ line_string += string(1, ' '); extra_space -= 1; } }else{ line_string += cur[j]; } } // 如果右侧有剩余部分，添加额外空格 int n_empty = maxWidth - line_string.size(); if(n_empty \u003e 0) line_string += string(n_empty, ' '); res.push_back(line_string); line_string.clear(); } if(lines.size() - 1 \u003e= 0){ // 处理最后一行 auto line = lines[lines.size() - 1]; for(int i = 0; i \u003c line.size(); i++){ if(i \u003c line.size() - 1){ line_string += line[i]; line_string += string(1, ' '); }else{ line_string += line[i]; } } int n_empty = maxWidth - line_string.size(); if(n_empty \u003e 0) line_string += string(n_empty, ' '); res.push_back(line_string); } return res; } }; ","date":"2021-09-09","objectID":"/lc68/:1:0","tags":["模拟","leetcode","算法","字符串"],"title":"lc68. 文本左右对齐","uri":"/lc68/"},{"categories":["每日一题"],"content":"502. IPO 如果没有k的限制：依次将资本消耗从小到大进行排序，然后投资capital[i],之后w+=profits[i] 有了k的限制 首先仍是将资本消耗从小到大排序 但是在选择项目时需要考虑利润的因素，每一次需要选择所有满足资本投资capital[i] \u003c w中利润最大的项目，可以利用最大堆获取。 这里需要注意的是，在每次投资之后资本w1会变大为w2，每次只需将w1-\u003ew2之间的项目入堆即可。 $O(n + k)logn$ typedef pair\u003cint, int\u003e PII; class Solution { public: // 如果没有k的限制：依次将资本消耗从小到大进行排序，然后投资capital[i],之后w+=profits[i] // 有了k的限制 // 首先仍是将资本消耗从小到大排序 // 但是在选择项目时需要考虑利润的因素，每一次需要选择所有满足资本投资capital[i] \u003c w中利润最大的项目，可以利用最大堆获取。 // 这里需要注意的是，在每次投资之后资本w1会变大为w2，每次只需将w1-\u003ew2之间的项目入堆即可。 // $O(n + k)logn$ int findMaximizedCapital(int k, int w, vector\u003cint\u003e\u0026 profits, vector\u003cint\u003e\u0026 capital) { vector\u003cPII\u003e projects; int n = profits.size(), idx = 0; priority_queue\u003cint, vector\u003cint\u003e\u003e hp; for(int i = 0; i \u003c n; i++){ projects.push_back({capital[i], profits[i]}); } // 排序 sort(projects.begin(), projects.end()); for(int i = 0; i \u003c k; i++){ while(idx \u003c n \u0026\u0026 projects[idx].first \u003c= w){ hp.push(projects[idx].second); idx++; } if(hp.empty()){ break; }else{ w += hp.top(); hp.pop(); } } return w; } }; ","date":"2021-09-08","objectID":"/lc502/:1:0","tags":["贪心","堆","leetcode","算法"],"title":"lc502. IPO","uri":"/lc502/"},{"categories":["每日一题"],"content":"165. 比较版本号 ","date":"2021-09-01","objectID":"/lc165/:1:0","tags":["字符串","leetcode","算法","双指针"],"title":"lc165. 比较版本号","uri":"/lc165/"},{"categories":["每日一题"],"content":"split后双指针比较 先对字符串做split提取出每个小的版本号 之后对每个小版本号进行比较即可。 $T:O(n)$ $S:O(n)$ class Solution { public: vector\u003cint\u003e split_s(string\u0026 s){ vector\u003cint\u003e res; for(int i = 0, num = 0; i \u003c s.size(); i++){ if(s[i] == '.'){ res.push_back(num); num = 0; }else{ num = num * 10 + s[i] - '0'; if(i == s.size() - 1) res.push_back(num); } } return res; } int compareVersion(string version1, string version2) { vector\u003cint\u003e split_v1 = split_s(version1); vector\u003cint\u003e split_v2 = split_s(version2); int n1 = split_v1.size(), n2 = split_v2.size(); for(int i = 0, j = 0; i \u003c n1 || j \u003c n2; i++, j++){ int x = 0, y = 0; if(i \u003c n1) x = split_v1[i]; if(j \u003c n2) y = split_v2[j]; if(x \u003e y) return 1; if(x \u003c y) return -1; } return 0; } }; ","date":"2021-09-01","objectID":"/lc165/:1:1","tags":["字符串","leetcode","算法","双指针"],"title":"lc165. 比较版本号","uri":"/lc165/"},{"categories":["每日一题"],"content":"直接使用双指针，边split边比较 class Solution { public: unsigned int get_num(string\u0026 version, int\u0026 idx){ if(idx \u003e= version.size()) return 0; unsigned int ans = 0; while(idx \u003c version.size()){ if(version[idx] == '.'){ idx++; break; } ans = ans * 10 + version[idx] - '0'; idx ++; } return ans; } int compareVersion(string version1, string version2) { int idx1 = 0, idx2 = 0; // 类似于split，每次提取出来的两个.之间的数字 // 如果下标已经超过了字符串的大小，则直接返回零进行比较。 while(idx1 \u003c version1.size() || idx2 \u003c version2.size()){ unsigned int n1 = get_num(version1, idx1); unsigned int n2 = get_num(version2, idx2); // cout \u003c\u003c n1 \u003c\u003c ' ' \u003c\u003c n2 \u003c\u003c endl; if(n1 \u003e n2) return 1; if(n1 \u003c n2) return -1; } return 0; } }; ","date":"2021-09-01","objectID":"/lc165/:1:2","tags":["字符串","leetcode","算法","双指针"],"title":"lc165. 比较版本号","uri":"/lc165/"},{"categories":["每日一题"],"content":"1109. 航班预订统计 差分用于快速处理区间的增量。 当我们需要对某一数组$a[n]$,区间$[l,r]$之间添加一个增量$inc$时，也就是对差分数组$d[n]$进行$d[l]+= inc, d[r + 1]-=inc$，之后对差分数组求前缀和，便可以对原数组进行快速的增量处理 $T:O(m + n)$ class Solution { public: vector\u003cint\u003e corpFlightBookings(vector\u003cvector\u003cint\u003e\u003e\u0026 bookings, int n) { vector\u003cint\u003e ans(n, 0); for(auto \u0026book: bookings){ int x = book[0] - 1, y = book[1] - 1, w = book[2]; ans[x] += w; if(y \u003c n - 1) ans[y + 1] -= w; } for(int i = 1; i \u003c ans.size(); i++){ ans[i] += ans[i - 1]; } return ans; } }; ","date":"2021-08-31","objectID":"/lc1109/:1:0","tags":["差分","leetcode","算法"],"title":"lc1109.航班预订统计","uri":"/lc1109/"},{"categories":["每日一题"],"content":"528. 按权重随机选择 题目的意思是根据下标不同的权重产生随机数 $w[i]$代表产生随机数$i$的权重 首先将计算所有数的和，然后依次计算前缀和，均匀分布产生的随机数$randnum$，在两个前缀和$[pre[i-1], pre[i])$之间的范围代表产生该数$i$。 如$w={1,2,3,4}$，分别代表产生$p_{0}=\\frac{1}{10},p_{1}=\\frac{2}{10}，p_{2}=\\frac{3}{10}，p_{3}=\\frac{4}{10}$ 首先计算前缀和数组$pre={0,1,3,6,10}$ 之后通过均匀分布产生一个在$[0,10)$之间的随机数$randnum$,根据$randnum$的取值重新产生新的随机数$i$，$randnum\\in[pre[i-1],pre[i])$，表示产生随机数$i-1$ 也就是在前缀和数组中找到第一个大于$randnum$的前缀和下标$i$，返回$i-1$，或者找到最后一个小于等于$randnum$的前缀和下标$i$，并且返回$i$ ","date":"2021-08-30","objectID":"/lc528/:1:0","tags":["随机数","leetcode","算法"],"title":"lc528.按权重随机选择","uri":"/lc528/"},{"categories":["每日一题"],"content":"第一个大于randnum的前缀和数组下标 $T:O(logn)$ class Solution { public: vector\u003cint\u003e pre = {0}; int range = 0; Solution(vector\u003cint\u003e\u0026 w) { for(auto w_: w){ range += w_; pre.push_back(range); } } int pickIndex() { int randnum = rand() % range; int idx = upper_bound(pre.begin(), pre.end(), randnum) - pre.begin(); return idx - 1; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(w); * int param_1 = obj-\u003epickIndex(); */ ","date":"2021-08-30","objectID":"/lc528/:1:1","tags":["随机数","leetcode","算法"],"title":"lc528.按权重随机选择","uri":"/lc528/"},{"categories":["每日一题"],"content":"最后一个小于等于randnum的数 class Solution { public: vector\u003cint\u003e pre = {0}; int range = 0; Solution(vector\u003cint\u003e\u0026 w) { for(auto w_: w){ range += w_; pre.push_back(range); } } int pickIndex() { int randnum = rand() % range; // 最后一个小于等于randnum的下标i，返回i int l = 0, r = pre.size() - 1; while(l \u003c r){ int mid = (l + r + 1) \u003e\u003e 1; if(pre[mid] \u003c= randnum){ l = mid; }else{ r = mid - 1; } } return l; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(w); * int param_1 = obj-\u003epickIndex(); */ ","date":"2021-08-30","objectID":"/lc528/:1:2","tags":["随机数","leetcode","算法"],"title":"lc528.按权重随机选择","uri":"/lc528/"},{"categories":["每日一题"],"content":"1480. 一维数组的动态和 ","date":"2021-08-28","objectID":"/lc1480/:1:0","tags":["前缀和","leetcode","算法"],"title":"lc1480. 一维数组的动态和","uri":"/lc1480/"},{"categories":["每日一题"],"content":"前缀和 pre[i]表示前i个数的和 返回i+1-\u003eend class Solution { public: vector\u003cint\u003e runningSum(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); vector\u003cint\u003e pre(n + 1, 0); for(int i = 1; i \u003c= n; i++){ pre[i] = pre[i - 1] + nums[i - 1]; } return vector\u003cint\u003e(pre.begin() + 1, pre.end()); } }; ","date":"2021-08-28","objectID":"/lc1480/:1:1","tags":["前缀和","leetcode","算法"],"title":"lc1480. 一维数组的动态和","uri":"/lc1480/"},{"categories":["每日一题"],"content":"881. 救生艇 ","date":"2021-08-26","objectID":"/lc881/:1:0","tags":["贪心","双指针","leetcode","算法"],"title":"lc881. 救生艇","uri":"/lc881/"},{"categories":["每日一题"],"content":"贪心+双指针 $T:O(nlogn)$ class Solution { public: int numRescueBoats(vector\u003cint\u003e\u0026 people, int limit) { sort(people.begin(), people.end()); int n = people.size(), cnt = 0; // 双指针+贪心 // 从小到大进行排序 // i指向最小,j指向最大 // i和j相加小于limit,则i与所有的j都可以组合成一组,此时应该贪心选择最优策略，两个相加重量最大 // i和j相加大于limit,则j与其他所有的i都不可以组成一组,j-- for(int i = 0, j = n - 1; i \u003c= j;){ if(people[i] + people[j] \u003c= limit){ i++;j--; }else{ j--; } cnt += 1; } return cnt; } }; ","date":"2021-08-26","objectID":"/lc881/:1:1","tags":["贪心","双指针","leetcode","算法"],"title":"lc881. 救生艇","uri":"/lc881/"},{"categories":["每日一题"],"content":"797. 所有可能的路径 ","date":"2021-08-25","objectID":"/lc797/:1:0","tags":["DFS","leetcode","算法"],"title":"lc797.所有可能的路径","uri":"/lc797/"},{"categories":["每日一题"],"content":"DFS 有向无环图DAG不会重复访问同一个点，所以不需要记录这些点是否访问过。 class Solution { public: vector\u003cvector\u003cint\u003e\u003e res; void dfs(vector\u003cvector\u003cint\u003e\u003e\u0026 g, int begin, vector\u003cint\u003e\u0026 path, int n ){ if(begin == n){ res.push_back(path); return; } for(int i = 0; i \u003c g[begin].size(); i++){ path.push_back(g[begin][i]); dfs(g, g[begin][i], path, n); path.pop_back(); } } vector\u003cvector\u003cint\u003e\u003e allPathsSourceTarget(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { vector\u003cint\u003e path; int n = graph.size() - 1; path.push_back(0); dfs(graph, 0, path, n); return res; } }; ","date":"2021-08-25","objectID":"/lc797/:1:1","tags":["DFS","leetcode","算法"],"title":"lc797.所有可能的路径","uri":"/lc797/"},{"categories":["算法基础课"],"content":"位运算 ","date":"2021-08-24","objectID":"/ch1_%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["算法基础课","leetcode","算法","位运算"],"title":"acwing基础课ch1-位运算","uri":"/ch1_%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"位的统计问题 计算n的二进制表示中第k位 先把第k位移动到最后一位， 然后进行判断。 lowbit(x)运算：返回x的最后一位1的位置 -x = ~x + 1 x \u0026 -x 1010 -\u003e10 101000 -\u003e 1000 二进制中1的个数 暴力统计每个数中的每一位 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; int a[N], n; void cal_bits(int\u0026 x){ int res = 0; while(x){ if(x \u0026 1) res += 1; x = x \u003e\u003e 1; } x = res; } int main(){ cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026a[i]); for(int i = 0; i \u003c n; i++){ cal_bits(a[i]); printf(\"%d \", a[i]); } return 0; } x \u0026 (-x)-\u003elow_bit(x)得到二进制中最右边的1的位置。 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; int x, n; int low_bits(int x){ return x \u0026 (-x); } int main(){ cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026x); int res = 0; while(x) { x = x - low_bits(x); res += 1; } cout \u003c\u003c res \u003c\u003c ' '; } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E4%BD%8D%E8%BF%90%E7%AE%97/:1:1","tags":["算法基础课","leetcode","算法","位运算"],"title":"acwing基础课ch1-位运算","uri":"/ch1_%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"前缀和 ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:1:0","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"一维前缀和 利用存储的部分前缀和快速计算部分数组的和 前缀和数组长度为n+1 s[0] = 0, s[i]表示nums[i]前所有数的和，不包括nums[i] s[i]表示前i个数的前缀和 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; int a[N], s[N]; int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026a[i]); for(int i = 1; i \u003c= n; i++){ s[i] = s[i - 1] + a[i - 1]; } // 注意这里输入的数据是前l, r个数字。 while(m--){ int l, r; cin \u003e\u003e l \u003e\u003e r; printf(\"%d\\n\", s[r] - s[l - 1]); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:1:1","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"二维前缀和-\u003e计算指定区域内的和 $s[i][j]$表示的是前i行，前j列的区域和。 #include \u003ciostream\u003e using namespace std; const int N = 1010; int a[N][N], s[N][N]; int main(){ int n, m, q; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c m; j++){ scanf(\"%d\", \u0026a[i][j]); } } for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= m; j++){ s[i][j] = a[i - 1][j - 1] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; } } while(q-- ){ int x1, y1, x2, y2; scanf(\"%d%d%d%d\", \u0026x1, \u0026y1, \u0026x2, \u0026y2); printf(\"%d\\n\", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:1:2","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"差分 构造一个新的数组使原数组成为该数组的前缀和。 作用：用O(1)的时间让某个区间[l, r]全部加上一个值 原数组求差分数组相当于差分数组在对应位置插入原数组的值，a[l] + c, a[r+1] - c。 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; int a[N], b[N]; void insert(int l, int r, int c){ b[l] += c; b[r + 1] -= c; } int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); // 原数组相当于差分数组在对应位置插入原数组的值 for(int i = 1; i \u003c= n; i++) insert(i, i, a[i]); while(m--){ int l, r, c; scanf(\"%d%d%d\",\u0026l, \u0026r, \u0026c); // 进行插入操作 insert(l, r, c); } // 对b数组求前缀和得到修改以后的数组 for(int i = 1; i \u003c= n; i++){ b[i] += b[i-1]; printf(\"%d \",b[i]); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:2:0","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"二维差分数组 在二维区域内$a[x1][y1]-\u003ea[x2][y2]$区域间所有的数加上一个数c. 等同于其差分数组$b[x1][y1] += c$，$b[x2+1][y1]-=c$，$b[x1][y2+1]-=c$，$b[x2+1][y2+1]+=c$ #include \u003ciostream\u003e using namespace std; const int N = 1010; int a[N][N], b[N][N]; void insert(int x1,int y1,int x2,int y2, int c){ b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main(){ int n, m, q; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= m; j++){ scanf(\"%d\", \u0026a[i][j]); insert(i, j, i, j, a[i][j]); } } while(q-- ){ int x1, y1, x2, y2, c; scanf(\"%d%d%d%d%d\", \u0026x1, \u0026y1, \u0026x2, \u0026y2, \u0026c); insert(x1, y1, x2, y2, c); } for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= m; j++){ // 计算前缀和 b[i][j] = b[i - 1][j] + b[i][j - 1] + b[i][j] - b[i - 1][j - 1]; printf(\"%d \", b[i][j]); } printf(\"\\n\"); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/:2:1","tags":["算法基础课","leetcode","算法","前缀和与差分"],"title":"acwing基础课ch1-前缀和与差分","uri":"/ch1_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"categories":["算法基础课"],"content":"双指针 ","date":"2021-08-24","objectID":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":["算法基础课","leetcode","算法","双指针"],"title":"acwing基础课ch1-双指针","uri":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法基础课"],"content":"两个序列双指针 归并排序 ","date":"2021-08-24","objectID":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/:1:1","tags":["算法基础课","leetcode","算法","双指针"],"title":"acwing基础课ch1-双指针","uri":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法基础课"],"content":"一个序列同向双指针 双指针利用某种性质将暴力(n^2)的算法优化到O(n). 实现split() 最长连续不重复子序列 暴力做法：枚举以i为结尾的所有数组，j表示离当前i最远的不重复数组。 暴力做法：TLE #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cunordered_set\u003e using namespace std; const int N = 1e5+10; int a[N]; int main(){ int res = 0, n = 0; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026a[i]); for(int i = 0; i \u003c n; i++){ unordered_set\u003cint\u003e uset; for(int j = i; j \u003e= 0; j--){ // check if(uset.find(a[j]) != uset.end()){ break; }else{ res = max(i - j + 1, res); } uset.insert(a[j]); } } cout \u003c\u003c res; return 0; } 双指针 利用反证法，如果以i结尾的子数组最长不重复对应左节点为j，那么i+1结尾最长不重复数组对应左节点大于 等于j。且如果左节点大于j的话，一定是由于新加入的i+1导致的。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cunordered_set\u003e using namespace std; const int N = 1e5+10; int a[N]; int main(){ int res = 0, n = 0; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026a[i]); unordered_set\u003cint\u003e uset; for(int i = 0, j = 0; i \u003c n; i++){ // 删除j, 直到当前j -\u003e i 中没有重复数字。 while(j \u003c i \u0026\u0026 uset.find(a[i]) != uset.end()){ uset.erase(a[j]); j++; } // 产生的重复是由a[i]导致的 uset.insert(a[i]); res = max(i - j + 1, res); } cout \u003c\u003c res; return 0; } 数组元素的目标和 给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。 求A[i] + B[j] = x i正序枚举，j倒序枚举，如果$A[i] + B[j] \u003e t$则$A[i+1]+B[j]\u003et$,所以j可以从$j+1$开始枚举。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int a[N], b[N]; int main(){ int n, m, t; cin \u003e\u003e n \u003e\u003e m \u003e\u003e t; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } for(int i = 0; i \u003c m; i++){ scanf(\"%d\", \u0026b[i]); } for(int i = 0, j = m - 1; i \u003c n; i++){ while(j \u003e= 0 \u0026\u0026 a[i] + b[j] \u003e t) j--; if(a[i] + b[j] == t){ printf(\"%d %d\", i, j); break; } } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/:1:2","tags":["算法基础课","leetcode","算法","双指针"],"title":"acwing基础课ch1-双指针","uri":"/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法基础课"],"content":"排序 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:0:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"分类 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:1:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"复杂度分析 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:2:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"快速排序 基于分治思想 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"主要步骤 确定分界点x，随机(一般为左端点) 调整范围，左半边小于等于x，右半边大于等于x（双指针）。 如果忘记了双指针方法，可以暴力开数组求解。 递归处理左右区间。 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:1","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"复杂度分析 最坏时间复杂度发生在数组有序的时候，数组有序时，每次划分的区间都是左边界，时间复杂度时$O(n^2)$ 最好时间复杂度：切分点在数组中间，$C_n = 2C_{n/2} + n$,$T:O(nlogn)$ 平均时间复杂度：切分点的期望是在数组中间，因此平均复杂度就是最好的时间复杂度。 空间复杂度：$O(logn)$递归栈调用，最差为$O(n)$ ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:2","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"Acwing785. 快速排序 快速选择切分，递归进行左右半边的区间排序 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5 + 10; int a[N]; int Quick_Select(int a[], int l, int r){ swap(a[l], a[l+r\u003e\u003e1]); int x = a[l] ,i = l, j = r+1; // 如果超出了数据范围break即可 while(i \u003c j){ while(a[++i] \u003c x){ if(i \u003e= r) break; } while(a[--j] \u003e x){ if(j \u003c= l) break; } if(i \u003c j) swap(a[i], a[j]); } swap(a[l], a[j]); return j; } void Quick_Sort(int a[], int l, int r){ if(l \u003e= r) return; int j = Quick_Select(a, l, r); // cout \u003c\u003c l \u003c\u003c ' ' \u003c\u003c r \u003c\u003c ' ' \u003c\u003c j \u003c\u003c endl; Quick_Sort(a, l, j-1); Quick_Sort(a, j+1, r); } int main(){ int n; scanf(\"%d\",\u0026n); for(int i = 0;i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } Quick_Sort(a, 0, n-1); for(int i = 0;i \u003c n; i++){ printf(\"%d \", a[i]); } return 0; } 高级短代码做法 一直选取做边界会超时 选择中值或者随机取值则不会超时。 while循环结束后$q[l…j]\u003c=x, q[j+1…r]\u003e=x$ j的取值范围为$l, r-1$，所以不会一直不划分边界 只能取大于或者小于号是因为交换原来的数字进行了限位，不会产生数组溢出的问题。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5 + 10; int a[N]; void Quick_Sort(int a[], int l, int r){ if(l \u003e= r) return; // 注意这里i,j都与开始值差一位 int x = a[l], i = l - 1, j = r + 1; // 循环结束后,a[l...j] \u003c= x, a[j+1...r] \u003e= x while(i \u003c j){ // 这里不能用等号，是因为交换让目标值做限位的作用 while(a[++i] \u003c x); while(a[--j] \u003e x); if(i \u003c j) swap(a[i], a[j]); } cout \u003c\u003cl \u003c\u003c ' '\u003c\u003c r \u003c\u003c ' ' \u003c\u003c j \u003c\u003c ' ' \u003c\u003c endl; // j取值范围时[l, r-1]不存在0和n区间无限循环 // j最小值大于等于l Quick_Sort(a, l, j); Quick_Sort(a, j+1, r); } int main(){ int n; scanf(\"%d\",\u0026n); for(int i = 0;i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } Quick_Sort(a, 0, n-1); for(int i = 0;i \u003c n; i++){ printf(\"%d \", a[i]); } return 0; } 快慢指针版本，数据量较大时候，由于多次交换，会超时。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5 + 10; int a[N]; void Quick_Sort(int a[], int l, int r){ // 快慢指针版本 if(l \u003e= r) return; swap(a[l], a[l + r \u003e\u003e 1]); int x = a[l], i = l; for(int j = l+1; j \u003c= r; j++){ if(a[j] \u003c= x){ swap(a[j], a[++i]); } } swap(a[i], a[l]); Quick_Sort(a, l, i-1); Quick_Sort(a, i+1, r); } int main(){ int n; scanf(\"%d\",\u0026n); for(int i = 0;i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } Quick_Sort(a, 0, n-1); for(int i = 0;i \u003c n; i++){ printf(\"%d \", a[i]); } return 0; } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:3","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"786. 第k个小的数 排序 $T:O(nlogn), S:O(logn)$ 大顶堆 $T:O(nlogk),S:O(k)$，结果有序 快速选择 平均复杂度：$T:O(n),S:O(logn)$ 最坏复杂度：$T:O(n^2),S:O(n)$ 快慢指针的快速选择切分 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cstdlib.h\u003e using namespace std; const int N = 1e5+10; int a[N]; int Quick_Select(int a[], int l, int r, int k){ if(l \u003e= r) return a[l]; // 添加随机性 int rand_idx = rand() % (r - l + 1) + l; swap(a[rand_idx], a[l]); int x = a[l], i = l, j = r + 1; while(i \u003c j){ while(a[++i] \u003c x){ if(i \u003e= r) break; } while(a[--j] \u003e x){ if(j \u003c= l) break; } if(i \u003c j) swap(a[i], a[j]); } swap(a[l], a[j]); if(j - l + 1 == k) return a[j]; else if(j - l + 1 \u003e k) return Quick_Select(a, l, j - 1, k); else return Quick_Select(a, j + 1, r, k - (j - l + 1)); } int main(){ int n, k; cin \u003e\u003e n \u003e\u003e k; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } int l = 0, r = n - 1; cout \u003c\u003c Quick_Select(a, l, r, k) \u003c\u003c endl; return 0; } 高级基于快速排序的快速选择。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int a[N]; int Quick_Sort(int a[], int l, int r, int k){ if(l \u003e= r) return a[l]; int x = a[l], i = l - 1, j = r + 1; while(i \u003c j){ while(a[++i] \u003c x); while(a[--j] \u003e x); if(i \u003c j) swap(a[i], a[j]); } if(j - l + 1 \u003e= k) Quick_Sort(a, l, j, k); else Quick_Sort(a, j+1, r, k - (j - l + 1)); } int main(){ int n, k; cin \u003e\u003e n \u003e\u003e k; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } cout \u003c\u003c Quick_Sort(a, 0, n-1, k); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:3:4","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"归并排序 本质：将两个排序好的队列进行合并的过程。 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:0","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"步骤 确定分界点。 递归划分区间。 双执政归并合并两个有序序列。 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:1","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"复杂度分析 $T:O(nlogn)$ $S:O(n)$，辅助数组进行赋值操作 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:2","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"787. 归并排序 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e6 + 10; int a[N]; int temp[N]; void merge(int a[], int l, int mid, int r){ int i = l, j = mid+1, cur = 0; while(i \u003c= mid \u0026\u0026 j \u003c= r){ if(a[i] \u003c= a[j]){ temp[cur++] = a[i++]; }else{ temp[cur++] = a[j++]; } } while(i \u003c= mid) temp[cur++] = a[i++]; while(j \u003c= r) temp[cur++] = a[j++]; for(int i = l, j = 0; j \u003c cur; i++, j++){ a[i] = temp[j]; } } void merge_sort(int a[], int l, int r){ if(l \u003e= r) return; int mid = l + r \u003e\u003e 1; merge_sort(a, l, mid); merge_sort(a, mid+1, r); merge(a, l, mid, r); } int main(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } merge_sort(a, 0, n-1); for(int i = 0; i \u003c n; i++){ printf(\"%d \", a[i]); } } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:3","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"788. 逆序对的数量 ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:4","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"归并思想 i 前面的数均小于j $T:O(nlogn)$ $S:O(n)$ #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; typedef long long LL; const int N = 1e5+10; int a[N]; int temp[N]; LL merge_reverse_num(int a[], int l, int r){ if(l \u003e= r) return 0; int mid = l + r \u003e\u003e 1; LL res = merge_reverse_num(a, l, mid) + merge_reverse_num(a, mid+1, r); int i = l, j = mid + 1, cur = 0; while(i \u003c= mid \u0026\u0026 j \u003c= r){ if(a[i] \u003c= a[j]){ temp[cur++] = a[i++]; }else{ // a[i] \u003e a[j] -\u003e + mid - i + 1 res += mid - i + 1; temp[cur++] = a[j++]; } } while(i \u003c= mid) temp[cur++] = a[i++]; while(j \u003c= r) temp[cur++] = a[j++]; for(int i = l, j = 0; j \u003c cur; i++, j++){ a[i] = temp[j]; } return res; } int main(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } printf(\"%ld\", merge_reverse_num(a, 0, n-1)); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:5","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"暴力(LTE) #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; typedef long long LL; const int N = 1e5+10; int a[N]; int main(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); } LL res = 0; for(int i = 0; i \u003c n; i++){ for(int j = i+1; j \u003c n; j++){ if(a[i] \u003e a[j]) res += 1; } } printf(\"%ld\", res); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:4:6","tags":["算法基础课","leetcode","算法","排序"],"title":"acwing基础课ch1-排序问题","uri":"/ch1_%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"高精度运算 ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:0:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"数据存储 利用数组倒序存储大的数据，进位在最后一位添加一个数十分方便。 ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:1:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"高精度加法 模拟加法进位 字符串输入，取反存入数组中 计算返回数组倒序输出。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cstring\u003e using namespace std; vector\u003cint\u003e add(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B){ vector\u003cint\u003e res; int up = 0; for(int i = 0; i \u003c A.size() || i \u003c B.size() || up; i++){ if(i \u003c A.size()) up += A[i]; if(i \u003c B.size()) up += B[i]; res.push_back(up % 10); up = up / 10; } return res; } int main(){ string a, b; vector\u003cint\u003e A, B; cin \u003e\u003e a \u003e\u003e b; // 注意这里的字符串转换 for(int i = a.size() - 1; i \u003e= 0; i--) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i \u003e= 0; i--) B.push_back(b[i] - '0'); vector\u003cint\u003e C = add(A, B); for(int i = C.size() - 1; i \u003e= 0; i--) printf(\"%d\", C[i]); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:2:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"高精度减法 保证A\u003e=B $A-B(A\u003e=B)$，$-(B-A)(A\u003cB)$ 注意减法会有前导零，要删除前导零 关键点有两个：如何判断两个数大小和如何进行模拟减法。 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; bool cmp(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B){ if(A.size() != B.size()) return A.size() \u003e B.size(); else{ for(int i = A.size() - 1;i \u003e= 0; i--){ if(A[i] != B[i]) return A[i] \u003e B[i]; } } return true; } vector\u003cint\u003e sub(vector\u003cint\u003e\u0026 A, vector\u003cint\u003e\u0026 B){ vector\u003cint\u003e res; int help = 0; for(int i = 0; i \u003c A.size(); i++){ help += A[i]; if(i \u003c B.size()) help -= B[i]; if(help \u003e= 0){ res.push_back(help); help = 0; }else{ res.push_back(help + 10); help = -1; } } while(res.size() \u003e 1 \u0026\u0026 res.back() == 0) res.pop_back(); return res; } int main(){ string a, b; vector\u003cint\u003e A, B, C; cin \u003e\u003e a \u003e\u003e b; for(int i = a.size() - 1;i \u003e= 0; i--) A.push_back(a[i] - '0'); for(int i = b.size() - 1;i \u003e= 0; i--) B.push_back(b[i] - '0'); if(cmp(A, B)){ C = sub(A, B); }else{ C = sub(B, A); printf(\"-\"); } for(int i = C.size() - 1; i \u003e= 0; i--) printf(\"%d\", C[i]); } ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:3:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"高精度乘法 每一项乘乘数，每次处理结果的最后一位，其余作为进位。 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; vector\u003cint\u003e mul(vector\u003cint\u003e\u0026 A, int b){ vector\u003cint\u003e res; int t = 0; for(int i = 0; i \u003c A.size(); i++){ t += A[i] * b; // 添加个位 res.push_back(t % 10); // 进位 t /= 10; } // 处理多余的进位 while(t){ res.push_back(t % 10); t /= 10; } // 去除前导0 while(res.size() \u003e 1 \u0026\u0026 res.back() == 0) res.pop_back(); return res; } int main(){ string a; int b; cin \u003e\u003e a \u003e\u003e b; vector\u003cint\u003e A, C; for(int i = a.size() - 1; i \u003e= 0; i--) A.push_back(a[i] - '0'); C = mul(A, b); for(int i = C.size() - 1; i \u003e= 0; i--) printf(\"%d\", C[i]); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:4:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"高精度除法 除法是正着计算的，其余都是按照逆运算进行进位的。 商的位数小于等于被除数的位数。 上次除的余数*10 / 除数 就是该位的结果，之后更新除数即可。 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e using namespace std; // 商的位数小于等于被除数的位数。 // 模拟除法 // 上次除的余数*10 / 除数 就是该位的结果 // 之后更新除数即可。 // A/b = C ... k vector\u003cint\u003e div(vector\u003cint\u003e\u0026 A, int b, int\u0026 k){ vector\u003cint\u003e res(A.size()); for(int i = A.size() - 1; i \u003e= 0; i--){ k = k * 10 + A[i]; res[i] = k / b; k = k % b; } while(res.size() \u003e 1 \u0026\u0026 res.back() == 0) res.pop_back(); return res; } int main(){ string a; int b, k = 0; vector\u003cint\u003e A, C; cin \u003e\u003e a \u003e\u003e b; for(int i = a.size() - 1; i \u003e= 0; i--) A.push_back(a[i] - '0'); C = div(A, b, k); for(int i = C.size() - 1; i \u003e= 0; i--) printf(\"%d\", C[i]); printf(\"\\n%d\", k); return 0; } ","date":"2021-08-24","objectID":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/:5:0","tags":["算法基础课","leetcode","算法","高精度运算"],"title":"acwing基础课ch1-高精度运算","uri":"/ch1_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"categories":["算法基础课"],"content":"哈希表 将一个复杂的数据结构进行映射。 (key-value)pair的关系。 ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:1:0","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"哈希表基本元素 key-value映射 哈希函数 哈希冲突解决方法 ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:1:1","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"哈希函数 一般取模(x%MOD) MOD是大于数据规模的最小质数 ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:1:2","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"哈希冲突 不同的key通过哈希函数后产生了相同的value（映射）。 拉链法 产生了冲突之后，将产生哈希冲突的值用链表的方式存储在相应的idx之后 插入：在哈希值的链表上插入一个值。 查找：找到哈希值，在哈希值对应的链上查找。 删除：删除链表的一个节点 #include \u003ciostream\u003e const int N = 1e5+10; using namespace std; struct Listnode{ int val; Listnode* next; Listnode(int x = 0, Listnode* ne = nullptr):val(x), next(ne) {} }; // 哈希值 Listnode* h[N] = {nullptr}; void insert(int x){ // 负数情况 int t = (x % N + N) % N; Listnode* add = new Listnode(x, nullptr); if(h[t] == nullptr){ h[t] = add; }else{ add -\u003e next = h[t] -\u003e next; h[t] -\u003e next = add; } } bool find(int x){ int t = (x % N + N) % N; Listnode* root = h[t]; while(root != nullptr){ if(root -\u003e val == x){ return true; } root = root -\u003e next; } return false; } int main(){ int n; cin \u003e\u003e n; while(n--) { char op; int x; cin \u003e\u003e op \u003e\u003e x; if(op == 'I'){ insert(x); }else{ if(find(x)) cout \u003c\u003c \"Yes\" \u003c\u003c endl; else cout \u003c\u003c \"No\" \u003c\u003c endl; } } return 0; } 开放寻址法 产生了冲突之后，向后查找直到找到一个位置value没有任何key存在在这个位置 添加： 查找：计算哈希值，查找哈希序列，如果遇到目标值，返回该目标值的下标。否则继续查找到一个合适位置。 删除：打一个特殊标记，不需要真的删除 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e using namespace std; const int N = 2e5+3; const int null = 0; int h[N], n; // 开放寻址法 int find(int x){ // 负数取余数仍是负数 // 处理负数的情况 int t = (x % N + N) % N; // 直到遇到空的节点，结束搜素 while(h[t] != null){ // 如果找到目标值返回目标值的索引 if(h[t] == x){ break; } t ++; if(t == N - 1){ t = 1; } } // 如果没找到目标值，返回它应该在的位置 return t; } int main(){ cin \u003e\u003e n; while(n-- ){ char op; int x; cin \u003e\u003e op \u003e\u003e x; int t = find(x); if(op == 'I'){ h[t] = x; }else{ if(h[t] == x) cout \u003c\u003c \"Yes\" \u003c\u003c endl; else cout \u003c\u003c \"No\" \u003c\u003c endl; } } return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:1:3","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"字符串哈希 ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:2:0","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"字符串前缀哈希法 将字符串转换为一个k进制的数。 然后将这个数取余数可以得到这个字符串的哈希值 注意不能有字母映射为0，对P，Q取经验值时不会存在哈希冲突。 首先求出一个字符串所有前缀的哈希值 然后可以根据前缀的哈希值就可以在$O(1)$时间内求出任一子串的哈希值 $h[l, r] = h[r] - h[l-1] * p ^{(r - l + 1)}$ ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:2:1","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"字符串哈希 处理多次询问子串是否相同的情况 #include \u003ciostream\u003e using namespace std; typedef unsigned long long ull; const int N = 1e5+10, P = 131; ull h[N], p[N]; // 返回前缀和 ull find(int l, int r){ return h[r] - h[l - 1] * p[r - l + 1]; } int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; string s; cin \u003e\u003e s; p[0] = 1; // 计算前缀 for(int i = 1; i \u003c= n; i++){ p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + s[i - 1]; } while(m-- ){ int l1, r1, l2, r2; cin \u003e\u003e l1 \u003e\u003e r1 \u003e\u003e l2 \u003e\u003e r2; if(find(l1, r1) == find(l2, r2)) cout \u003c\u003c \"Yes\" \u003c\u003c endl; else cout \u003c\u003c \"No\" \u003c\u003c endl; } } ","date":"2021-08-24","objectID":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/:2:2","tags":["算法基础课","leetcode","算法","哈希表"],"title":"acwing基础课ch2-哈希表","uri":"/ch2_%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["算法基础课"],"content":"堆/优先队列 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:0","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"堆是什么 堆是一颗完全二叉树。 大顶堆：父亲结点的值大于左右子树的结点。 小顶堆：父亲结点的值小于左右子树的结点。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:1","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"堆的操作与优点 优点 O(1)时间内找出最大或最小的数 添加或者删除一个数需要O(logn)的时间复杂度 支持操作-最小堆 向上调整：把欲调整节点与其父亲节点比较，直到其小于父亲节点。 向下调整：将当前结点与左右孩子比较，直到其比左右儿子都小。 存储方式 使用一维数组进行存储，1号点为根节点，同时使用一个变量记录节点的总数。 使用数组静态表示堆$heap[i]$从1开始，该节点左孩子为$heap[2i]$,该节点右孩子为$heap[2i+1]$。 因为堆为完全二叉树，所以数组肯定可以放满。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:2","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"建立堆 先将堆初始化（数组初始化）。 从n/2到1向下调整每一个数。 时间复杂度$O(n)$，而通过插入每一个元素建立堆的时间复杂度是$O(nlogn)$ ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:3","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"向堆中插入一个数 将欲添加元素添加至堆的最后。 将该元素向上调整至合适的位置。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:4","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"求堆顶元素 返回第一个元素即可 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:5","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"删除堆顶元素 把最后一个元素覆盖堆顶元素 删除最后一个元素，缩小数据规模 之后将第一个元素向下调整 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:6","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"删除任意一个元素 将第k个元素与最后一个元素交换 之后删除最后一个元素 然后再将第k个元素分别向上/向下调整（因为不知道交换之后的元素具体位置）。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:7","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"修改任意一个元素 修改第k个元素 然后将第k个元素分别向上/向下调整。 ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:1:8","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"堆排序 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; int h[N], cnt, n, m; void down(int idx){ int t = idx; if(idx * 2 \u003c= cnt \u0026\u0026 h[idx * 2] \u003c h[t]) t = idx * 2; if(idx * 2 + 1 \u003c= cnt \u0026\u0026 h[idx * 2 + 1] \u003c h[t]) t = idx * 2 + 1; swap(h[t], h[idx]); if(t != idx){ down(t); } } void up(int idx){ int t = idx; if(idx / 2 \u003e 0 \u0026\u0026 h[idx / 2] \u003e h[t]) t = idx / 2; swap(h[t], h[idx]); if(t != idx){ up(t) } } int popTop(){ int ret = h[1]; swap(h[cnt], h[1]); cnt--; down(1); return ret; } // 建堆过程，向下调整 // 时间复杂度O(n) void creatHeap(){ cnt = n; for(int i = n / 2; i \u003e= 1; i--){ down(i); } } int main(){ cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e h[i]; creatHeap(); for(int i = 1; i \u003c= m; i++){ cout \u003c\u003c popTop() \u003c\u003c ' '; } return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%A0%86/:2:0","tags":["算法基础课","leetcode","算法","堆"],"title":"acwing基础课ch2-堆","uri":"/ch2_%E5%A0%86/"},{"categories":["算法基础课"],"content":"字典树 ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:1:0","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"作用 高效地存储与查找字符串。(O(logn)的时间复杂度进行查找) 支持两种操作：插入一个字符串(insert) 查找是否存在一个字符串(qury) 一个关键点：字典树是通过边存储字符串的。 静态实现 #include \u003ciostream\u003e using namespace std; const int N = 1e5+10; // 最多有N*26个节点 int son[N][26], cnt[N], idx; char str[N], op[2]; // 插入一个字符串 void insert(char str[]){ int p = 0; for(int i = 0; str[i]; i++){ int u = str[i] - 'a'; if(!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p]++ ; } // 查询一个字符串，并且返回该字符串出现的次数。 int query(char str[]){ int p = 0; for(int i = 0; str[i]; i++){ int u = str[i] - 'a'; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main(){ int n; scanf(\"%d\", \u0026n); while(n-- ){ scanf(\"%s%s\", \u0026op, \u0026str); if(op[0] == 'I'){ insert(str); }else{ printf(\"%d\\n\", query(str)); } } return 0; } OOP实现 无内存管理，存在内存泄漏 #include \u003ciostream\u003e using namespace std; class Trie{ private: int cnt = 0; Trie* next[26] = {nullptr}; public: Trie(){} void insert(string\u0026 s){ Trie* root = this; for(int i = 0; i \u003c s.size(); i++){ int x = s[i] - 'a'; if(root -\u003e next[x] == nullptr) root -\u003e next[x] = new Trie(); root = root -\u003e next[x]; } root -\u003e cnt += 1; } int qury(string\u0026 s){ Trie* root = this; for(int i = 0; i \u003c s.size(); i++){ int x = s[i] - 'a'; if(root -\u003e next[x] == nullptr) return 0; root = root -\u003e next[x]; } return root-\u003ecnt; } }; int main(){ int n; cin \u003e\u003e n; Trie* root = new Trie(); while(n--){ char op; string s; cin \u003e\u003e op \u003e\u003e s; if(op == 'I'){ root -\u003e insert(s); }else{ cout \u003c\u003c root -\u003e qury(s) \u003c\u003c endl; } } return 0; } 内存管理-\u003e析构函数 #include \u003ciostream\u003e using namespace std; class TrieNode{ public: int cnt = 0; TrieNode* ne[26] = {nullptr}; }; class Trie{ private: TrieNode* root; void delRoot(TrieNode* root){ if(root == nullptr){ return; } for(int i = 0; i \u003c 26; i++){ delRoot(root -\u003e ne[i]); } delete root; } public: Trie(){ root = new TrieNode(); } void insert(string s){ TrieNode* t = root; for(int i = 0; i \u003c s.size(); i++){ int x = s[i] - 'a'; if(t -\u003e ne[x] == nullptr) t -\u003e ne[x] = new TrieNode(); t = t -\u003e ne[x]; } t -\u003e cnt += 1; } int qury(string s){ TrieNode* t = root; for(int i = 0; i \u003c s.size(); i++){ int x = s[i] - 'a'; if(t -\u003e ne[x] == nullptr) return 0; t = t -\u003e ne[x]; } return t -\u003e cnt; } ~Trie(){ delRoot(root); } }; int main(){ int n; cin \u003e\u003e n; Trie myTrie; while(n--){ char op; string s; cin \u003e\u003e op \u003e\u003e s; if(op == 'I'){ myTrie.insert(s); }else{ cout \u003c\u003c myTrie.qury(s) \u003c\u003c endl; } } return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:1:1","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"最大异或对 ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:2:0","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"题目描述 找出一个数组中异或最大的两个数。 ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:2:1","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"暴力 枚举所有的数的组合，分别计算异或值$O(n^2)$ ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:2:2","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"字典树 首先建立每个数的二进制字典树 之后查询字典树，对于每一位优先选择相反的位以获得该位最大的收益。 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 1e5+10; // 每个数有31位，所以有31*n个节点 int son[N * 31][2], a[N], index = 0; void insert(int x){ int p = 0; //根节点 // 倒序，最高位靠近根节点。 for(int i = 30; i \u003e= 0; i--){ int u = x \u003e\u003e i \u0026 1; if(!son[p][u]) son[p][u] = ++index; p = son[p][u]; } } int qury(int x){ int p = 0, res = 0; for(int i = 30; i \u003e= 0; i--){ int u = x \u003e\u003e i \u0026 1; if(son[p][!u]){ p = son[p][!u]; // 该位与查询数不同，异或值为1 res += 1 \u003c\u003c i; }else{ p = son[p][u]; } } return res; } int main(){ int n, res = 0; cin \u003e\u003e n; // 建立字典树 for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026a[i]); insert(a[i]); } // 对于每个数字，查询z for(int i = 0; i \u003c n; i++) res = max(res, qury(a[i])); cout \u003c\u003c res; return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/:3:0","tags":["算法基础课","leetcode","算法","字典树"],"title":"acwing基础课ch2-字典树","uri":"/ch2_%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["算法基础课"],"content":"字符串问题 ","date":"2021-08-24","objectID":"/ch2_string/:1:0","tags":["算法基础课","leetcode","算法","字符串"],"title":"acwing基础课ch2-字符串问题","uri":"/ch2_string/"},{"categories":["算法基础课"],"content":"字符串单模匹配 给你一个字符串haystack和needle，找出needle再haystack中第一个出现的位置。 如果needle未曾出现再haystack时，返回-1。 如果needle是空串，返回0 28. 实现 strStr() ","date":"2021-08-24","objectID":"/ch2_string/:1:1","tags":["算法基础课","leetcode","算法","字符串"],"title":"acwing基础课ch2-字符串问题","uri":"/ch2_string/"},{"categories":["算法基础课"],"content":"暴力算法 枚举haystack中的每个字串 $T:O(m*n)$ ssssssclass Solution { public: int strStr(string haystack, string needle) { if(needle == \"\"){ return 0; } if(haystack.size() \u003c needle.size()){ return -1; } for(int i = 0; i \u003c haystack.size(); i++){ bool flag = true; for(int j = 0;j \u003c needle.size(); j++){ if(haystack[i+j] != needle[j]){ flag = false; break; } } if(flag){ return i; } } return -1; } }; ","date":"2021-08-24","objectID":"/ch2_string/:1:2","tags":["算法基础课","leetcode","算法","字符串"],"title":"acwing基础课ch2-字符串问题","uri":"/ch2_string/"},{"categories":["算法基础课"],"content":"KMP算法 s[n]为目标串，p[n]为模式串 next[i] = j 以i-1为结尾的字符串与前缀匹配的最长的长度为j（p[1,j]和p[i-j, i-1]匹配） 图中的j是模式串的位置，如果第i个数匹配不成功，向后移动查看p[ne[j]+1]和s[i]是否能匹配成功。 如何计算next数组-\u003e类似的思想，如果不匹配，向后移动ne[j]个字符。 匹配成功j = ne[j]向后移动继续匹配下一个串 理解j=ne[j]是向后移动：j是已经匹配了的字符串的长度，继续匹配第j+1个字符 ne数组：ne[i]:与下标i结尾的后缀相同的前缀的长度，取值范围为$0-\u003ei-1$，前缀的长度小于当前子串长度 $T:O(2*m+n)$，$j$在while(j \u0026\u0026 p[i] != p[j + 1])​中最多减$m$次，而$j$在for循环中最多加$m$次。 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003calgorithm\u003e #define N 1000001 char s[N], p[N]; int n, m; int ne[N]; using namespace std; int main(){ // 从第1个字符开始 cin \u003e\u003e n \u003e\u003e p + 1 \u003e\u003e m \u003e\u003e s + 1; // ne[1] = 0,因为第一个不匹配时 // 都可以让目标串向后移动一位 // 求ne数组：ne[i]:与下标i结尾的后缀相同的前缀的长度 for(int i = 2, j = 0; i \u003c= n; i++){ while(j \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j += 1; ne[i] = j; } // 查看next数组 j = 0,意味着从零开始匹配，ne[0]无意义。 // for(int i = 0; i \u003c= n; i++){ // cout \u003c\u003c ne[i] \u003c\u003c ' ' ; // } // cout \u003c\u003c endl; // KMP匹配 // i表示开始匹配的目标串的下标 // j表示匹配的长度 for(int i = 1, j = 0; i \u003c= m; i++){ while(j \u0026\u0026 s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j += 1; if(j == n){ // 计数从1开始所以不用减去1 cout \u003c\u003c i - n \u003c\u003c ' '; // 一定要是ne[j]不能是把整个字符串右移。 j = ne[j]; } } // cout \u003c\u003c ne[n+1]; return 0; } ","date":"2021-08-24","objectID":"/ch2_string/:1:3","tags":["算法基础课","leetcode","算法","字符串"],"title":"acwing基础课ch2-字符串问题","uri":"/ch2_string/"},{"categories":["算法基础课"],"content":"并查集 ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:0","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"并查集是什么 Union,Find,Set 并查集包含Union,Find,Set3个关键词，是一种维护集合的基本操作。 并查集是一种用树表示的集合，树根的编号表示集合的编号。 ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:1","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"并查集实现的方法 并查集由两个任务： 合并：合并两个集合。 查找：判断两个元素是否在一个集合内。 实现：数组实现，索引表示结点编号，数组的值表示索引的根节点。 同一个集合中只能包含一个根节点(father[i] = i)。 查找父节点 int findFather(int x, int father[]){ while(x != father[x]){ x = father[x]; } return x; } 合并结点 一定要使用根节点进行合并。 查找它们的根节点，如果他们根节点不同，则属于不同的集合才可以进行合并。 void Union(int a, int b, int fa[]){ fa[find(a)] = find(b); } 路径压缩 把当前查询结点的路径上所有节点的父亲都指向根节点。 int find(int x, int fa[]){ if(x != far[x]) fa[x] = find(fa[x]); return fa[x]; } ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:2","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"写法 静态 int fa[N]; // 初始化 for(int i = 1; i \u003c= n; i++){ fa[i] = i; } // find int find(int x){ if(x = fa[x]) return x; f[x] = find(f[x]); return f[x]; } // 合并 void Union(int x){ fa[find(x)] = find(y); } // 查询 int qury(int x, int y){ return find(y) == find(y); } OOP class findUnionSet{ private: vector\u003cint\u003e f; public: findUnionSet(int n = N){ f = vector\u003cint\u003e(n + 1, 0); for(int i = 1; i \u003c= n; i++){ f[i] = i; } } int find(int x) { if(x == f[x]) return x; f[x] = find(f[x]); return f[] } void un(int x, int y) { f[find(x)] = find(y); } bool qury(int x, int y) { return find(x) == find(y); } }; ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:3","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"Ac836.合并集合 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; const int N = 1e5+10; class findUnionSet{ private: vector\u003cint\u003e f; public: findUnionSet(int n = N){ f = vector\u003cint\u003e(n + 1, 0); for(int i = 1; i \u003c= n; i++){ f[i] = i; } } int find(int x) { if(x != f[x]) f[x] = find(f[x]); return f[x]; } void un(int x, int y) { f[find(x)] = find(y); } bool qury(int x, int y) { return find(x) == find(y); } }; int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; findUnionSet myun; while(m--){ char op; int x, y; cin \u003e\u003e op \u003e\u003e x \u003e\u003e y; if(op == 'M'){ myun.un(x, y); } else{ if(myun.qury(x, y)) cout \u003c\u003c \"Yes\" \u003c\u003c endl; else cout \u003c\u003c \"No\" \u003c\u003c endl; } } return 0; } ","date":"2021-08-24","objectID":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:0","tags":["算法基础课","leetcode","算法","并查集"],"title":"acwing基础课ch2-并查集","uri":"/ch2_%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["算法基础课"],"content":"图基础 ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:1:0","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"有向图 节点之间存在方向 存储方法 邻接矩阵：二维数组。 邻接表：n个单链表，类似于哈希表的拉链法。 邻接表存储模板 // 邻接表 int h[N], e[N * 2], ne[N * 2], idx; // add a -\u003e b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:1:1","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"树与图的深度优先搜索 有向图DFS模板 // 需要标记数组st[N], 遍历节点的每个相邻的边 void dfs(int u) { st[u] = true; // 标记，j for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { dfs(j); } } } 树的重心 后序遍历 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; const int N = 1e5+10; // h表示每个节点的链表头节点，e表示使用的下标为idx的节点的值 // ne表示下标为idx的节点的下一个节点，idx表示当前使用的节点个数。 // 注意所有节点的链表节点头要初始化为-1 int h[N], e[N*2], ne[N*2], idx; bool vis[N]; int n, ans = N; // 有向图邻接表 // a-\u003eb插入一个节点 void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } // 相当于是后序遍历，dfs返回每个子树节点的个数。 int dfs(int u){ vis[u] = true; int num = 1, res = 0; for(int i = h[u]; i != -1; i = ne[i]){ int j = e[i]; if(!vis[j]){ vis[j] = true; int t = dfs(j); res = max(res, t); num += t; } } // n-num为树上半部分的节点数 res = max(res, n - num); ans = min(res, ans); return num; } int main(){ memset(h, -1, sizeof(h)); cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ int a, b; cin \u003e\u003e a \u003e\u003e b; // 无向图 add(a, b), add(b, a); } dfs(1); cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:1:2","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"树与图的宽度优先搜索 解决权重相同的最短路问题 使用队列进行宽度优先搜索 queue \u003c- head while(queue){ t \u003c- queue head 标记t已经访问 拓展t } 图中点的层次 相同权重的最短路问题 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e using namespace std; const int N = 1e5+10; int h[N], e[N], ne[N], idx; // d表示每个节点到1节点的距离。 int d[N]; int n, m; void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int bfs(int x){ queue\u003cint\u003e que; que.push(x); memset(d, -1, sizeof(d)); d[x] = 0; while(!que.empty()){ int t = que.front(); que.pop(); for(int i = h[t]; i != -1; i = ne[i]){ int j = e[i]; if(d[j] == -1){ d[j] = d[t] + 1; que.push(j); } } } return d[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(h, -1, sizeof(h)); while(m--){ int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b); } cout \u003c\u003c bfs(1) \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:1:3","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"拓扑排序 有向图 宽度优先搜索的应用。 起点在其对应的终点前面。 有向无环图一定存在拓扑序列，也称为拓扑图。 步骤 所有入度为0的点入队 依次出队，删除入度为0的点，修改该点的邻接点的入度数 如果邻接点的入度数为0，将该邻接点入队。 ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:2:0","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"有向图的拓扑序列 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cqueue\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int N = 1e5+10; int h[N], e[N*2], ne[N*2], idx; // d存储每个节点的入度个数。 int d[N]; int n, m; void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; d[b] += 1; } bool topsort(vector\u003cint\u003e\u0026 res){ queue\u003cint\u003e que; for(int i = 1; i \u003c= n; i++){ if(d[i] == 0){ que.push(i); } } int in_que = 0; while(!que.empty()){ int t = que.front(); // 出队顺序就是拓扑排序的顺序 res.push_back(t); que.pop(); in_que += 1; for(int i = h[t]; i != -1; i = ne[i]){ int j = e[i]; d[j] -= 1; if(d[j] == 0){ que.push(j); } } } return in_que == n; } int main(){ memset(h, -1, sizeof(h)); cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c m; i++){ int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b); } vector\u003cint\u003e res; if(topsort(res)){ for(int i = 0; i \u003c res.size(); i++){ cout \u003c\u003c res[i] \u003c\u003c ' '; } cout \u003c\u003c endl; }else{ cout \u003c\u003c -1 \u003c\u003c endl; } return 0; } ","date":"2021-08-24","objectID":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:2:1","tags":["算法基础课","leetcode","算法","图"],"title":"acwing基础课ch3-图基础与拓扑排序","uri":"/ch3_%E5%9B%BE%E5%9F%BA%E7%A1%80_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["算法基础课"],"content":"搜索算法 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:1:0","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"DFS与BFS DFS: stack， $O(h)$，h指的是深度 BFS： queue, $O(2^h)$，具有最短路的性质 DFS可以使用递归树进行理清思路 剪枝：直接判断当前状态不合法，直接不继续向下搜索。 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:2:0","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"DFS习题 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:3:0","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"全排列（无重复数字） 回溯搜索 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 10; int a[N], vis[N], path[N]; // c表示当前路径上的个数 void dfs(int n, int c){ // 递归终止条件 if(c \u003e= n){ for(int i = 0; i \u003c n; i++ ) cout \u003c\u003c path[i] \u003c\u003c ' '; cout \u003c\u003c endl; return; } for(int i = 0; i \u003c n; i++){ if(vis[i] == 0){ // 递归 vis[i] = 1; path[c] = a[i]; dfs(n, c + 1); // 回溯 vis[i] = 0; } } } int main(){ int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ a[i] = i + 1; } dfs(n, 0); return 0; } 使用next_permutation() #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 10; int a[N]; int main(){ int n; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++){ a[i] = i; } do{ for(int i = 1; i \u003c= n; i++){ cout \u003c\u003c a[i] \u003c\u003c ' '; } cout \u003c\u003c endl; }while(next_permutation(a+1, a+1+n)); return 0; } ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:3:1","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"子集问题 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:3:2","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"八皇后问题 相同行，列，对角线不能存在皇后 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 10; char g[N][N]; int n; int dx[] = {-1, -1, -1, 1, 1, 1}, dy[] = {-1, 0, 1, -1, 0, 1}; // 检查每行每列是否满足要求 bool check(int x, int y){ for(int i = 0; i \u003c 6; i++){ int x1 = x + dx[i], y1 = y + dy[i]; while(x1 \u003e= 0 \u0026\u0026 x1 \u003c n \u0026\u0026 y1 \u003e= 0 \u0026\u0026 y1 \u003c n){ if(g[x1][y1] == 'Q') return false; x1 = x1 + dx[i], y1 = y1 + dy[i]; } } return true; } void dfs(int cur){ if(cur \u003e= n){ for(int i = 0; i \u003c n; i++) cout \u003c\u003c g[i] \u003c\u003c endl; cout \u003c\u003c endl; return; } for(int i = 0; i \u003c n; i++){ if(check(cur, i)){ g[cur][i] = 'Q'; dfs(cur+1); g[cur][i] = '.'; } } } int main(){ cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c n; j++){ g[i][j] = '.'; } } dfs(0); return 0; } ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:3:3","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"BFS习题 宽度优先搜索最大的优势就是最短路径，所有的路径权重都是1的情况。 队列 ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:4:0","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"AC844. 走迷宫 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cqueue\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 100; // a存储整个地图，vis存储每个节点到原点的距离。 int a[N][N]; int vis[N][N]; int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1}; int main(){ int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c m; j++){ scanf(\"%d\", \u0026a[i][j]); } } queue\u003cPII\u003e que; que.push({0, 0}); while(!que.empty()){ // 队头元素 auto f = que.front(); que.pop(); int row = f.first, col = f.second; if(row == n - 1 \u0026\u0026 col == m - 1){ cout \u003c\u003c vis[row][col] \u003c\u003c endl; break; } // 队头元素进行拓展 for(int i = 0; i \u003c 4; i++){ int x =row + dx[i], y = col + dy[i]; if(x \u003e= 0 \u0026\u0026 x \u003c n \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c m){ if(vis[x][y] == 0 \u0026\u0026 a[x][y] == 0){ que.push({x, y}); vis[x][y] = vis[row][col] + 1; } } } } return 0; } ","date":"2021-08-24","objectID":"/ch3_bfs_dfs/:4:1","tags":["算法基础课","leetcode","算法","搜索算法"],"title":"acwing基础课ch3-搜索算法","uri":"/ch3_bfs_dfs/"},{"categories":["算法基础课"],"content":"最小生成树与二分图 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:1:0","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"最小生成树 生成树：包含所有节点的无环图。 最小生成树：权值和最小的生成树。 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:2:0","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"朴素Prim算法 $O(n^2)$ 初始化所有点的距离 遍历n个点，每次将一个点加入到最小生成树集合S 找到距离S最近的点，将其加入集合，并且用改点更新其他点的距离。 #include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 510, INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dis[N]; // dis表示点到集合的距离 bool st[N]; // st表示点是否在集合中 int prim(){ memset(dis, 0x3f, sizeof(dis)); int res = 0; for(int i = 0; i \u003c n; i++){ int t = -1; for(int j = 1; j \u003c= n; j++){ if(!st[j] \u0026\u0026 (t == -1 || dis[t] \u003e dis[j])){ t = j; } } // 无法继续更新，无最小生成树。 if(i \u0026\u0026 dis[t] == INF) return INF; // 第一个边不能加入最小生成树 if(i) res += dis[t]; st[t] = true; for(int j = 1;j \u003c= n; j++){ // 注意这里是到集合的最短距离 dis[j] = min(dis[j], g[t][j]); } } return res; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(g, 0x3f, sizeof(g)); while(m-- ){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if(t == INF) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c t \u003c\u003cendl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:2:1","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"Kruskal算法 $O(mlogm)$ 将所有边按照权重从小到大排序。 枚举每条边a,b权重为c 如果a，b不连通，将该条边加入最小生成树的集合当中 用并查集判断a，b是否在同一个连通块当中 #include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 2e5+10; int p[N], n, m; struct edge{ int a, b, w; bool operator\u003c(edge ne){ return w \u003c ne.w; } }Edge[N]; int find(int x){ // 路径压缩 if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main(){ cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c m; i++){ int a, b, w; cin \u003e\u003e a \u003e\u003e b \u003e\u003e w; Edge[i] = {a, b, w}; } // 1. 从小到大排序 sort(Edge, Edge + m); for(int i = 1; i \u003c= n; i++) p[i] = i; // 2.遍历所有的边 int res = 0, cnt = 0; for(int i = 0; i \u003c m; i++){ int a = Edge[i].a, b = Edge[i].b, w = Edge[i].w; a = find(a), b = find(b); // a, b不属于同一个集合，将其加入集合 if(a != b){ cnt += 1; res += w; p[a] = b; } } if(cnt != n - 1) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:2:2","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"二分图问题 二分图：将所有点分为两个集合，所有的边都在集合外部，集合内无边。 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:3:0","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"染色法判定二分图 如果一个点染色， 则所有与该点相连的点的颜色都可以确定。 二分图中当且仅当不含有奇数环(反证)。 判断染色是否有矛盾。 $O(n)$ #include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; const int N = 100010, M = 200010; int n, m; // 注意这里建图初始化为M条边 int h[M], e[M], ne[M], idx; int color[N]; void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } bool dfs(int x, int c){ color[x] = c; for(int i = h[x]; i != -1; i = ne[i]){ int j = e[i]; if(!color[j]){ // 如果没染色进行染色 if(!dfs(j, 3 - c)) return false; }else{ // 如果已经染色，判断染色是否冲突，是否有奇数环 if(color[j] == c) return false; } } return true; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(h, -1, sizeof(h)); while(m-- ){ int a, b; scanf(\"%d%d\", \u0026a, \u0026b); add(a, b); add(b, a); } bool flag = true; for(int i = 1; i \u003c= n; i++){ if(!color[i]){ if(dfs(i, 1) == false){ flag = false; break; } } } if(flag == false){ cout \u003c\u003c \"No\" \u003c\u003c endl; }else{ cout \u003c\u003c \"Yes\" \u003c\u003c endl; } return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:3:1","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"匈牙利算法 二分图的最大匹配 二分图的两个集合可以一一匹配的最大的边数。 $O(nm)$ #include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e using namespace std; const int N = 510, M = 100010; int n1, n2, m; int h[N], e[M], ne[M], idx; int match[N]; // match表示右边的点对应的左边的点 bool st[N]; // st表示对于某个左边的点而言，右边的点是否访问过 void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } bool find(int x){ for(int i = h[x]; i != -1; i = ne[i]){ int j = e[i]; if(!st[j]){ st[j] = true; // 如果未匹配，或者可以更改匹配 if(match[j] == 0 || find(match[j])){ match[j] = x; return true; } } } return false; } int main(){ cin \u003e\u003e n1 \u003e\u003e n2 \u003e\u003e m; memset(h, -1, sizeof h); while(m --){ int a, b; cin \u003e\u003e a \u003e\u003e b; add(a, b); } int cnt = 0; for(int i = 1; i \u003c= n1; i++){ // 每个点只访问一次 memset(st, false, sizeof st); if(find(i)) cnt += 1; } cout \u003c\u003c cnt \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/:3:2","tags":["算法基础课","leetcode","算法","最小生成树","二分图"],"title":"acwing基础课ch3-最小生成树_二分图","uri":"/ch3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["算法基础课"],"content":"最短路问题 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:1:0","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"单源最短路 从起点到其他所有点的最短距离。 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:2:0","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"所有边权都是正数 Dijkstra基于贪心 朴素Dijkstra $T:O(n^2)，n为点的数量，m为边的数量$，适合于稠密图 初始化dis数组，$dis[1]=0$,$dis[i]=inf$，S为已经确定最短路径的点集 迭代n次，每次确定一个点的最短路径。 找到不在S中距离源点最近的点t，并将t加入到S（$n^2$次） 用t更新其他点的距离:$dis \u003e dis[t] + dis(t-\u003ex)$（$m$次） #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; const int N = 510; const int INF = 0x3f3f3f3f; // 稠密图，使用邻接矩阵 int n, m; int g[N][N]; int dis[N]; // 从1到每个点的最短距离 bool st[N]; // 已经确定距离的点集 int dijkstra(){ // 1.初始化为INF memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; // 2.循环n次，每次确定一个点 for(int i = 0; i \u003c n; i++){ // 3.找到当前距离1最近的点 int t = -1; for(int j = 1; j \u003c= n; j++){ if(!st[j] \u0026\u0026 (t == -1 || dis[j] \u003c dis[t])){ t = j; } } // 将该点加入确定的点的集合 st[t] = true; // 4.更新其他点的距离 for(int j = 1; j \u003c= n; j++){ dis[j] = min(dis[j], dis[t] + g[t][j]); } } if(dis[n] == 0x3f3f3f3f) return -1; else return dis[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m; // 存在重边，重边只用保留长度最短的边 memset(g, 0x3f, sizeof(g)); while(m--){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; g[a][b] = min(g[a][b], c); } int t = dijkstra(); cout \u003c\u003c t \u003c\u003c endl; return 0; } 堆优化Dijkstra $T:O(mlogn)$适合于稀疏图 初始化dis数组，$dis[1]=0$,$dis[i]=inf$，S为已经确定最短路径的点集 迭代n次，每次确定一个点的最短路径，因为使用堆优化，所以每次确定最短路径时间为$logn$。 用堆找到不在S中距离源点最近的点t，并将t加入到S（$n$次） 用t更新其他点的距离:$dis \u003e dis[t] + dis(t-\u003ex)$（$mlogn$次，实际为$mlogm$,因为无法堆中无法更新指定点的距离，存在冗余）。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e#include \u003cvector\u003e using namespace std; typedef pair\u003cint, int\u003e PII; const int N = 1e6+10; int h[N], ne[N], e[N], w[N], idx; int n, m; int dis[N]; bool st[N]; void add(int a, int b, int c){ e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int dijkstra(){ // 1. 初始化 memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e\u003e heap; heap.push({dis[1], 1}); while(heap.size()){ // 2. 找到距离最短的点，并且标记 auto t = heap.top(); heap.pop(); int node = t.second, distance = t.first; // 已经访问过，这个为冗余边 if(st[node]) continue; st[node] = true; // 3. 用当前点更新其他点的距离。 for(int i = h[node]; i != -1; i = ne[i]){ int j = e[i]; if(dis[j] \u003e dis[node] + w[i]){ dis[j] = dis[node] + w[i]; heap.push({dis[j], j}); } } } if(dis[n] == 0x3f3f3f3f) return -1; else return dis[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(h, -1, sizeof(h)); while(m-- ){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); } int t = dijkstra(); cout \u003c\u003c t \u003c\u003c endl; return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:2:1","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"存在负边权 如果存在负权回路，最短路可能不存在。 Bellman-Ford 连续进行松弛，每次松弛时把每条边都更新一下，若在n次松弛后还能更新，则说明图中有负环。 $T:O(mn)$ 迭代k次（k的意义:路径长度为k的最短路径），注意把dis进行backup，防止更新过程对下一个产生影响。 遍历所有的边，对于a-\u003eb,w更新dis[b] = min(dis[b], backup[a] + w) 注意要对所有点的距离进行备份，防止在更新过程中收到影响。 bellman - ford算法擅长解决有边数限制的最短路问题 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; const int N = 510, M = 10100; int dis[N], backup[N], n, m, k; struct edge{ int a, b, w; edge(int x, int y, int z):a(x), b(y), w(z){}; edge(){}; }Edge[M]; int bellman_ford(){ // 初始化距离为无穷，并且要把1点的距离置为0 memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; // dis数组意义，迭代k次，路径长度为k的最短距离为dis for(int i = 0; i \u003c k; i++){ memcpy(backup, dis, sizeof(dis)); // 注意要备份 for(int j = 0; j \u003c m; j++){ int a = Edge[j].a, b = Edge[j].b, w = Edge[j].w; dis[b] = min(dis[b], backup[a] + w); } } if(dis[n] \u003e 0x3f3f3f3f / 2) return -1; else return dis[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for(int i = 0; i \u003c m; i++){ int a, b, w; cin \u003e\u003e a \u003e\u003e b \u003e\u003e w; Edge[i] = {a, b, w}; } int t = bellman_ford(); if(t == -1) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c t \u003c\u003c endl; return 0; } SPFA $T:O(m),最坏O(mn)$ SPFA不能存在负权回路 对bellman-ford算法的距离更新进行优化，当a进行更新时，b才会更新。 BFS进行优化，队列中存储距离变小的节点，队列中存储可以更新其他点的点。 当队列不为空，队头出队。 并且访问队头元素所有的边，如果目标点的距离可以被更新则将其加入到队列中。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e using namespace std; const int N = 1e5+10, M = 1e5+10; int dis[N], h[N], n, m; int e[M], ne[M], w[M], idx = 0; // st表示当前节点是否在队列中 // 如果当前节点在队列中，则不可以通过其他节点更新该点。 bool st[N]; void add(int a, int b, int c){ e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int spfa(){ // 1.初始化所有节点距离，将1节点入队 memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; queue\u003cint\u003e que; que.push(1); st[1] = true; // 2.队列不为空时，使用队头节点更新其他节点。 while(!que.empty()){ int t = que.front(); que.pop(); st[t] = false; // 该节点已经不再队列中 for(int i = h[t]; i != -1; i = ne[i]){ int node = e[i], distance = w[i]; if(dis[node] \u003e dis[t] + distance){ dis[node] = dis[t] + distance; // 2.1如果该节点被更新，入队。 if(!st[node]){ que.push(node); // 标记该节点 st[node] = true; } } } } if(dis[n] == 0x3f3f3f3f) return -1; else return dis[n]; } int main(){ cin \u003e\u003e n \u003e\u003e m; memset(h, -1, sizeof(h)); while(m--){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); } int t = spfa(); if(t == -1) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c t \u003c\u003c endl; return 0; } SPFA判断负环 用cnt数组记录从源点到该点最短距离经过的边数。 更新距离的过程中同时更新边数，dis[b] = dis[a] + w -\u003e cnt[b] = cnt[a] + 1 如果更新的cnt \u003e n则表示存在负环。 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:2:2","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"多源最短路 ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:3:0","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["算法基础课"],"content":"Floyd算法 基于动态规划d[k,i,j] = d[k-1,i,k]+d[k-1,k,j],k表示只经过1-\u003ek这些点 $O(n^3)$ 枚举中间变量k 枚举起点i，枚举终点j,d[i][j] = min(d[i][j], d[i][k] + d[k][j]) #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int N = 210, INF = 1e9; int n, m, q; int d[N][N]; void floyd(){ for(int k = 1; k \u003c= n; k++){ for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= n; j++){ d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } int main(){ cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= n; j++){ // 初始化自己到自己的距离0，自己到其他点的距离为无穷 if(i == j) d[i][j] = 0; else d[i][j] = INF; } } while(m-- ){ int a, b, w; cin \u003e\u003e a \u003e\u003e b \u003e\u003e w; d[a][b] = min(w, d[a][b]); } floyd(); while(q-- ){ int a, b; cin \u003e\u003e a \u003e\u003e b; if(d[a][b] \u003e INF / 2) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c d[a][b] \u003c\u003c endl; } return 0; } ","date":"2021-08-24","objectID":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/:3:1","tags":["算法基础课","leetcode","算法","最短路问题"],"title":"acwing基础课ch3-最短路问题","uri":"/ch3_%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"},{"categories":["每日一题"],"content":"787. K 站中转内最便宜的航班 Bellman_ford算法解决有边数限制的最短路问题 K站中转就是最多有k+1条边的最短路问题 acwing模板题 const int N = 110; const int M = N * N / 2; struct edge{ int a, b, w; edge(int x, int y, int z):a(x), b(y), w(z){}; edge(){}; }Edge[M]; class Solution { public: int bellman_ford(int n, int m, int k, int src, int dst){ int dis[N], backup[N]; // 初始化距离，并且设置起点为 0 memset(dis, 0x3f, sizeof(dis)); dis[src] = 0; for(int i = 0; i \u003c k + 1; i++){ // 备份 memcpy(backup, dis, sizeof(dis)); for(int j = 0; j \u003c m; j++){ int a = Edge[j].a, b = Edge[j].b, w = Edge[j].w; dis[b] = min(dis[b], backup[a] + w); // cout \u003c\u003c dis[dst] \u003c\u003c endl; } } if(dis[dst] == 0x3f3f3f3f) return -1; return dis[dst]; } int findCheapestPrice(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 flights, int src, int dst, int k) { int idx = 0; for(auto\u0026 flight: flights){ Edge[idx++] = edge{flight[0], flight[1], flight[2]}; } return bellman_ford(n, idx, k, src, dst); } }; ","date":"2021-08-24","objectID":"/lc787/:1:0","tags":["最短路问题","leetcode","算法","Bellman_ford"],"title":"lc787. K站中转内最便宜的航班","uri":"/lc787/"},{"categories":["每日一题"],"content":"1646. 获取生成数组中的最大值 分两种情况 奇数：nums[i] = nums[i / 2] 偶数：nums[i] = nums[i / 2] + nums[i / 2 + 1] ","date":"2021-08-23","objectID":"/lc1646/:1:0","tags":["模拟","leetcode","算法"],"title":"lc1646.获取生成数组中的最大值","uri":"/lc1646/"},{"categories":["每日一题"],"content":"模拟 class Solution { public: int getMaximumGenerated(int n) { if(n \u003c= 0) return 0; vector\u003cint\u003e nums(n + 1, 0); nums[1] = 1; int res = 1; for(int i = 2; i \u003c= n; i++){ if(i % 2 == 0){ nums[i] = nums[i / 2]; }else{ nums[i] = nums[i / 2] + nums[i / 2 + 1]; } res = max(res, nums[i]); } return res; } }; ","date":"2021-08-23","objectID":"/lc1646/:1:1","tags":["模拟","leetcode","算法"],"title":"lc1646.获取生成数组中的最大值","uri":"/lc1646/"},{"categories":["每日一题"],"content":"789. 逃脱阻碍者 起始点和阻碍者应该同时沿着最短路向目标移动。 由于类似于棋盘的网格状，因此最短路径距离就是曼哈顿距离。 存在以下三种情况。 存在任一阻碍者到达目标的最短路比起始点短，返回false 存在任一阻碍者到达目标的最短路与起始点相同，二者同时到达，返回false 所有阻碍者到达目标的最短路都比起始点远，则可以从起点到达目标点，返回true class Solution { public: int calmanhattanDistance(vector\u003cint\u003e\u0026 p1, vector\u003cint\u003e p2){ return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]); } bool escapeGhosts(vector\u003cvector\u003cint\u003e\u003e\u0026 ghosts, vector\u003cint\u003e\u0026 target) { int okDistance = calmanhattanDistance(target, {0, 0}); for(auto\u0026 ghost: ghosts){ int curDistance = calmanhattanDistance(target, ghost); if(curDistance \u003c= okDistance){ return false; } } return true; } }; ","date":"2021-08-22","objectID":"/lc789/:1:0","tags":["数学","leetcode","算法","最短路问题"],"title":"lc789.逃脱阻碍者","uri":"/lc789/"},{"categories":["每日一题"],"content":"443. 压缩字符串 ","date":"2021-08-21","objectID":"/lc443/:1:0","tags":["字符串","leetcode","算法","双指针"],"title":"lc443. 压缩字符串","uri":"/lc443/"},{"categories":["每日一题"],"content":"使用额外空间 两种情况进行判断是否需要在结果中添加该字符 如果该字符是最后一个字符 或者该字符与下一个字符不相同 $T:O(n)$ $S:O(n)$ class Solution { public: int compress(vector\u003cchar\u003e\u0026 chars) { int n = chars.size(), left = 0; string s; for(int i = 0; i \u003c n; i++){ if(i == n - 1 || chars[i] != chars[i + 1]){ s += chars[i]; int cnt = i - left + 1; left = i + 1; if(cnt == 1) continue; s += to_string(cnt); } } for(int i = 0; i \u003c s.size(); i++){ chars[i] = s[i]; } return s.size(); } }; ","date":"2021-08-21","objectID":"/lc443/:1:1","tags":["字符串","leetcode","算法","双指针"],"title":"lc443. 压缩字符串","uri":"/lc443/"},{"categories":["每日一题"],"content":"不使用额外空间 双指针 read指向已经读取的字符下标，write指向已经更新的压缩的字符下标 两种情况进行判断是否需要在结果中添加该字符 如果该字符是最后一个字符 或者该字符与下一个字符不相同 class Solution { public: int compress(vector\u003cchar\u003e\u0026 chars) { int write = 0, left = 0; int n = chars.size(); for(int read = 0; read \u003c n; read++ ){ // 如果是最后一个或者与下一个相等 if(read == n - 1 || chars[read] != chars[read + 1] ){ // 记录字母 chars[write++] = chars[read]; int cnt = read - left + 1; left = read + 1; // 如果只有一个字母跳过。 if(cnt == 1) continue; string s_cnt = to_string(cnt); for(int i = 0; i \u003c s_cnt.size(); i++){ chars[write++] = s_cnt[i]; } } } return write; } }; ","date":"2021-08-21","objectID":"/lc443/:1:2","tags":["字符串","leetcode","算法","双指针"],"title":"lc443. 压缩字符串","uri":"/lc443/"},{"categories":["每日一题"],"content":"541. 反转字符串 II 按照题意进行翻转即可，使用reverse传入泛型指针进行翻转 class Solution { public: string reverseStr(string s, int k) { int n = s.size(), cur = 0; while(cur + 2 * k \u003c n){ reverse(s.begin() + cur, s.begin() + cur + k); cur += 2 * k; } if(n - cur \u003c k){ reverse(s.begin() + cur, s.end()); }else{ reverse(s.begin() + cur, s.begin() + cur + k); } return s; } }; ","date":"2021-08-20","objectID":"/lc541/:1:0","tags":["字符串","leetcode","算法"],"title":"lc541.反转字符串II","uri":"/lc541/"},{"categories":["每日一题"],"content":"345. 反转字符串中的元音字母 ","date":"2021-08-19","objectID":"/lc345/:1:0","tags":["字符串","leetcode","算法","双指针"],"title":"lc345.反转字符串中的元音字母","uri":"/lc345/"},{"categories":["每日一题"],"content":"双指针 这里可以使用string.find(c)，如果找到了该字母返回该字母的下标，否则返回std::npos，这个是一个固定值。npos 是一个常数，用来表示不存在的位置。 i找到左边元音字母，j找到右边元音字母。 class Solution { public: string aeiou = \"aeiouAEIOU\"; string reverseVowels(string s) { for(int i = 0, j = s.size() - 1; i \u003c j;){ if(aeiou.find(s[i]) == aeiou.npos){ i++; continue; } if(aeiou.find(s[j]) == aeiou.npos){ j--; continue; } swap(s[i], s[j]); i++; j--; } return s; } }; ","date":"2021-08-19","objectID":"/lc345/:1:1","tags":["字符串","leetcode","算法","双指针"],"title":"lc345.反转字符串中的元音字母","uri":"/lc345/"},{"categories":["每日一题"],"content":"516. 最长回文子序列 ","date":"2021-08-12","objectID":"/lc516/:1:0","tags":["type","leetcode","算法"],"title":"lc516.最长回文子序列","uri":"/lc516/"},{"categories":["每日一题"],"content":"暴力 枚举所有的子序列(子集) $T:O(n2^n)$ class Solution { public: int ans = 1; void dfs(string\u0026 s, string\u0026 path, int idx){ // cout \u003c\u003c path \u003c\u003c endl; bool isok = true; for(int i = 0, j = path.size() - 1; i \u003c j; i++, j--){ if(path[i] != path[j]){ isok = false; break; } } if(isok) ans = max(ans, int(path.size())); for(int i = idx; i \u003c s.size(); i++){ path.push_back(s[i]); dfs(s, path, i + 1); path.pop_back(); } } int longestPalindromeSubseq(string s) { string path; dfs(s, path, 0); return ans; } }; ","date":"2021-08-12","objectID":"/lc516/:1:1","tags":["type","leetcode","算法"],"title":"lc516.最长回文子序列","uri":"/lc516/"},{"categories":["每日一题"],"content":"动态规划 状态定义：$f[i][j]$表示$i,j$之间的最长回文子序列的长度 状态转移:$f[i][j] = f[i+1][j-1] + 2,f[i]=f[j]$,$f[i][j] = max(f[i+1][j], f[i][j-1]), f[i]!=f[j]$ 注意这里状态转移会用到$i+1$所以不能从小到大进行枚举，需要大到小进行枚举 $T:O(n^2)$ class Solution { public: int longestPalindromeSubseq(string s) { int n = s.size(); vector\u003cvector\u003cint\u003e\u003e f(n, vector\u003cint\u003e(n, 0)); for(int i = n - 1; i \u003e= 0; i--){ f[i][i] = 1; for(int j = i + 1; j \u003c n; j++){ if(s[i] == s[j]){ f[i][j] = f[i + 1][j - 1] + 2; }else{ f[i][j] = max(f[i][j - 1], f[i + 1][j]); } } } return f[0][n - 1]; } }; ","date":"2021-08-12","objectID":"/lc516/:1:2","tags":["type","leetcode","算法"],"title":"lc516.最长回文子序列","uri":"/lc516/"},{"categories":["每日一题"],"content":"446. 等差数列划分 II - 子序列 ","date":"2021-08-11","objectID":"/lc446/:1:0","tags":["子集","leetcode","动态规划","等差数组"],"title":"lc446.等差数列划分 II - 子序列","uri":"/lc446/"},{"categories":["每日一题"],"content":"暴力枚举所有子序列 枚举子集就是枚举所有的子序列 typedef long long LL; class Solution { public: int ans = 0; void dfs(vector\u003cint\u003e\u0026 nums, vector\u003cLL\u003e\u0026 path, int cur){ if(path.size() \u003e= 3){ for(int i = 1; i \u003c path.size(); i++){ if(path[i] - path[i - 1] != path[1] - path[0]){ return; } } ans += 1; } for(int i = cur; i \u003c nums.size(); i++){ path.push_back(nums[i]); dfs(nums, path, i + 1); path.pop_back(); } } int numberOfArithmeticSlices(vector\u003cint\u003e\u0026 nums) { vector\u003cLL\u003e path; dfs(nums, path, 0); return ans; } }; ","date":"2021-08-11","objectID":"/lc446/:1:1","tags":["子集","leetcode","动态规划","等差数组"],"title":"lc446.等差数列划分 II - 子序列","uri":"/lc446/"},{"categories":["每日一题"],"content":"413. 等差数列划分 ","date":"2021-08-10","objectID":"/lc413/:1:0","tags":["双指针","leetcode","算法","等差数列"],"title":"lc413.等差数列划分","uri":"/lc413/"},{"categories":["每日一题"],"content":"暴力 枚举所有的子数组，之后对每一个数组进行判断是否满足等差数列的条件 $O(n^3)$：$O(n^2)$枚举所有数组，$O(n)$判断该数组是否满足条件 class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); int res = 0; for(int i = 0; i \u003c n; i++){ for(int j = i + 1; j \u003c n; j++){ if(isOk(i, j, nums)){ res += 1; } } } return res; } bool isOk(int x, int y, vector\u003cint\u003e\u0026 nums){ if(y - x + 1 \u003c 3) return false; int d = nums[x + 1] - nums[x]; for(int i = x + 2; i \u003c= y; i++){ if(nums[i] - nums[i - 1] != d){ return false; } } return true; } }; ","date":"2021-08-10","objectID":"/lc413/:1:1","tags":["双指针","leetcode","算法","等差数列"],"title":"lc413.等差数列划分","uri":"/lc413/"},{"categories":["每日一题"],"content":"双指针 枚举以$i$为起点的最长等差子序列 $i -\u003e j$为长度为$len$的等差数列 长度为$len$的等差数列包含$\\sum_{k = 3}^{k = len}$个的长度至少为3的等差子序列 其求和$\\sum_{k = 3}^{k = len}$为$a1 = 1, an = len - 3 + 1$的等差数列。 class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e\u0026 nums) { int res = 0, n = nums.size(); // 枚举以i为起点的最长等差子序列 for(int i = 0; i \u003c n - 1; ){ int j = i + 1; int d = nums[j] - nums[i]; // i -\u003e j为等差数列 while(j + 1 \u003c n \u0026\u0026 nums[j + 1] - nums[j] == d){ j++; } int len = j - i + 1; // 这里要注意：i之后为上一个等差数列的最后一个数j // 不是j+1,因为与j与j+1不能延长上一个等差数列，但是他们可以构成新的等差数列。 // 如 1 2 3 5 7 // 1 2 3 -\u003e i = 0, j = 2 // 之后 // 3 5 7 -\u003e i = 2, j = 4 i = j; if(len \u003c 3) continue; // i -\u003e j 构成了长为len的等差数列 // 长度为len的等差数列包含$\\sum_{k = 3}^{k = len}$所有的子序列 // 其求和为$a1 = 1, an = len - 3 + 1$的等差数列 int a1 = 1, an = len - 3 + 1; res += (a1 + an) * an / 2; } return res; } }; ","date":"2021-08-10","objectID":"/lc413/:1:2","tags":["双指针","leetcode","算法","等差数列"],"title":"lc413.等差数列划分","uri":"/lc413/"},{"categories":["每日一题"],"content":"802. 找到最终的安全状态 ","date":"2021-08-05","objectID":"/lc802/:1:0","tags":["图","leetcode","算法","拓扑排序"],"title":"lc802.找到最终的安全状态","uri":"/lc802/"},{"categories":["每日一题"],"content":"染色法(DFS) 理解题目的意思：无论怎么走必定到达终点 也就是说该节点不能与环相连接 三色标记 label[i]表示当前结点的状态 0: 未访问 1: 可以到达环，或者在环中 2: 可以在有限步到达终点，不会进入到环。 T:O(m+n) S:O(n) class Solution { public: // **理解题目的意思**：**无论怎么走**必定到达终点 // 也就是说该节点不能与环相连接 // 三色标记 label[i]表示当前结点的状态 // 0: 未访问 // 1: 可以到达环，或者在环中 // 2: 可以在有限步到达终点，不会进入到环。 // T:O(m+n) // S:O(n) vector\u003cint\u003e eventualSafeNodes(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { int n = graph.size(); vector\u003cint\u003e label(n, 0); function \u003cbool(int)\u003e safe = [\u0026](int x){ if(label[x] \u003e 0){ return label[x] == 2; } label[x] = 1; for(auto \u0026y :graph[x]){ if(safe(y) == false){ return false; } } label[x] = 2; return true; }; vector\u003cint\u003e res; for(int i = 0; i \u003c n; i++){ if(safe(i)){ res.push_back(i); } } return res; } }; ","date":"2021-08-05","objectID":"/lc802/:1:1","tags":["图","leetcode","算法","拓扑排序"],"title":"lc802.找到最终的安全状态","uri":"/lc802/"},{"categories":["每日一题"],"content":"拓扑排序 将所有边翻转，原来终点(出度为0)反转后入度为零 在环内或者可以到达环的点，反转后经过拓扑排序入度肯定不为0. class Solution { public: vector\u003cint\u003e eventualSafeNodes(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { int n = graph.size(); vector\u003cvector\u003cint\u003e\u003e rg(n, vector\u003cint\u003e()); vector\u003cint\u003e res; vector\u003cint\u003e indegree(n, 0); // 反向图 for(int i = 0; i \u003c n; i++){ auto node = graph[i]; for(auto\u0026 to_node: node){ rg[to_node].push_back(i); indegree[i] += 1; } } // 拓扑排序 queue\u003cint\u003e que; // 添加入度为0的点 for(int i = 0; i \u003c n; i++){ if(indegree[i] == 0){ que.push(i); } } while(!que.empty()){ int x = que.front(); que.pop(); for(auto\u0026 y: rg[x]){ indegree[y]--; if(indegree[y] == 0){ que.push(y); } } } // 把最后入度为0的点添加到结果集。 for(int i = 0; i \u003c n; i++){ if(indegree[i] == 0){ res.push_back(i); } } return res; } }; ","date":"2021-08-05","objectID":"/lc802/:1:2","tags":["图","leetcode","算法","拓扑排序"],"title":"lc802.找到最终的安全状态","uri":"/lc802/"},{"categories":["每日一题"],"content":"611.有效三角形的个数 ","date":"2021-08-04","objectID":"/lc611/:1:0","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"DFS超时 $T:O(2^n)$ class Solution { public: int res = 0; void dfs(vector\u003cint\u003e\u0026 nums, vector\u003cint\u003e\u0026 path, int idx){ if(path.size() \u003e= 3){ int a = path[0], b = path[1], c = path[2]; // cout \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c ' ' \u003c\u003c c \u003c\u003c ' ' \u003c\u003c res \u003c\u003c endl; if((a + b \u003e c) \u0026\u0026 (abs(a - b) \u003c c)){ res += 1; } return ; } for(int i = idx; i \u003c nums.size(); i++){ path.push_back(nums[i]); dfs(nums, path, i + 1); path.pop_back(); } } int triangleNumber(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e path; dfs(nums, path, 0); return res; } }; ","date":"2021-08-04","objectID":"/lc611/:1:1","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"暴力枚举 O(n^3) 超时 class Solution: def triangleNumber(self, nums: List[int]) -\u003e int: res = 0 n = len(nums) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): fisrt, second, third = nums[i], nums[j], nums[k] if fisrt + second \u003e third and abs(fisrt - second) \u003c third: res += 1 return res ","date":"2021-08-04","objectID":"/lc611/:1:2","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"预排序+双指针 注意逆向扫描，正向扫描不对，逆向扫描可以保证两边之差肯定小于第三边，只需要判断两边之和是否大于第三边。 如果l，r满足条件，则l-\u003er-1 与r构成的三角形都满足。 $T:O(n^2)$ class Solution { public: int triangleNumber(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); int res = 0; for(int i = nums.size() - 1; i \u003e= 0; i--){ int l = 0, r = i - 1; // 已经保证两数之差小于第三边 while(l \u003c r){ // 如果 l + r \u003e nums[i] // l -\u003e r - 1 与 r 以及num[i]肯定可以组成三角形 if(nums[l] + nums[r] \u003e nums[i]){ res += r - l; r -= 1; }else{ // 否则增大l边 l += 1; } } } return res; } }; ","date":"2021-08-04","objectID":"/lc611/:1:3","tags":["排序","leetcode","算法","双指针"],"title":"lc611.有效三角形的个数","uri":"/lc611/"},{"categories":["每日一题"],"content":"581. 最短无序连续子数组 ","date":"2021-08-03","objectID":"/lc581/:1:0","tags":["双指针","leetcode","算法"],"title":"lc581.最短无序连续子数组","uri":"/lc581/"},{"categories":["每日一题"],"content":"排序+双指针 T:O(nlogn) class Solution { public: int findUnsortedSubarray(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e cpy(nums.begin(), nums.end()); sort(cpy.begin(), cpy.end()); int l = -1, r = nums.size(); for(int i = 0; i \u003c nums.size(); i++){ if(nums[i] == cpy[i]){ l = i; }else{ break; } } if(l == nums.size() - 1) return 0; for(int i = nums.size() - 1; i \u003e= 0; i--){ if(nums[i] == cpy[i]){ r = i; }else{ break; } } return r - l - 1; } }; 找规律 T:O(n) 一次遍历，最大的数决定右边界，最小的数决定左边界。 class Solution { public: int findUnsortedSubarray(vector\u003cint\u003e\u0026 nums) { // 一次遍历，最大的数决定右边界，最小的数决定左边界。 // 数组可以分为3部分numsA, numsB, numsC; // numsB重新排序可以将整个数组变为升序排列。 // 对于numsA中每一个数numsA[i] \u003c numB[j]/numsC[j], j \u003e i; // 从右向左遍历数组，记录右边的最小值 // 如果当前数比最小值大，则该数的位置为左边界 int minx = INT_MAX, left = -1; for(int i = nums.size() - 1; i \u003e= 0; i--){ if(minx \u003c nums[i]){ left = i; }else{ minx = nums[i]; } } int maxx = INT_MIN, right = nums.size() - 1; for(int i = 0; i \u003c nums.size(); i++){ if(maxx \u003e nums[i]){ right = i; }else{ maxx = nums[i]; } } if(left == -1) return 0; return right - left + 1; } }; ","date":"2021-08-03","objectID":"/lc581/:1:1","tags":["双指针","leetcode","算法"],"title":"lc581.最短无序连续子数组","uri":"/lc581/"},{"categories":["每日一题"],"content":"743. 网络延迟时间 ","date":"2021-08-02","objectID":"/lc743/:1:0","tags":["图","leetcode","算法","最短路问题"],"title":"lc743.网络延迟时间","uri":"/lc743/"},{"categories":["每日一题"],"content":"dijkstra最短路问题 题意为找距离k最短路径中的最大值作为传递时间 Cpp Tips:在对象内初始化vector注意事项 class内部成员vector\u003cint\u003e x(n, 0)不可以使用，这样会被编译器认为是返回值为vector\u003cint\u003e的成员函数，报错unknown type. 但是可以通过复制构造函数进行构造c++11/c++15 参考链接 class t{ public: // vector\u003cint\u003e s(5, 0); // 编译错误，unknown type of 5 vector\u003cint\u003e s = vector\u003cint\u003e(5, 0); // 复制构造函数 } 稠密图：朴素dijkstra() T:O(mn + n*n) const int N = 110, M = 6100; class Solution { public: int h[N], e[M], w[M], ne[M]; bool vis[N]; int dis[N]; int idx = 0, n = 0; int dijkstra(int k){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[k] = 0; // dijkstra找到距离起点最短距离的最长路径(无堆优化) // T: O(nm) for(int i = 0; i \u003c n; i++){ int find = -1; for(int j = 1; j \u003c= n; j++){ if(vis[j] == false \u0026\u0026 (find == -1 || dis[j] \u003c dis[find] )){ find = j; } } vis[find] = true; for(int u = h[find]; u != -1; u = ne[u]){ int x = e[u]; dis[x] = min(dis[find] + w[u], dis[x]); } } for(int i = 1; i \u003c= n ; i++){ if(dis[i] == 0x3f3f3f3f) return -1; } return *max_element(dis+1, dis+n+1); } int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e\u0026 times, int n_, int k) { n = n_; for(int i = 1; i \u003c= n; i++){ h[i] = -1; } for(auto\u0026 edge: times){ add(edge[0], edge[1], edge[2]); } int res = dijkstra(k); if(res != -1){ return res; }else{ return -1; } } void add(int a, int b, int w_){ e[idx] = b; w[idx] = w_; ne[idx] = h[a]; h[a] = idx++; } }; 稀疏图：堆优化dijkstra() T:O(nlogm) const int N = 110, M = 6100; typedef pair\u003cint, int\u003e PII; class Solution { public: int h[N], e[M], w[M], ne[M]; bool vis[N]; int dis[N]; int idx = 0, n = 0; int dijkstra(int k){ memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[k] = 0; // dijkstra堆优化，优化找最短路径的过程 // 稀疏图 // T: O(mlogn) priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e \u003e heap; heap.push({dis[k], k}); while(heap.size()){ auto t = heap.top(); heap.pop(); int distance = t.first, node = t.second; if(vis[node]) continue; vis[node] = true; for(int u = h[node]; u != -1; u = ne[u]){ int x = e[u]; if(dis[x] \u003e dis[node] + w[u]){ dis[x] = dis[node] + w[u]; heap.push({dis[x], x}); } } } for(int i = 1; i \u003c= n ; i++){ if(dis[i] == 0x3f3f3f3f) return -1; } return *max_element(dis+1, dis+n+1); } int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e\u0026 times, int n_, int k) { n = n_; for(int i = 1; i \u003c= n; i++){ h[i] = -1; } for(auto\u0026 edge: times){ add(edge[0], edge[1], edge[2]); } int res = dijkstra(k); if(res != -1){ return res; }else{ return -1; } } void add(int a, int b, int w_){ e[idx] = b; w[idx] = w_; ne[idx] = h[a]; h[a] = idx++; } }; ","date":"2021-08-02","objectID":"/lc743/:1:1","tags":["图","leetcode","算法","最短路问题"],"title":"lc743.网络延迟时间","uri":"/lc743/"},{"categories":["每日一题"],"content":"987. 二叉树的垂序遍历 利用三元组记录每个节点[列，行，节点值] 之后进行排序，默认的排序方式就是先按列从小到大排序，再按行从小到大排序，最后按节点值排序 这里用到了c++的元组tuple，元组像pair一样。 构造可以使用列表推导的方式进行构造tuple\u003cint, float, int\u003e t = {1, 1.0, 2}; 但是元组直接访问元素很复杂，使用std::get\u003cidx\u003e(t);,返回值是引用可以直接修改。 get的参数必须是编译是的常数(constant) for each循环可以对tuple直接进行解包，for(const auto\u0026 [n1, n2, n3]: rec) std::tie(n1, n2, n3) = t可以tuple中每个值的引用 c++17标准auto [n1, n2, n3] = t /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ typedef pair\u003cint, int\u003e PII; typedef tuple\u003cint, int, int\u003e TIII; class Solution { public: vector\u003cTIII\u003e rec; void dfs(PII cur, TreeNode* root){ if(root == nullptr){ return; } // 列, 行, 节点值 rec.push_back({cur.second, cur.first, root-\u003eval}); dfs({cur.first + 1, cur.second - 1}, root-\u003eleft); dfs({cur.first + 1, cur.second + 1}, root-\u003eright); } vector\u003cvector\u003cint\u003e\u003e verticalTraversal(TreeNode* root) { dfs({0, 0}, root); vector\u003c vector\u003cint\u003e\u003e res; sort(rec.begin(), rec.end()); int pre = INT_MIN, idx = -1; for(const auto\u0026 [col, row, val]: rec){ if(idx == -1 || pre != col){ res.push_back({}); idx += 1; } res[idx].push_back(val); pre = col; } return res; } }; ","date":"2021-07-31","objectID":"/lc987/:1:0","tags":["二叉树","leetcode","算法"],"title":"lc987.二叉树的垂序遍历","uri":"/lc987/"},{"categories":["每日一题"],"content":"171. Excel 表列序号 ","date":"2021-07-30","objectID":"/lc171/:1:0","tags":["进制转换","算法","leetcode"],"title":"lc171.Excel表列序号","uri":"/lc171/"},{"categories":["每日一题"],"content":"正向遍历 class Solution { public: int titleToNumber(string columnTitle) { // 正向遍历-\u003e叠加权重 int ans = 0, n = columnTitle.size(); for(int i = 0; i \u003c n; i++){ ans = columnTitle[i] - 'A' + ans * 26 + 1; } return ans; } }; ","date":"2021-07-30","objectID":"/lc171/:1:1","tags":["进制转换","算法","leetcode"],"title":"lc171.Excel表列序号","uri":"/lc171/"},{"categories":["每日一题"],"content":"反向遍历 计算每一位的权重 class Solution { public: int titleToNumber(string columnTitle) { // 反向-\u003e计算位权重 int ans = 0, n = columnTitle.size(); long long weight = 1; for(int i = n - 1; i \u003e= 0; i--){ ans += (columnTitle[i] - 'A' + 1) * weight; weight *= 26; } return ans; } }; ","date":"2021-07-30","objectID":"/lc171/:1:2","tags":["进制转换","算法","leetcode"],"title":"lc171.Excel表列序号","uri":"/lc171/"},{"categories":["每日一题"],"content":"1104. 二叉树寻路 ","date":"2021-07-29","objectID":"/lc1104/:1:0","tags":["二叉树","leetcode","算法"],"title":"lc1104.二叉树寻路","uri":"/lc1104/"},{"categories":["每日一题"],"content":"完全二叉树规律 $i_{father} = i_{child}/2$ 所以先找到该节点对称的结点，再利用完全二叉树的规律即可 完全二叉树一行的开始是$2^{row - 1}$,结束是$2^{row}-1$ 下一行的开始是$2^{row}$ class Solution { public: vector\u003cint\u003e pathInZigZagTree(int label) { if(label == 1){ return {label}; } // rowStart 是这一行的开始 2**(row - 1) // rowStart * 2 是下一行的开始 2**row // 这一行的结束就是rowStart - 1 = 2**row-1 int row = 1, rowStart = 1; while(rowStart * 2 \u003c= label){ row += 1; rowStart *= 2; } vector\u003cint\u003e res(row, 0); while(row){ res[row - 1] = label; // 找到对称结点除以2,就是父亲节点 label = (rowStart * 2 - 1 - label + rowStart) / 2; rowStart /= 2; row -= 1; } return res; } }; ","date":"2021-07-29","objectID":"/lc1104/:1:1","tags":["二叉树","leetcode","算法"],"title":"lc1104.二叉树寻路","uri":"/lc1104/"},{"categories":["每日一题"],"content":"1337. 矩阵中战斗力最弱的 K 行 ","date":"2021-07-29","objectID":"/lc1337/:1:0","tags":["堆","二分查找","leetcode","算法"],"title":"lc1337.矩阵中战斗力最弱的K行","uri":"/lc1337/"},{"categories":["每日一题"],"content":"二分查找+topK 1总是排在前面，所以我们只需要通过二分查找找到最后一个1的位置。 再利用最小堆找出topK小的数 T:O(mlogn+klogm) O(mlogn):二分查找 O(m):构建优先队列，参考：https://www.zhihu.com/question/20729324 O(klogm):topK typedef pair\u003cint, int\u003e PII; class Solution { public: vector\u003cint\u003e kWeakestRows(vector\u003cvector\u003cint\u003e\u003e\u0026 mat, int k) { // O(mlogn):二分查找 vector\u003cPII\u003e cmp; for(int i = 0; i \u003c mat.size(); i++){ int l = -1, r = mat[i].size() - 1; while(l \u003c r){ int mid = (l + r + 1) \u003e\u003e 1; if(mat[i][mid] == 1){ l = mid; }else{ r = mid - 1; } } cmp.push_back({l, i}); } // O(m):构建优先队列 priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e\u003e q(cmp.begin(), cmp.end()); vector\u003cint\u003e ans; // O(klogm):topK for (int i = 0; i \u003c k; ++i) { ans.push_back(q.top().second); q.pop(); } return ans; } }; ","date":"2021-07-29","objectID":"/lc1337/:1:1","tags":["堆","二分查找","leetcode","算法"],"title":"lc1337.矩阵中战斗力最弱的K行","uri":"/lc1337/"},{"categories":["每日一题"],"content":"678. 有效的括号字符串 使用两个栈分别记录左括号和星号（栈内记录其下标），遇到右括号时，首先匹配左括号栈，之后匹配星号栈。 对于左括号栈和星号栈的剩余部分，需要星号匹配左括号，所以星号的下标应该大于左括号。从栈顶开始比较两个栈的下标。 class Solution { public: bool checkValidString(string s) { int cnt = 0; stack\u003cint\u003e l_st; stack\u003cint\u003e s_st; for(int i = 0; i \u003c s.size(); i++){ if(s[i] == '('){ l_st.push(i); }else if(s[i] == '*'){ s_st.push(i); } if(s[i] == ')'){ if(!l_st.empty()){ l_st.pop(); }else if(!s_st.empty()){ s_st.pop(); }else{ return false; } } } while(!l_st.empty()){ if(s_st.empty()){ return false; } if(l_st.top() \u003c s_st.top()){ l_st.pop(); s_st.pop(); }else{ return false; } } return true; } }; ","date":"2021-07-29","objectID":"/lc678/:1:0","tags":["栈","leetcode","算法"],"title":"lc678.有效的括号字符串","uri":"/lc678/"}]