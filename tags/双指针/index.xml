<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>双指针 - 标签 - stonex</title>
        <link>https://sheny1xuan.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
        <description>双指针 - 标签 - stonex</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>sheny1xuan@163.com (Shen)</managingEditor>
            <webMaster>sheny1xuan@163.com (Shen)</webMaster><lastBuildDate>Wed, 01 Sep 2021 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://sheny1xuan.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="self" type="application/rss+xml" /><item>
    <title>lc165. 比较版本号</title>
    <link>https://sheny1xuan.github.io/lc165/</link>
    <pubDate>Wed, 01 Sep 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc165/</guid>
    <description><![CDATA[165. 比较版本号 split后双指针比较 先对字符串做split提取出每个小的版本号 之后对每个小版本号进行比较即可。 $T:O(n)$ $S:O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14]]></description>
</item><item>
    <title>lc881. 救生艇</title>
    <link>https://sheny1xuan.github.io/lc881/</link>
    <pubDate>Thu, 26 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc881/</guid>
    <description><![CDATA[881. 救生艇 贪心+双指针 $T:O(nlogn)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int numRescueBoats(vector&lt;int&gt;&amp; people, int limit) { sort(people.begin(), people.end()); int n = people.size(), cnt = 0; // 双指针+贪心 // 从小到大进行排序 //]]></description>
</item><item>
    <title>acwing基础课ch1-双指针</title>
    <link>https://sheny1xuan.github.io/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/</link>
    <pubDate>Tue, 24 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/ch1_%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
    <description><![CDATA[双指针 两个序列双指针 归并排序 一个序列同向双指针 双指针利用某种性质将暴力(n^2)的算法优化到O(n). 实现split() 最长连续不重复子序列]]></description>
</item><item>
    <title>lc443. 压缩字符串</title>
    <link>https://sheny1xuan.github.io/lc443/</link>
    <pubDate>Sat, 21 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc443/</guid>
    <description><![CDATA[443. 压缩字符串 使用额外空间 两种情况进行判断是否需要在结果中添加该字符 如果该字符是最后一个字符 或者该字符与下一个字符不相同 $T:O(n)$ $S:O(n)$ 1 2 3 4 5 6 7 8 9]]></description>
</item><item>
    <title>lc345.反转字符串中的元音字母</title>
    <link>https://sheny1xuan.github.io/lc345/</link>
    <pubDate>Thu, 19 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc345/</guid>
    <description><![CDATA[345. 反转字符串中的元音字母 双指针 这里可以使用string.find(c)，如果找到了该字母返回该字母的下标，否则返回std::npos，这个是]]></description>
</item><item>
    <title>lc413.等差数列划分</title>
    <link>https://sheny1xuan.github.io/lc413/</link>
    <pubDate>Tue, 10 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc413/</guid>
    <description><![CDATA[413. 等差数列划分 暴力 枚举所有的子数组，之后对每一个数组进行判断是否满足等差数列的条件 $O(n^3)$：$O(n^2)$枚举所有数组，$O(n)]]></description>
</item><item>
    <title>lc611.有效三角形的个数</title>
    <link>https://sheny1xuan.github.io/lc611/</link>
    <pubDate>Wed, 04 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc611/</guid>
    <description><![CDATA[611.有效三角形的个数 DFS超时 $T:O(2^n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int res = 0; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path, int idx){ if(path.size() &gt;= 3){ int a = path[0], b = path[1],]]></description>
</item><item>
    <title>lc581.最短无序连续子数组</title>
    <link>https://sheny1xuan.github.io/lc581/</link>
    <pubDate>Tue, 03 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://sheny1xuan.github.io/lc581/</guid>
    <description><![CDATA[581. 最短无序连续子数组 排序+双指针 T:O(nlogn) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; cpy(nums.begin(), nums.end()); sort(cpy.begin(), cpy.end()); int l = -1, r = nums.size(); for(int i = 0; i]]></description>
</item></channel>
</rss>
